<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>git常见操作2-查看历史改动</title>
      <link href="/2024/04/07/git%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C2-%E6%9F%A5%E7%9C%8B%E5%8E%86%E5%8F%B2%E6%94%B9%E5%8A%A8/"/>
      <url>/2024/04/07/git%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C2-%E6%9F%A5%E7%9C%8B%E5%8E%86%E5%8F%B2%E6%94%B9%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="查看单个文件历史改动">查看单个文件历史改动</h2><h3 id="命令行-p选项">命令行-p选项</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> -- filename <span class="comment"># 不显示具体的改动内容</span></span><br><span class="line">git <span class="built_in">log</span> -p -- filename <span class="comment"># 显示具体的改动内容</span></span><br></pre></td></tr></table></figure><p>比如某个仓库共有如下4次提交历史：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --oneline --all --graph</span><br><span class="line">* 841c6cd (HEAD -&gt; master) 同时修改A/B.java</span><br><span class="line">* 67aeb5a 修改B.java</span><br><span class="line">* e792004 修改A.java</span><br><span class="line">* df23fd5 First Commit</span><br></pre></td></tr></table></figure><p>其中第一次提交中新增了<code>A.java</code>和<code>B.java</code>两个文件。</p><p>如果我们希望查看哪些提交中改动了文件<code>A.java</code>，可以通过如下的命令实现：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> -- A.java</span><br><span class="line">commit 841c6cdf0e944f3b32dd62fbe6ab902454f03733 (HEAD -&gt; master)</span><br><span class="line">Author: TerryLikesCoding &lt;18328621355@163.com&gt;</span><br><span class="line">Date:   Sun Apr 7 16:15:31 2024 +0800</span><br><span class="line"></span><br><span class="line">    同时修改A/B.java</span><br><span class="line"></span><br><span class="line">commit e7920046eef378eca3c34c1228ba253bc4b2c686</span><br><span class="line">Author: TerryLikesCoding &lt;18328621355@163.com&gt;</span><br><span class="line">Date:   Sun Apr 7 16:13:22 2024 +0800</span><br><span class="line"></span><br><span class="line">    修改A.java</span><br><span class="line"></span><br><span class="line">commit df23fd5d74982047163443150743add9936c63df</span><br><span class="line">Author: TerryLikesCoding &lt;18328621355@163.com&gt;</span><br><span class="line">Date:   Sun Apr 7 16:12:35 2024 +0800</span><br><span class="line"></span><br><span class="line">    First Commit <span class="comment"># 新增了`A.java`和`B.java`两个文件</span></span><br></pre></td></tr></table></figure><p>但是上面的输出中并不会显示每一次改动修改的内容，如果希望显示每次改动的内容，可以添加<code>-p</code>选项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> -p -- A.java</span><br><span class="line">commit 841c6cdf0e944f3b32dd62fbe6ab902454f03733 (HEAD -&gt; master)</span><br><span class="line">Author: TerryLikesCoding &lt;18328621355@163.com&gt;</span><br><span class="line">Date:   Sun Apr 7 16:15:31 2024 +0800</span><br><span class="line"></span><br><span class="line">    同时修改A/B.java</span><br><span class="line"></span><br><span class="line">diff --git a/A.java b/A.java</span><br><span class="line">index 5f2f16b..4f142ee 100644</span><br><span class="line">--- a/A.java</span><br><span class="line">+++ b/A.java</span><br><span class="line">@@ -1 +1,2 @@</span><br><span class="line"> 1111</span><br><span class="line">+2222</span><br><span class="line"></span><br><span class="line">commit e7920046eef378eca3c34c1228ba253bc4b2c686</span><br><span class="line">Author: TerryLikesCoding &lt;18328621355@163.com&gt;</span><br><span class="line">Date:   Sun Apr 7 16:13:22 2024 +0800</span><br><span class="line"></span><br><span class="line">    修改A.java</span><br><span class="line"></span><br><span class="line">diff --git a/A.java b/A.java</span><br><span class="line">index e69de29..5f2f16b 100644</span><br><span class="line">--- a/A.java</span><br><span class="line">+++ b/A.java</span><br><span class="line">@@ -0,0 +1 @@</span><br><span class="line">+1111</span><br><span class="line"></span><br><span class="line">commit df23fd5d74982047163443150743add9936c63df</span><br><span class="line">Author: TerryLikesCoding &lt;18328621355@163.com&gt;</span><br><span class="line">Date:   Sun Apr 7 16:12:35 2024 +0800</span><br><span class="line"></span><br><span class="line">    First Commit</span><br><span class="line"></span><br><span class="line">diff --git a/A.java b/A.java</span><br><span class="line">new file mode 100644 <span class="comment"># 新增文件</span></span><br><span class="line">index 0000000..e69de29</span><br></pre></td></tr></table></figure><h3 id="命令行–follow选项">命令行–follow选项</h3><p>假设我们在后续某次操作中，将文件<code>A.java</code>重命名为<code>A1.java</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">mv</span> A.java A1.java</span><br><span class="line"></span><br><span class="line">MINGW64 /d/tmp/git-playground (master)</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git restore --staged &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line">        renamed:    A.java -&gt; A1.java</span><br><span class="line"></span><br><span class="line">$ git commit -m <span class="string">&#x27;修改文件名：A.java -&gt; A1.java&#x27;</span></span><br><span class="line">[master fea443b] 修改文件名：A.java -&gt; A1.java</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> rename A.java =&gt; A1.java (100%)</span><br></pre></td></tr></table></figure><p>然后我们在后续的修改中，修了<code>A1.java</code>的内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ git show 3356864</span><br><span class="line">commit 3356864626403629df5cf2378b273c8457433192 (HEAD -&gt; master)</span><br><span class="line">Author: TerryLikesCoding &lt;18328621355@163.com&gt;</span><br><span class="line">Date:   Sun Apr 7 16:41:32 2024 +0800</span><br><span class="line"></span><br><span class="line">    修改A1.java</span><br><span class="line"></span><br><span class="line">diff --git a/A1.java b/A1.java</span><br><span class="line">index 4f142ee..e0037f0 100644</span><br><span class="line">--- a/A1.java</span><br><span class="line">+++ b/A1.java</span><br><span class="line">@@ -1,2 +1,3 @@</span><br><span class="line"> 1111</span><br><span class="line"> 2222</span><br><span class="line">+3333</span><br></pre></td></tr></table></figure><p>完整的git历史如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --all --oneline</span><br><span class="line">3356864 (HEAD -&gt; master) 修改A1.java</span><br><span class="line">fea443b 修改文件名：A.java -&gt; A1.java</span><br><span class="line">841c6cd 同时修改A/B.java</span><br><span class="line">67aeb5a 修改B.java</span><br><span class="line">e792004 修改A.java</span><br><span class="line">df23fd5 First Commit</span><br></pre></td></tr></table></figure><p>如果使用命令不添加<code>--follow</code>选项，则输出的历史如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span>  --oneline -- A1.java</span><br><span class="line">3356864 (HEAD -&gt; master) 修改A1.java</span><br><span class="line">fea443b 修改文件名：A.java -&gt; A1.java</span><br></pre></td></tr></table></figure><p>可以看到，并不包含<code>3356864</code>这一次针对重命名前针对文件<code>A.java</code>的更改。如果我们添加上<code>--follow</code>选项，则输出如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span>  --oneline --follow -- A1.java</span><br><span class="line">3356864 (HEAD -&gt; master) 修改A1.java</span><br><span class="line">fea443b 修改文件名：A.java -&gt; A1.java</span><br><span class="line">841c6cd 同时修改A/B.java</span><br><span class="line">e792004 修改A.java</span><br><span class="line">df23fd5 First Commit</span><br></pre></td></tr></table></figure><p><code>A1.java</code>所有的修改记录（包括重命名之前的都可以查看到）。</p><blockquote><p>注意：如果反过来：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span>  --oneline -- A.java</span><br><span class="line">fea443b 修改文件名：A.java -&gt; A1.java</span><br><span class="line">841c6cd 同时修改A/B.java</span><br><span class="line">e792004 修改A.java</span><br><span class="line">df23fd5 First Commit</span><br><span class="line"></span><br><span class="line">$ git <span class="built_in">log</span>  --oneline --follow -- A.java</span><br><span class="line">fea443b 修改文件名：A.java -&gt; A1.java</span><br><span class="line">841c6cd 同时修改A/B.java</span><br><span class="line">e792004 修改A.java</span><br><span class="line">df23fd5 First Commit</span><br></pre></td></tr></table></figure><blockquote><p>则重命名后针对<code>A1.java</code>的改动不会显示。</p></blockquote></blockquote><h3 id="使用gitk可视化查看">使用gitk可视化查看</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gitk A1.java</span><br><span class="line">gitk --follow A1.java</span><br></pre></td></tr></table></figure><blockquote><p><code>--follow</code>的含义同上</p></blockquote><p>比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitk --follow A1.java</span><br></pre></td></tr></table></figure><p><img src="./git%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C2-%E6%9F%A5%E7%9C%8B%E5%8E%86%E5%8F%B2%E6%94%B9%E5%8A%A8/image-20240407171009269.png" alt="image-20240407171009269"></p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git工具-7-gitk</title>
      <link href="/2024/04/07/git%E5%B7%A5%E5%85%B7-7-gitk/"/>
      <url>/2024/04/07/git%E5%B7%A5%E5%85%B7-7-gitk/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git常见操作1-对比</title>
      <link href="/2024/04/07/git%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C1-%E5%AF%B9%E6%AF%94/"/>
      <url>/2024/04/07/git%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C1-%E5%AF%B9%E6%AF%94/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git工具-8-cherrypick</title>
      <link href="/2024/04/03/git%E5%B7%A5%E5%85%B7-8-cherrypick/"/>
      <url>/2024/04/03/git%E5%B7%A5%E5%85%B7-8-cherrypick/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是cherry-pick">什么是cherry-pick?</h2><p><code>cherry-pick</code>是一个强大的Git命令，用于<strong>将一个或多个其他分支的提交应用到当前分支</strong>。这个命令让你能够<strong>选择性地拾取</strong>某个分支上的<strong>提交</strong>（即”<strong>樱桃挑选</strong>”或&quot;<strong>拣选</strong>&quot;），<strong>而不是通过合并或重置操作引入整个分支的更改</strong>。</p><p>git 中的<code>cherry-pick</code>类似于对<strong>特定的某次提交的变基</strong>。 它会提取该提交的补丁，之后尝试将其重新应用到当前分支上。</p><h2 id="使用场景">使用场景</h2><ul class="lvl-0"><li class="lvl-2"><p>当你想将一个特定的修复从一个分支（如<code>main</code>）应用到另一个分支（如发布分支）时，而<strong>不需要引入</strong>中间的<strong>所有提交</strong>。</p></li><li class="lvl-2"><p>在处理大型项目时，如果<strong>只需要</strong>某个分支上的<strong>一个小更改</strong>而<strong>不是整个分支的合并</strong>。</p></li><li class="lvl-2"><p>在回滚特定的提交时，可以用于将该提交的<strong>反向更改</strong>应用到当前分支上。</p></li></ul><h2 id="基本用法">基本用法</h2><h3 id="pick单个提交">pick单个提交</h3><p>假设我们有如下的提交历史：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MINGW64 /d/tmp/git-playground (ruby_client)</span><br><span class="line">$ git <span class="built_in">log</span> --all --oneline --graph</span><br><span class="line">* 43cd18a (HEAD -&gt; ruby_client) 5ddae</span><br><span class="line">* 9f671cd e43a6</span><br><span class="line">| * c0bdf4c (master) f42c5</span><br><span class="line">|/</span><br><span class="line">* 0fa9f4c a6b4c</span><br><span class="line">* 513c20b 0b743</span><br></pre></td></tr></table></figure><p><img src="./git%E5%B7%A5%E5%85%B7-8-cherrypick/image-20240415162356204.png" alt="image-20240415162356204"></p><p><img src="./git%E5%B7%A5%E5%85%B7-8-cherrypick/image-20240415162409086.png" alt="image-20240415162409086"></p><p>如果你希望将提交<code>e43a6</code> 拉取到 <code>master</code> 分支，你可以运行如下命令：</p><p>首先查看该次提交的内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git show 9f671cd</span><br><span class="line">commit 9f671cd9bf8c7fbae4a11a63fae89c32b401523b</span><br><span class="line">Author: TerryLikesCoding &lt;18328621355@163.com&gt;</span><br><span class="line">Date:   Mon Apr 15 16:20:46 2024 +0800</span><br><span class="line"></span><br><span class="line">    e43a6</span><br><span class="line"></span><br><span class="line">diff --git a/index.html b/index.html</span><br><span class="line">index e69de29..793f0b4 100644</span><br><span class="line">--- a/index.html</span><br><span class="line">+++ b/index.html</span><br><span class="line">@@ -0,0 +1 @@</span><br><span class="line">+&lt;!DOCTYPE&gt;</span><br></pre></td></tr></table></figure><p>此次的改动内容：往<code>index.html</code>文件中添加了一行<code>&lt;!DOCTYPE&gt;</code>,然后切换到<code>master</code>分支，执行如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MINGW64 /d/tmp/git-playground (ruby_client)</span><br><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">&#x27;master&#x27;</span></span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cat</span> index.html</span><br><span class="line"><span class="comment"># cherry-pick前内容为空</span></span><br><span class="line"></span><br><span class="line">$ git cherry-pick 9f671cd</span><br><span class="line">[master b9951e5] e43a6</span><br><span class="line"> Date: Mon Apr 15 16:20:46 2024 +0800</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><p>执行完成<code>cherry-pick</code>后，查看仓库的状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MINGW64 /d/tmp/git-playground (master)</span><br><span class="line">$ <span class="built_in">cat</span> index.html</span><br><span class="line">&lt;!DOCTYPE&gt;</span><br></pre></td></tr></table></figure><p>提交<code>e43a6</code>的变动内容已经合并到<code>master</code>分支,此时查看<code>git log</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> MINGW64 /d/tmp/git-playground (master)</span><br><span class="line">$ git <span class="built_in">log</span> --all --oneline --graph</span><br><span class="line">* b9951e5 (HEAD -&gt; master) e43a6</span><br><span class="line">* c0bdf4c f42c5</span><br><span class="line">| * 43cd18a (ruby_client) 5ddae</span><br><span class="line">| * 9f671cd e43a6</span><br><span class="line">|/</span><br><span class="line">* 0fa9f4c a6b4c</span><br><span class="line">* 513c20b 0b743</span><br></pre></td></tr></table></figure><p><img src="./git%E5%B7%A5%E5%85%B7-8-cherrypick/image-20240415163342779.png" alt="image-20240415163342779"></p><p>这样会拉取和 <code>e43a6</code> 相同的更改，但是因为应用的日期不同，你会得到一个<strong>新的提交 SHA-1 值</strong>。现在你的历史会变成这样：</p><p><img src="./git%E5%B7%A5%E5%85%B7-8-cherrypick/image-20240415163532390.png" alt="image-20240415163532390"></p><h3 id="pick多个提交">pick多个提交</h3><ul class="lvl-0"><li class="lvl-2"><p><strong>多个提交</strong>：可以连续列出多个提交哈希值，也可以使用范围操作符，如<code>git cherry-pick startHash^..endHash</code>，这将拾取从<code>startHash</code>到<code>endHash</code>之间的所有提交（包括<code>endHash</code>，但不包括<code>startHash</code>）。</p></li></ul><h2 id="注意事项">注意事项</h2><ul class="lvl-0"><li class="lvl-2"><p><strong>冲突</strong>：<code>git cherry-pick</code>可能会引起冲突，就像合并操作一样。如果发生冲突，Git会停止应用提交，让你解决冲突。解决后，你需要使用<code>git cherry-pick --continue</code>来继续应用提交。</p></li><li class="lvl-2"><p><strong>选择性地引入更改</strong>：虽然<code>cherry-pick</code>提供了高度的选择性，但它也可能导致分支历史混乱，尤其是当被拾取的提交依赖于其他未被拾取的更改时。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git工具-7-diff</title>
      <link href="/2024/04/03/git%E5%B7%A5%E5%85%B7-7-diff/"/>
      <url>/2024/04/03/git%E5%B7%A5%E5%85%B7-7-diff/</url>
      
        <content type="html"><![CDATA[<h2 id="概览">概览</h2><p><img src="image-20240403163022847.png" alt="image-20240403163022847"></p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git工具-6-checkout</title>
      <link href="/2024/04/03/git%E5%B7%A5%E5%85%B7-6-checkout/"/>
      <url>/2024/04/03/git%E5%B7%A5%E5%85%B7-6-checkout/</url>
      
        <content type="html"><![CDATA[<h2 id="检出与重置的区别">检出与重置的区别</h2><p>和 <code>reset</code> 一样，<code>checkout</code> 也操纵<strong>三棵树</strong>，不过它<strong>有一点不同</strong>，这取决于你<strong>是否传给该命令一个文件路径</strong>。</p><h2 id="不带路径检出">不带路径检出</h2><p>运行 <code>git checkout [branch]</code> 与运行 <code>git reset --hard [branch]</code> <strong>非常相似</strong>，它会更新所有<strong>三棵树</strong>使其看起来像 <code>[branch]</code>，不过有<strong>两点重要的区别</strong>：</p><ul class="lvl-0"><li class="lvl-2"><p>首先不同于 <code>reset --hard</code>，<code>checkout</code> <strong>对工作目录是安全的</strong>，它会通过<strong>检查来确保不会将已更改的文件吹走</strong>。 其实它还更聪明一些。它会在工作目录中先<strong>试着简单合并一下</strong>，这样所有_还未修改过的_文件都会被更新。 而 <code>reset --hard</code> 则会不做检查就全面地替换所有东西。</p></li><li class="lvl-2"><p>第二个重要的区别是<strong>如何更新</strong> <code>HEAD</code>。 <code>reset</code> 会移动 <code>HEAD</code> <strong>分支的指向</strong>，而 <code>checkout</code> 只会<strong>移动</strong> <code>HEAD</code> <strong>自身</strong>来指向另一个分支。</p></li></ul><p>例如，假设我们有 <code>master</code> 和 <code>develop</code> 分支，它们分别指向不同的提交；我们现在在 <code>develop</code> 上（所以 <code>HEAD</code> 指向它）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --all --oneline --graph</span><br><span class="line">* 3e57e67 (HEAD -&gt; develop) commit B</span><br><span class="line">* a08141d (master) commit A</span><br></pre></td></tr></table></figure><p><img src="image-20240403160341122.png" alt="image-20240403160341122"></p><p>如果我们运行 <code>git reset master</code>，那么 <code>develop</code> 自身现在会和 <code>master</code> 指向同一个提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MINGW64 /d/tmp/git-playground1 (develop)</span><br><span class="line">$ git reset master</span><br><span class="line"></span><br><span class="line">MINGW64 /d/tmp/git-playground1 (develop)</span><br><span class="line">$ git <span class="built_in">log</span> --all --oneline --graph</span><br><span class="line">* a08141d (HEAD -&gt; develop, master) commit A</span><br></pre></td></tr></table></figure><p><img src="image-20240403160420938.png" alt="image-20240403160420938"></p><p>而如果我们运行 <code>git checkout master</code> 的话，<code>develop</code> 不会移动，<code>HEAD</code> 自身会移动。 现在 <code>HEAD</code> 将会指向 <code>master</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MINGW64 /d/tmp/git-playground2 (develop) <span class="comment"># develop分支</span></span><br><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">&#x27;master&#x27;</span></span><br><span class="line"></span><br><span class="line">MINGW64 /d/tmp/git-playground2 (master) <span class="comment"># master分支</span></span><br><span class="line">$ git <span class="built_in">log</span> --all --oneline --graph</span><br><span class="line">* 3e57e67 (develop) commit B</span><br><span class="line">* a08141d (HEAD -&gt; master) commit A</span><br></pre></td></tr></table></figure><p><img src="image-20240403160454963.png" alt="image-20240403160454963"></p><p>所以，虽然在这两种情况下我们都移动 <code>HEAD</code> 使其指向了提交 A，但_做法_是非常不同的。 <code>reset</code> 会移动 <code>HEAD</code> 分支的指向（比如上面的<code>develop</code>指针），而 <code>checkout</code> 则移动 <code>HEAD</code> 自身，不移动<code>develop</code>指针。</p><h2 id="带路径检出">带路径检出</h2><p>运行 <code>checkout</code> 的另一种方式就是<strong>指定一个文件路径</strong>，这会像 <code>reset</code> 一样<strong>不会移动</strong> <code>HEAD</code>。</p><p>它就像 <code>git reset [branch] file</code> 那样用<strong>该次提交中的那个文件</strong>来<strong>更新索引</strong>（<code>Index</code>），但是它也<strong>会覆盖工作目录中对应的文件</strong>。 它就像是 <code>git reset --hard [branch] file</code>（如果 <code>reset</code> 允许你这样运行的话）- 这样对工作目录并不安全，它也不会移动 <code>HEAD</code>。</p><p>此外，同 <code>git reset</code> 和 <code>git add</code> 一样，<code>checkout</code> 也接受一个 <code>--patch</code> 选项，允许你根据选择一块一块地恢复文件内容。</p><h2 id="总结">总结</h2><p>希望你现在熟悉并理解了 <code>reset</code> 命令，不过关于它和 <code>checkout</code> 之间的区别，你可能还是会有点困惑，毕竟不太可能记住不同调用的所有规则。</p><p>下面的速查表列出了命令对树的影响。 “<code>HEAD</code>” 一列中的 “<code>REF</code>” 表示该命令移动了 HEAD 指向的分支引用，而<code>HEAD</code> 则表示只移动了 <code>HEAD</code> 自身。 特别注意 <em>WD Safe?</em> 一列 - 如果它标记为 <strong>NO</strong>，那么运行该命令之前请考虑一下。</p><table><thead><tr><th style="text-align:left"></th><th style="text-align:left">HEAD</th><th style="text-align:left">Index</th><th style="text-align:left">Workdir</th><th style="text-align:left">WD Safe?</th></tr></thead><tbody><tr><td style="text-align:left"><strong>Commit Level</strong></td><td style="text-align:left" colspan="4"></td></tr><tr><td style="text-align:left"><code>reset --soft [commit]</code></td><td style="text-align:left" rowspan="3">REF</td><td style="text-align:left">NO</td><td style="text-align:left" rowspan="2">NO</td><td style="text-align:left" rowspan="2">YES</td></tr><tr><td style="text-align:left"><code>reset [commit]</code></td><td style="text-align:left" rowspan="3">YES</td></tr><tr><td style="text-align:left"><code>reset --hard [commit]</code></td><td style="text-align:left" rowspan="2">YES</td><td style="text-align:left"><strong>NO</strong></td></tr><tr><td style="text-align:left"><code>checkout [commit]</code></td><td style="text-align:left">HEAD</td><td style="text-align:left">YES</td></tr><tr><td style="text-align:left"><strong>File Level</strong></td><td style="text-align:left" colspan="4"></td></tr><tr><td style="text-align:left"><code>reset (commit) [file]</code></td><td style="text-align:left" rowspan="2">NO</td><td style="text-align:left" rowspan="2">YES</td><td style="text-align:left">NO</td><td style="text-align:left">YES</td></tr><tr><td style="text-align:left"><code>checkout (commit) [file]</code></td><td style="text-align:left">YES</td><td style="text-align:left"><strong>NO</strong></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git工具-5-重置揭密</title>
      <link href="/2024/04/02/git%E5%B7%A5%E5%85%B7-5-%E9%87%8D%E7%BD%AE%E6%8F%AD%E5%AF%86/"/>
      <url>/2024/04/02/git%E5%B7%A5%E5%85%B7-5-%E9%87%8D%E7%BD%AE%E6%8F%AD%E5%AF%86/</url>
      
        <content type="html"><![CDATA[<h2 id="git中的三颗树">git中的三颗树</h2><p>理解 <code>reset</code> 和 <code>checkout</code> 的最简方法，就是以 Git 的思维框架（将其作为内容管理器）来管理三棵不同的树。 “<strong>树</strong>” 在我们这里的实际意思是 “<strong>文件的集合</strong>”，而<strong>不是指特定的数据结构</strong>。 （在某些情况下索引看起来并不像一棵树，不过我们现在的目的是用简单的方式思考它。）</p><p>Git 作为一个系统，是以它的一般操作来管理并操纵这三棵树的：</p><table><thead><tr><th style="text-align:left">树</th><th style="text-align:left">用途</th></tr></thead><tbody><tr><td style="text-align:left">HEAD</td><td style="text-align:left">上一次提交的快照，下一次提交的父结点</td></tr><tr><td style="text-align:left">Index</td><td style="text-align:left">预期的下一次提交的<strong>快照</strong></td></tr><tr><td style="text-align:left">Working Directory</td><td style="text-align:left">沙盒</td></tr></tbody></table><h3 id="HEAD">HEAD</h3><p><code>HEAD</code> 是<strong>当前分支引用</strong>的指针，它总是指向该分支上的<strong>最后一次提交</strong>。 这表示 <strong>HEAD</strong> 将是<strong>下一次提交的父结点（父提交）</strong>。 通常，理解 <code>HEAD</code> 的最简方式，就是将它看做<strong>你的上一次提交</strong>的快照。</p><p>比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MINGW64 /d/coding/git-playground (master)</span><br><span class="line">$ git <span class="built_in">log</span> --all --oneline --graph</span><br><span class="line">* ce592c7 (HEAD -&gt; master) 剔除误提交的文件</span><br><span class="line">* ddfa328 删除误提交的文件</span><br><span class="line">* 0be6ec6 添加2个文件</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>本例中，<code>HEAD</code>指针指向当前分支<code>master</code>的最后一次提交<code>ce592c7</code>，可以通过<code>cat-file</code> 与 <code>ls-tree</code>来查看该指针：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -p HEAD</span><br><span class="line">tree 477422fcec1bd9e1853d1270e0cbf7ea23e47f1f</span><br><span class="line">parent ddfa32845e5d6c247feaf7d29929cc3ddbb374dc</span><br><span class="line">author slimterry &lt;slimterry@qq.com&gt; 1712025707 +0800</span><br><span class="line">committer slimterry &lt;slimterry@qq.com&gt; 1712025795 +0800</span><br><span class="line"></span><br><span class="line">剔除误提交的文件</span><br><span class="line"></span><br><span class="line">$ git ls-tree -r HEAD</span><br><span class="line">100644 blob 148e347a33cd2aafb4e6aff5db9c55619693e25f    .gitignore</span><br><span class="line">100644 blob cb2417e0dc35491097e241451d4400cf9913632e    A.java</span><br><span class="line">100644 blob 2ace6f50f4e42509f12a61db477c722965f56120    B.java</span><br><span class="line">100644 blob 3bd9bce7058fdf7b9809c5a87053a5270c6a75ea    C.java</span><br><span class="line">100644 blob e69de29bb2d1d6434b8b29ae775ad8c2e48c5391    D.java</span><br><span class="line">100644 blob b7d9ae7ac5e402d486cd2d93f6dd0792eae483ed    app.properties</span><br><span class="line">100644 blob e69de29bb2d1d6434b8b29ae775ad8c2e48c5391    bar.txt</span><br><span class="line">100644 blob e69de29bb2d1d6434b8b29ae775ad8c2e48c5391    foo.txt</span><br></pre></td></tr></table></figure><p><code>cat-file</code> 与 <code>ls-tree</code> 是底层命令，它们一般用于底层工作，在日常工作中并不使用。不过它们能帮助我们了解到底发生了什么,其作用说明如下：</p><blockquote><ul class="lvl-1"><li class="lvl-2"><p><code>git-ls-tree</code> :-List the contents of a tree object,<code>-r</code> :Recurse into sub-trees.</p></li><li class="lvl-2"><p><code>git-cat-file</code> : Provide contents or <strong>details of repository objects</strong>,<code>-p</code>:Pretty-print the contents of <code>&lt;object&gt;</code> based on its type.</p></li></ul></blockquote><p>也可以通过<code>git show</code>命令查看该对象：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">commit ce592c7e11b6ece40d224d7902e35a292d217597 (HEAD -&gt; master)</span><br><span class="line">Author: slimterry &lt;slimterry@qq.com&gt;</span><br><span class="line">Date:   Tue Apr 2 10:41:47 2024 +0800</span><br><span class="line"></span><br><span class="line">    剔除误提交的文件</span><br><span class="line"></span><br><span class="line">diff --git a/bar.txt b/bar.txt</span><br><span class="line">new file mode 100644</span><br><span class="line">index 0000000..e69de29</span><br></pre></td></tr></table></figure><h3 id="INDEX-索引">INDEX (索引)</h3><p>索引是你的 <strong>预期的下一次提交</strong>。 我们也会将这个概念引用为 Git 的 “<strong>暂存区域</strong>”，这就是当你运行 <code>git commit</code> 时 Git 看起来的样子,可以通过<code>git ls-files</code>查看快照内容。</p><p>Git 将上一次检出到工作目录中的所有文件填充到<strong>索引区（暂存区）</strong>，它们看起来就像最初被检出时的样子。 之后你会将其中一些文件替换为新版本，接着通过 <code>git commit</code> 将它们<strong>转换为树</strong>来用作新的提交。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git status -s</span><br><span class="line">?? index.html <span class="comment"># 未追踪的文件</span></span><br><span class="line"></span><br><span class="line">$ git ls-files -s</span><br><span class="line">100644 148e347a33cd2aafb4e6aff5db9c55619693e25f 0       .gitignore</span><br><span class="line">100644 cb2417e0dc35491097e241451d4400cf9913632e 0       A.java</span><br><span class="line">100644 2ace6f50f4e42509f12a61db477c722965f56120 0       B.java</span><br><span class="line">100644 3bd9bce7058fdf7b9809c5a87053a5270c6a75ea 0       C.java</span><br><span class="line">100644 e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 0       D.java</span><br><span class="line">100644 b7d9ae7ac5e402d486cd2d93f6dd0792eae483ed 0       app.properties</span><br><span class="line">100644 e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 0       bar.txt</span><br><span class="line">100644 e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 0       foo.txt</span><br></pre></td></tr></table></figure><blockquote><p><code>git-ls-files</code> - Show information about files <strong>in the index and the working tree</strong></p><p><code>-s</code></p><p><code>--stage</code></p><p>Show staged contents’ mode bits, object name and stage number in the output.</p></blockquote><p>注意：本例中未追踪的文件<code>index.html</code>并不会显示在 <code>git ls-files</code>的输出中，因为它并<strong>未被索引（暂存）</strong>。</p><h3 id="工作目录">工作目录</h3><p>最后，你就有了自己的工作目录。 另外两棵树以一种<strong>高效但并不直观</strong>的方式，将它们的内容存储在 <code>.git</code> 文件夹中。 <strong>工作目录</strong>会将它们<strong>解包为实际的文件以便编辑</strong>。 你可以把工作目录当做 <strong>沙盒</strong>。在你将修改提交到暂存区并记录到历史之前，可以随意更改。</p><h2 id="git工作流程">git工作流程</h2><p>Git 主要的目的是通过操纵<strong>这三棵树</strong>来以更加连续的状态记录项目的<strong>快照</strong>。</p><p><img src="image-20240402150853129.png" alt="image-20240402150853129"></p><p>让我们来可视化这个过程：假设我们进入到一个新目录，其中有一个文件。 我们称其为该文件的 <strong>v1</strong> 版本，将它标记为蓝色。 现在运行 <code>git init</code>，这会创建一个 Git 仓库。<img src="image-20240402151102760.png" alt="image-20240402151102760"></p><p>此时其中的 <code>HEAD</code> 尚未存在：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> MINGW64 /d/tmp/git-playground (master)</span><br><span class="line">$ git cat-file -p HEAD</span><br><span class="line">fatal: Not a valid object name HEAD</span><br></pre></td></tr></table></figure><p>此时的<code>Index</code>(<strong>暂存区</strong>)内容也为空：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> MINGW64 /d/tmp/git-playground (master)</span><br><span class="line">$  git ls-files -s</span><br><span class="line"><span class="comment"># nothing ...</span></span><br></pre></td></tr></table></figure><p>此时，只有工作目录有内容:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ll</span><br><span class="line">total 0</span><br><span class="line">-rw-r--r-- 1 86182 197609 0  4月  2 15:12 file.txt</span><br><span class="line"></span><br><span class="line">$ git status -s</span><br><span class="line">?? file.txt  <span class="comment"># 未追踪</span></span><br></pre></td></tr></table></figure><p>现在我们想要提交这个文件，所以用 <code>git add</code> 来获取工作目录中的内容，并将其复制到<strong>索引</strong>中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git add file.txt</span><br><span class="line"></span><br><span class="line">$ git status -s</span><br><span class="line">A  file.txt</span><br><span class="line"></span><br><span class="line">$ git ls-files -s</span><br><span class="line">100644 e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 0       file.txt</span><br></pre></td></tr></table></figure><p>可以看到，此时<code>Index</code>(<strong>暂存区</strong>)内容中已经包含了文件 <code>file.txt</code>，但是仍然没有<code>HEAD</code>指针：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -p HEAD</span><br><span class="line">fatal: Not a valid object name HEAD</span><br></pre></td></tr></table></figure><p><img src="image-20240402152442006.png" alt="image-20240402152442006"></p><p>接着运行 <code>git commit</code>，它首先会<strong>移除索引中</strong>(<code>Index</code>)<strong>的内容</strong>并将它保存为一个永久的快照，然后创建一个指向该快照的提交对象，最后更新 <code>master</code> 来指向本次提交。</p><p><img src="image-20240402152550110.png" alt="image-20240402152550110"></p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m <span class="string">&#x27;提交file.txt&#x27;</span></span><br><span class="line">[master (root-commit) 7dccb2a] 提交file.txt</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 file.txt</span><br></pre></td></tr></table></figure><p>此时查看<code>HEAD</code>指针的内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -p HEAD</span><br><span class="line">tree bdd68b0120ca91384c1606468b4ca81b8f67c728</span><br><span class="line">author slimterry &lt;slimterry@qq.com&gt; 1712042812 +0800</span><br><span class="line">committer slimterry &lt;slimterry@qq.com&gt; 1712042812 +0800</span><br><span class="line"></span><br><span class="line">提交file.txt</span><br><span class="line"></span><br><span class="line">$ git ls-tree HEAD</span><br><span class="line">100644 blob e69de29bb2d1d6434b8b29ae775ad8c2e48c5391    file.txt</span><br></pre></td></tr></table></figure><p>查看<code>Index</code>的内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git ls-files -s</span><br><span class="line">100644 e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 0       file.txt</span><br></pre></td></tr></table></figure><p>此时如果我们运行 <code>git status</code>，会发现没有任何改动，因为现在三棵树完全相同:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><p>现在我们想要对文件进行修改然后提交它。 我们将会经历同样的过程；首先在工作目录中修改文件。 我们称其为该文件的 <strong>v2</strong> 版本，并将它标记为红色。</p><p>修改文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;111111&#x27;</span> &gt; file.txt</span><br><span class="line"></span><br><span class="line">$ git status -s</span><br><span class="line"> M file.txt</span><br></pre></td></tr></table></figure><p><img src="image-20240402153235775.png" alt="image-20240402153235775"></p><p>如果现在运行 <code>git status</code>，我们会看到文件显示在 “Changes not staged for commit,” 下面并被标记为红色，因为该条目在索引与工作目录之间存在不同。 接着我们运行 <code>git add</code> 来将它暂存到索引中:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git restore &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">        modified:   file.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">&quot;git add&quot;</span> and/or <span class="string">&quot;git commit -a&quot;</span>)</span><br><span class="line"></span><br><span class="line">$ git add file.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="image-20240402153359163.png" alt="image-20240402153359163"></p><p>此时，由于索引(<code>Index</code>/暂存区)和 <code>HEAD</code> 不同，若运行 <code>git status</code> 的话就会看到 “Changes to be committed” 下的该文件变为绿色 ——也就是说，现在预期的下一次提交与上一次提交不同。 最后，我们运行 <code>git commit</code> 来完成提交。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git restore --staged &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line">        modified:   file.txt</span><br><span class="line"></span><br><span class="line">$ git commit -m <span class="string">&#x27;修改file.txt文件&#x27;</span></span><br><span class="line">[master 6f722b3] 修改file.txt文件</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><p><img src="image-20240402153637450.png" alt="image-20240402153637450"></p><p>现在运行 <code>git status</code> 会没有输出，因为三棵树又变得相同了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line"></span><br><span class="line"> MINGW64 /d/tmp/git-playground (master)</span><br><span class="line">$ git ls-files -s <span class="comment"># 查看暂存区（索引）的内容</span></span><br><span class="line">100644 90d2950097fa1850b6f692ab1095ec9cdd3f7fae 0       file.txt</span><br><span class="line"></span><br><span class="line">MINGW64 /d/tmp/git-playground (master)</span><br><span class="line">$ git ls-tree -r HEAD <span class="comment"># 查看HEAD指针的内容</span></span><br><span class="line">100644 blob 90d2950097fa1850b6f692ab1095ec9cdd3f7fae    file.txt</span><br><span class="line"></span><br><span class="line"> MINGW64 /d/tmp/git-playground (master)</span><br><span class="line">$ ll <span class="comment"># 查看工作区内容</span></span><br><span class="line">total 1</span><br><span class="line">-rw-r--r-- 1 86182 197609 7  4月  2 15:32 file.txt </span><br><span class="line"></span><br><span class="line">$ git <span class="built_in">log</span> --all --oneline --graph</span><br><span class="line">* 6f722b3 (HEAD -&gt; master) 修改file.txt文件</span><br><span class="line">* 7dccb2a 提交file.txt</span><br></pre></td></tr></table></figure><p>切换分支或克隆的过程也类似。 当检出一个分支时，它会修改 <strong>HEAD</strong> 指向新的分支引用，将<strong>索引</strong>填充为该次提交的快照，然后将 <strong>索引</strong>的内容复制到 <strong>工作目录</strong> 中。</p><h2 id="3种reset模式">3种reset模式</h2><p>在以下情景中观察 <code>reset</code> 命令会更有意义。为了演示这些例子，我们分三次修改了<code>file.txt</code>文件，其提交历史如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;v1&#x27;</span> &gt; file.txt</span><br><span class="line">$ git commit -m <span class="string">&#x27;v1&#x27;</span></span><br><span class="line">[master (root-commit) d4d805e] v1</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 file.txt</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;v2&#x27;</span> &gt;&gt; file.txt</span><br><span class="line">$ git commit -am <span class="string">&#x27;v2&#x27;</span></span><br><span class="line">[master 448db38] v2</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;v3&#x27;</span> &gt;&gt; file.txt</span><br><span class="line">$ git commit -am <span class="string">&#x27;v3&#x27;</span></span><br><span class="line">[master 5789903] v3</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"></span><br><span class="line">$ git <span class="built_in">log</span> --all --oneline</span><br><span class="line">5789903 (HEAD -&gt; master) v3</span><br><span class="line">448db38 v2</span><br><span class="line">d4d805e v1</span><br></pre></td></tr></table></figure><p>三次提交后，文件内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> file.txt</span><br><span class="line">v1</span><br><span class="line">v2</span><br><span class="line">v3</span><br></pre></td></tr></table></figure><p>此时git仓库的三棵树的示意图如下：</p><p><img src="image-20240402154435434.png" alt="image-20240402154435434"></p><p>查看此时的<code>HEAD</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -p HEAD</span><br><span class="line">tree 8cd6823441b40b1947ed4e1fa1fde8fb0a2b3f8c</span><br><span class="line">parent 448db38045cbfdcd17f66f97cdd27398c1851a36</span><br><span class="line">author slimterry &lt;slimterry@qq.com&gt; 1712108715 +0800</span><br><span class="line">committer slimterry &lt;slimterry@qq.com&gt; 1712108715 +0800</span><br><span class="line"></span><br><span class="line">v3</span><br><span class="line"></span><br><span class="line">$ git ls-tree 8cd6823441b40b1947ed4e1fa1fde8fb0a2b3f8c</span><br><span class="line">100644 blob 4b1d4d4b660c400875dd122de217e942f481a378    file.txt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ git show 4b1d4d4b660c400875dd122de217e942f481a378</span><br><span class="line">v1</span><br><span class="line">v2</span><br><span class="line">v3</span><br></pre></td></tr></table></figure><p>查看<code>Index</code>中的内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git ls-files -s</span><br><span class="line">100644 4b1d4d4b660c400875dd122de217e942f481a378 0       file.txt</span><br><span class="line"></span><br><span class="line">$ git show 4b1d4d4b660c400875dd122de217e942f481a378</span><br><span class="line">v1</span><br><span class="line">v2</span><br><span class="line">v3</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到，此时<code>HEAD</code>、<code>Index</code>、<strong>工作区</strong>的内容完全一致，此时：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><p>接下来我们将如上的仓库分<strong>复制三份</strong>，分别演示如下三种不同的<code>reset</code>模式。</p><h3 id="第-1种模式-soft-仅移动HEAD">第 1种模式 --soft(仅移动HEAD)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --soft HEAD~</span><br><span class="line"></span><br><span class="line">$ git <span class="built_in">log</span> --all --oneline --graph</span><br><span class="line">* 448db38 (HEAD -&gt; master) v2</span><br><span class="line">* d4d805e v1</span><br></pre></td></tr></table></figure><p>可以看出：提交<code>v3</code>被撤销了，此时我们再查看三棵树的内容：</p><p><code>HEAD</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -p HEAD</span><br><span class="line">tree 967592420c3025aa7a647ce3eab8bf51cde4f9d1</span><br><span class="line">parent d4d805e23832f896eefb9b8d21f9ec0f632b433a</span><br><span class="line">author slimterry &lt;slimterry@qq.com&gt; 1712108693 +0800</span><br><span class="line">committer slimterry &lt;slimterry@qq.com&gt; 1712108693 +0800</span><br><span class="line"></span><br><span class="line">v2</span><br><span class="line"></span><br><span class="line">$ git ls-tree 967592420c3025aa7a647ce3eab8bf51cde4f9d1</span><br><span class="line">100644 blob 2139d8be699ff388ab3ec85008a3906675ac67cb    file.txt</span><br><span class="line"></span><br><span class="line">$ git show 2139d8be699ff388ab3ec85008a3906675ac67cb</span><br><span class="line">v1</span><br><span class="line">v2</span><br></pre></td></tr></table></figure><p><code>Index</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git ls-files -s</span><br><span class="line">100644 4b1d4d4b660c400875dd122de217e942f481a378 0       file.txt</span><br><span class="line"></span><br><span class="line">$ git show 4b1d4d4b660c400875dd122de217e942f481a378</span><br><span class="line">v1</span><br><span class="line">v2</span><br><span class="line">v3</span><br></pre></td></tr></table></figure><p>工作区：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> file.txt</span><br><span class="line">v1</span><br><span class="line">v2</span><br><span class="line">v3</span><br></pre></td></tr></table></figure><p>此时的git仓库示意图如下：</p><p><img src="image-20240402161245015.png" alt="image-20240402161245015"></p><p>现在看一眼上图，理解一下发生的事情：它本质上是<strong>撤销了上一次</strong> <code>git commit</code> 命令，<code>Index</code>和工作区的内容不变，仍然是<code>v3</code>版本。因为<code>HEAD</code>与<code>Index</code>的内容不一致，因此如果此时我们运行<code>git status</code>命令，会有如下的输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git restore --staged &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line">        modified:   file.txt</span><br></pre></td></tr></table></figure><p>因为：</p><p><img src="image-20240403102446226.png" alt="image-20240403102446226"></p><h3 id="第2种：更新索引-–mixed">第2种：更新索引(–mixed)</h3><p>该模式为<strong>默认的模式</strong>，即如下<strong>2个命令</strong>等价:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset HEAD~</span><br><span class="line">$ git reset --mixed HEAD~</span><br></pre></td></tr></table></figure><p>执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --mixed HEAD~</span><br><span class="line">Unstaged changes after reset:</span><br><span class="line">M       file.txt</span><br></pre></td></tr></table></figure><p>此时观察三棵树的状态：</p><p><code>HEAD</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -p HEAD</span><br><span class="line">tree 967592420c3025aa7a647ce3eab8bf51cde4f9d1</span><br><span class="line">parent d4d805e23832f896eefb9b8d21f9ec0f632b433a</span><br><span class="line">author slimterry &lt;slimterry@qq.com&gt; 1712108693 +0800</span><br><span class="line">committer slimterry &lt;slimterry@qq.com&gt; 1712108693 +0800</span><br><span class="line"></span><br><span class="line">v2</span><br><span class="line"></span><br><span class="line">$ git ls-tree 967592420c3025aa7a647ce3eab8bf51cde4f9d1</span><br><span class="line">100644 blob 2139d8be699ff388ab3ec85008a3906675ac67cb    file.txt</span><br><span class="line"></span><br><span class="line">$ git show 2139d8be699ff388ab3ec85008a3906675ac67cb</span><br><span class="line">v1</span><br><span class="line">v2</span><br></pre></td></tr></table></figure><p><code>Index</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git ls-files -s</span><br><span class="line">100644 2139d8be699ff388ab3ec85008a3906675ac67cb 0       file.txt</span><br><span class="line"></span><br><span class="line">$ git show 2139d8be699ff388ab3ec85008a3906675ac67cb</span><br><span class="line">v1</span><br><span class="line">v2</span><br></pre></td></tr></table></figure><p>工作区：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> file.txt</span><br><span class="line">v1</span><br><span class="line">v2</span><br><span class="line">v3</span><br></pre></td></tr></table></figure><p>可以看到<code>HEAD</code>指针被移动到<code>v2</code>版本，且<code>Index</code>也被置位和<code>HEAD</code>相同的内容，此时仓库的示意图如下：</p><p><img src="image-20240403092045753.png" alt="image-20240403092045753"></p><p>在再看一眼上图，理解一下发生的事情：</p><ol><li class="lvl-3"><p>它依然会<strong>撤销</strong>一上次 <code>提交</code>（因为<code>HEAD</code>指针移动了）</p></li><li class="lvl-3"><p>但还会<strong>取消暂存</strong> 所有的东西（索引的内容被重置为<code>v2</code>版本的）</p></li><li class="lvl-3"><p>工作区的<code>v3</code>版本的改动仍然存在</p></li></ol><p>于是，我们回滚到了所有 <code>git add</code> 和 <code>git commit</code> 的命令执行之前。此时工作区和<code>Index</code>内容不一致，执行<code>git status</code>的结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git restore &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">        modified:   file.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">&quot;git add&quot;</span> and/or <span class="string">&quot;git commit -a&quot;</span>)</span><br></pre></td></tr></table></figure><p>因为：</p><p><img src="image-20240403105420398.png" alt="image-20240403105420398"></p><h3 id="第3种-hard（不可恢复）">第3种 --hard（不可恢复）</h3><p>执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard HEAD~</span><br><span class="line">HEAD is now at 448db38 v2</span><br></pre></td></tr></table></figure><p>此时查看三棵树：</p><p><code>HEAD</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -p HEAD</span><br><span class="line">tree 967592420c3025aa7a647ce3eab8bf51cde4f9d1</span><br><span class="line">parent d4d805e23832f896eefb9b8d21f9ec0f632b433a</span><br><span class="line">author slimterry &lt;slimterry@qq.com&gt; 1712108693 +0800</span><br><span class="line">committer slimterry &lt;slimterry@qq.com&gt; 1712108693 +0800</span><br><span class="line"></span><br><span class="line">v2</span><br><span class="line"></span><br><span class="line">$ git ls-tree 967592420c3025aa7a647ce3eab8bf51cde4f9d1</span><br><span class="line">100644 blob 2139d8be699ff388ab3ec85008a3906675ac67cb    file.txt</span><br><span class="line"></span><br><span class="line">$ git show 2139d8be699ff388ab3ec85008a3906675ac67cb</span><br><span class="line">v1</span><br><span class="line">v2</span><br></pre></td></tr></table></figure><p><code>Index</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git ls-files -s</span><br><span class="line">100644 2139d8be699ff388ab3ec85008a3906675ac67cb 0       file.txt</span><br><span class="line"></span><br><span class="line">$ git show 2139d8be699ff388ab3ec85008a3906675ac67cb</span><br><span class="line">v1</span><br><span class="line">v2</span><br></pre></td></tr></table></figure><p>工作区：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> file.txt</span><br><span class="line">v1</span><br><span class="line">v2</span><br></pre></td></tr></table></figure><p>可以看到三棵树的状态完全一致,因此此时执行<code>git status</code>命令结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><p>此时git仓库的示意图如下：</p><p><img src="image-20240402162049568.png" alt="image-20240402162049568"></p><p><code>--hard</code> 标记撤销了最后的提交、<code>git add</code> 和 <code>git commit</code> 命令<strong>以及</strong>工作目录中的<strong>所有工作</strong>。</p><p>必须注意，<code>--hard</code> 标记是 <code>reset</code> 命令唯一的<strong>危险用法</strong>，它也是 Git 会<strong>真正地销毁数据</strong>的仅有的几个操作之一。 其他任何形式的 <code>reset</code> 调用都可以轻松撤消，但是 <code>--hard</code> 选项不能，因为它强制覆盖了工作目录中的文件。</p><blockquote><p>在这种特殊情况下，我们的 Git 数据库中的一个提交内还留有该文件的 <strong>v3</strong> 版本，我们可以通过 <code>reflog</code> 来找回它。<strong>但是若该文件还未提交</strong>，Git 仍会覆盖它从而导致无法恢复。</p><p>本例中的改动之前已经提交过，因此还可以通过<code>reflog</code>找到对应的<code>commit id</code>，然后检出后回退：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git reflog</span><br><span class="line">448db38 (HEAD -&gt; master) HEAD@&#123;0&#125;: reset: moving to HEAD~</span><br><span class="line">5789903 HEAD@&#123;1&#125;: commit: v3</span><br><span class="line">448db38 (HEAD -&gt; master) HEAD@&#123;2&#125;: commit: v2</span><br><span class="line">d4d805e HEAD@&#123;3&#125;: commit (initial): v1</span><br><span class="line"></span><br><span class="line">$ git checkout 5789903</span><br><span class="line">Note: switching to <span class="string">&#x27;5789903&#x27;</span>.</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cat</span> file.txt</span><br><span class="line">v1</span><br><span class="line">v2</span><br><span class="line">v3 <span class="comment"># 改动被找回</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="总结">总结</h3><ul class="lvl-0"><li class="lvl-2"><p><code>--soft</code> ： 只移动<code>HEAD</code> ,<strong>最后一次提交中的文件</strong>变为已暂存（<code>staged</code>）</p></li><li class="lvl-2"><p><code>--mixed</code> 移动<code>HEAD</code>，而且将<code>Index</code>置为和<code>HEAD</code>一样的内容，<strong>最后一次提交中的文件</strong>变为<strong>待暂存</strong></p></li><li class="lvl-2"><p><code>--hard</code>  移动<code>HEAD</code>，将<code>Index</code>和工作区内容置为和<code>HEAD</code>一样的内容，最后一次提交的内容<strong>被完全清除</strong></p><blockquote><p>需要通过<code>reflog</code>才能找回</p></blockquote></li></ul><p><code>reset</code> 命令会以特定的顺序重写这三棵树，在你指定以下选项时停止：</p><ol><li class="lvl-3"><p>移动 <code>HEAD</code> 分支的指向 <em>（若指定了 <code>--soft</code>，则到此停止）</em></p></li><li class="lvl-3"><p>使**索引（暂存区）**看起来像 <code>HEAD</code> <em>（若未指定 <code>--hard</code>，则到此停止）</em></p></li><li class="lvl-3"><p>使工作目录看起来像索引（指定 了<code>--hard</code>）</p></li></ol><p>重置前：</p><p><img src="image-20240402154435434.png" alt="image-20240402154435434"></p><p>重置后：</p><p><img src="image-20240403094148992.png" alt="image-20240403094148992"></p><h2 id="通过路径来重置">通过路径来重置</h2><h3 id="将某个文件恢复成上一个版本">将某个文件恢复成上一个版本</h3><p>前面讲述了 <code>reset</code> 基本形式的行为，不过你还可以给它提供一个<strong>作用路径</strong>。 若指定了一个路径，<code>reset</code> 将<strong>不会移动</strong><code>HEAD</code>指针，并且将它的作<strong>用范围限定为指定的文件或文件集合</strong>。</p><p>假设我们有如下的仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --all --oneline --graph</span><br><span class="line">* 5789903 (HEAD -&gt; master) v3</span><br><span class="line">* 448db38 v2</span><br><span class="line">* d4d805e v1 <span class="comment"># 初始提交</span></span><br><span class="line"></span><br><span class="line">$ ll</span><br><span class="line">total 1</span><br><span class="line">-rw-r--r-- 1 86182 197609 9  4月  3 13:59 file.txt</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cat</span> file.txt</span><br><span class="line">v1</span><br><span class="line">v2</span><br><span class="line">v3</span><br></pre></td></tr></table></figure><p>我们分别在三次提交中往<code>file.txt</code>中依次插入了3行。</p><p>现在，假如我们运行 <code>git reset HEAD~ file.txt</code> ，所以它本质上只是将 <code>file.txt</code> 从 <code>HEAD</code>~ 复制到<strong>索引</strong>中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git reset HEAD~ file.txt</span><br><span class="line">Unstaged changes after reset:</span><br><span class="line">M       file.txt</span><br></pre></td></tr></table></figure><blockquote><p>上面提到，<code>git reset</code>的默认模式是<code>--mixed</code>,因此此处的命令相当于：<code>git reset --mixed HEAD file.txt</code> ，但是在新版本的git中已经弃用该选项</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --mixed HEAD~ file.txt</span><br><span class="line">warning: --mixed with paths is deprecated; use <span class="string">&#x27;git reset -- &lt;paths&gt;&#x27;</span> instead.</span><br><span class="line">Unstaged changes after reset:</span><br><span class="line">M       file.txt</span><br></pre></td></tr></table></figure></blockquote><p>此时查看三棵树中的文件状态：</p><p><code>HEAD</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -p HEAD</span><br><span class="line">tree 8cd6823441b40b1947ed4e1fa1fde8fb0a2b3f8c</span><br><span class="line">parent 448db38045cbfdcd17f66f97cdd27398c1851a36</span><br><span class="line">author slimterry &lt;slimterry@qq.com&gt; 1712108715 +0800</span><br><span class="line">committer slimterry &lt;slimterry@qq.com&gt; 1712108715 +0800</span><br><span class="line"></span><br><span class="line">v3</span><br><span class="line"></span><br><span class="line">$ git ls-tree 8cd6823441b40b1947ed4e1fa1fde8fb0a2b3f8c</span><br><span class="line">100644 blob 4b1d4d4b660c400875dd122de217e942f481a378    file.txt</span><br><span class="line"></span><br><span class="line">$ git show 4b1d4d4b660c400875dd122de217e942f481a378</span><br><span class="line">v1</span><br><span class="line">v2</span><br><span class="line">v3</span><br></pre></td></tr></table></figure><p><code>Index</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git ls-files -s</span><br><span class="line">100644 2139d8be699ff388ab3ec85008a3906675ac67cb 0       file.txt</span><br><span class="line"></span><br><span class="line">$ git show 2139d8be699ff388ab3ec85008a3906675ac67cb</span><br><span class="line">v1</span><br><span class="line">v2</span><br></pre></td></tr></table></figure><p>工作区：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> file.txt</span><br><span class="line">v1</span><br><span class="line">v2</span><br><span class="line">v3</span><br></pre></td></tr></table></figure><p>此时的<code>git status</code>命令输出如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git restore --staged &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line">        modified:   file.txt</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git restore &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">        modified:   file.txt</span><br></pre></td></tr></table></figure><blockquote><ul class="lvl-1"><li class="lvl-2"><p><code>file.txtfile.txt</code>出现在<code>Changes to be committed:</code>下方是因为<code>Index</code>与HEAD的内容不一致，别忘了<code>git reset HEAD~ file.txt</code>的本质是将上一版本的拷贝到<code>Index</code>中</p></li><li class="lvl-2"><p><code>file.txt</code>出现在<code>Changes not staged for commit:</code>下方是因为<strong>工作区</strong>和<code>Index</code>的内容不一致</p></li></ul></blockquote><p>可以看到指定了文件后，git reset命令确实不会移动<code>HEAD</code>指针，此时可以通过如下命令舍弃<code>v3</code>版本的改动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git restore file.txt</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git restore --staged &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line">        modified:   file.txt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cat</span> file.txt</span><br><span class="line">v1</span><br><span class="line">v2</span><br></pre></td></tr></table></figure><h3 id="将文件恢复成指定版本">将文件恢复成指定版本</h3><p>我们的仓库历史提交如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --all --oneline --graph</span><br><span class="line">* 5789903 (HEAD -&gt; master) v3</span><br><span class="line">* 448db38 v2</span><br><span class="line">* d4d805e v1</span><br></pre></td></tr></table></figure><p>此时执行命令<code> git reset d4d805e file.txt</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git reset d4d805e file.txt</span><br><span class="line">Unstaged changes after reset:</span><br><span class="line">M       file.txt</span><br></pre></td></tr></table></figure><p>此时查看文件内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> file.txt</span><br><span class="line">v1</span><br><span class="line">v2</span><br><span class="line">v3</span><br></pre></td></tr></table></figure><p>查看<code>Index</code>中的内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git ls-files -s</span><br><span class="line">100644 626799f0f85326a8c1fc522db584e86cdfccd51f 0       file.txt</span><br><span class="line"></span><br><span class="line">$ git show 626799f0f85326a8c1fc522db584e86cdfccd51f</span><br><span class="line">v1</span><br></pre></td></tr></table></figure><blockquote><p><code>Index</code>中<code>file.txt</code>的内容已经被置为与版本<code>d4d805e</code>一样的内容。</p></blockquote><p>此时查看<code>HEAD</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -p HEAD</span><br><span class="line">tree 8cd6823441b40b1947ed4e1fa1fde8fb0a2b3f8c</span><br><span class="line">parent 448db38045cbfdcd17f66f97cdd27398c1851a36</span><br><span class="line">author slimterry &lt;slimterry@qq.com&gt; 1712108715 +0800</span><br><span class="line">committer slimterry &lt;slimterry@qq.com&gt; 1712108715 +0800</span><br><span class="line"></span><br><span class="line">v3</span><br><span class="line"></span><br><span class="line">$ git ls-tree 8cd6823441b40b1947ed4e1fa1fde8fb0a2b3f8c</span><br><span class="line">100644 blob 4b1d4d4b660c400875dd122de217e942f481a378    file.txt</span><br><span class="line"></span><br><span class="line">$ git show 4b1d4d4b660c400875dd122de217e942f481a378</span><br><span class="line">v1</span><br><span class="line">v2</span><br><span class="line">v3</span><br></pre></td></tr></table></figure><p>此时查看<code>git status</code>输出如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git restore --staged &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line">        modified:   file.txt</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git restore &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">        modified:   file.txt</span><br></pre></td></tr></table></figure><blockquote><ul class="lvl-1"><li class="lvl-2"><p><code>file.txt</code>出现在<code>Changes to be committed:</code>下方是因为<code>Index</code>与HEAD的内容不一致，别忘了<code>git reset d4d805e file.txt</code>的本质是将版本<code>d4d805e</code>中的<code>file.txt</code>拷贝到<code>Index</code>中</p></li><li class="lvl-2"><p><code>file.txt</code>出现在<code>Changes not staged for commit:</code>下方是因为<strong>工作区</strong>和<code>Index</code>的内容不一致</p></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git工具(4)--子模块</title>
      <link href="/2024/04/01/git%E5%B7%A5%E5%85%B7-4-%E5%AD%90%E6%A8%A1%E5%9D%97/"/>
      <url>/2024/04/01/git%E5%B7%A5%E5%85%B7-4-%E5%AD%90%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git工具(3)--高级合并</title>
      <link href="/2024/04/01/git%E5%B7%A5%E5%85%B7-3-%E9%AB%98%E7%BA%A7%E5%90%88%E5%B9%B6/"/>
      <url>/2024/04/01/git%E5%B7%A5%E5%85%B7-3-%E9%AB%98%E7%BA%A7%E5%90%88%E5%B9%B6/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git工具(2)--重写历史</title>
      <link href="/2024/04/01/git%E5%B7%A5%E5%85%B7-2-%E9%87%8D%E5%86%99%E5%8E%86%E5%8F%B2/"/>
      <url>/2024/04/01/git%E5%B7%A5%E5%85%B7-2-%E9%87%8D%E5%86%99%E5%8E%86%E5%8F%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="修改最后一次提交">修改最后一次提交</h2><h3 id="仅修改提交信息">仅修改提交信息</h3><p>假设修改前的git日志如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --oneline</span><br><span class="line">5e5996c (HEAD -&gt; master) 修改b.java 6</span><br><span class="line">cce2144 修改b.java 5</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>如果我们只是希望修改最后一次提交的提交信息，我们可以通过如下的方式进行修改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git commit --amend -m <span class="string">&#x27;修改B.java文件：删除无用的import语句&#x27;</span></span><br><span class="line">[master 055cda3] 修改B.java文件：删除无用的import语句</span><br><span class="line"> Date: Mon Apr 1 10:39:09 2024 +0800</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><p>此时再次查看git日志：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --oneline</span><br><span class="line">055cda3 (HEAD -&gt; master) 修改B.java文件：删除无用的import语句</span><br><span class="line">cce2144 修改b.java 5</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>可以发现，之前旧的提交对象<code>5e5996c</code>被新的提交对象<code>055cda3</code>覆盖，并没有增加新的提交对象。</p><h3 id="修改提交的文件快照">修改提交的文件快照</h3><p>如果你已经完成提交，又因为之前提交时忘记添加一个新创建的文件，想通过添加或修改文件来更改提交的快照，也可以通过类似的操作来完成。 通过修改文件然后运行 <code>git add</code> 或 <code>git rm</code> 一个已追踪的文件，随后运行 <code>git commit --amend</code> 拿走当前的暂存区域并使其做为新提交的快照。</p><p>使用这个技巧的时候需要小心，因为修正会改变提交的 <strong>SHA-1</strong> 校验和。 它<strong>类似于一个小的变基</strong> - <strong>如果已经推送了最后一次提交就不要修正它</strong>。</p><p>比如修改前的git日志如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --oneline</span><br><span class="line">055cda3 (HEAD -&gt; master) 修改B.java文件：删除无用的import语句</span><br><span class="line">cce2144 修改b.java 5</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><p>此时如果我们希望追加一个新的文件<code>D.java</code>,并删除<code>B.java</code>中的某一行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git status -s</span><br><span class="line"> M B.java <span class="comment"># 修改</span></span><br><span class="line">?? D.java <span class="comment"># 新增</span></span><br></pre></td></tr></table></figure><p>但是我们希望将这些改动也加入最后一次改动中，可以通过如下的方式实现：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git add *</span><br><span class="line"></span><br><span class="line">$ git status -s</span><br><span class="line">M  B.java</span><br><span class="line">A  D.java</span><br><span class="line"></span><br><span class="line">$ git commit --amend <span class="comment"># 弹出的文本编辑器中可以根据需要选择是否要修改提交信息</span></span><br><span class="line">[master 38063bd] 修改B.java文件：删除无用的import语句</span><br><span class="line"> Date: Mon Apr 1 10:39:09 2024 +0800</span><br><span class="line"> 2 files changed, 2 insertions(+)</span><br><span class="line"> create mode 100644 D.java</span><br></pre></td></tr></table></figure><p>此时再次查看git日志：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --oneline</span><br><span class="line">38063bd (HEAD -&gt; master) 修改B.java文件：删除无用的import语句</span><br><span class="line">cce2144 修改b.java 5</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="修改多个提交信息">修改多个提交信息</h2><p>为了修改在提交历史中较远的提交，必须使用更复杂的工具。 Git <strong>没有一个改变历史工具</strong>，但是可以使用<strong>变基工具</strong>来变基一系列提交，基于它们原来的 <code>HEAD</code> 而不是将其移动到另一个新的上面。</p><p>通过<strong>交互式变基工具</strong>，可以在任何想要修改的提交后停止，然后修改信息、添加文件或做任何想做的事情。 可以通过给 <code>git rebase</code> 增加 <code>-i</code> 选项来交互式地运行变基。 必须指定想要重写多久远的历史，这可以通过告诉命令将要变基到的提交来做到。</p><p>详情阅读:<a href="https://www.progit.cn/#_rewriting_history">修改多个提交信息</a></p><h2 id="重新排序提交">重新排序提交</h2><p>详情阅读:<a href="https://www.progit.cn/#_rewriting_history">修改多个提交信息</a></p><h2 id="压缩提交">压缩提交</h2><p>详情阅读:<a href="https://www.progit.cn/#_rewriting_history">修改多个提交信息</a></p><h2 id="拆分提交">拆分提交</h2><p>详情阅读:<a href="https://www.progit.cn/#_rewriting_history">修改多个提交信息</a></p><h2 id="彻底移除文件">彻底移除文件</h2><h3 id="简单情况：仅涉及最近一次提交">简单情况：仅涉及最近一次提交</h3><p>参考：<a href="https://stackoverflow.com/questions/872565/remove-sensitive-files-and-their-commits-from-git-history">remove-sensitive-files-and-their-commits-from-git-history</a></p><p>如果改动需要移除的文件仅在本地的最后一次提交中存在，而且没有被Push到远端仓库，可以直接使用给<code>git commit --amend</code>进行修复，比如错误的提交了</p><p><code>secret.txt</code>文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --all --oneline --graph</span><br><span class="line">* f1a16dc (HEAD -&gt; master) 提交 secret.txt</span><br><span class="line">* d945ca3 app.properties中新增<span class="built_in">env</span>变量</span><br><span class="line"></span><br><span class="line">$ ll</span><br><span class="line">total 7</span><br><span class="line">...</span><br><span class="line">-rw-r--r-- 1 86182 197609   0  4月  2 10:32 secret.txt</span><br></pre></td></tr></table></figure><p>我们可以通过如下的方式覆盖本地提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">rm</span> secret.txt</span><br><span class="line"><span class="built_in">rm</span> <span class="string">&#x27;secret.txt&#x27;</span></span><br><span class="line"></span><br><span class="line">$ git commit --amend -m <span class="string">&#x27;删除误提交的文件&#x27;</span></span><br><span class="line">You asked to amend the most recent commit, but doing so would make</span><br><span class="line">it empty. You can repeat your <span class="built_in">command</span> with --allow-empty, or you can</span><br><span class="line">remove the commit entirely with <span class="string">&quot;git reset HEAD^&quot;</span>.</span><br><span class="line">On branch master</span><br><span class="line">No changes</span><br></pre></td></tr></table></figure><blockquote><p>因为原先该次提交只提交了文件<code>secret.txt</code>，而此次<code>amend</code>删除了该文件，会导致原先的那次<code>commit</code>内容为空，因此需要加上<code>--allow-empty</code>参数，也可以根据提示直接删除这次提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ git commit --amend --allow-empty -m <span class="string">&#x27;删除误提交的文件&#x27;</span></span><br><span class="line">[master 84d04fe] 删除误提交的文件</span><br><span class="line"> Date: Tue Apr 2 10:32:28 2024 +0800</span><br><span class="line"></span><br><span class="line">$ ll <span class="comment"># 结果中已经没有secret.txt文件</span></span><br><span class="line">total 7</span><br><span class="line">-rw-r--r-- 1 86182 197609 649  4月  1 10:38 A.java</span><br><span class="line">...</span><br><span class="line">-rw-r--r-- 1 86182 197609   0  4月  1 13:43 D.java</span><br><span class="line"></span><br><span class="line">$ git <span class="built_in">log</span> --all --oneline --graph</span><br><span class="line">* 84d04fe (HEAD -&gt; master) 删除误提交的文件</span><br><span class="line">* d945ca3 app.properties中新增<span class="built_in">env</span>变量</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">$ git show 84d04fe</span><br><span class="line">commit 84d04fe11239c940a1828dcdb446bc2151be7a88 (HEAD -&gt; master)</span><br><span class="line">Author: slimterry &lt;slimterry@qq.com&gt;</span><br><span class="line">Date:   Tue Apr 2 10:32:28 2024 +0800</span><br><span class="line"></span><br><span class="line">    删除误提交的文件</span><br></pre></td></tr></table></figure><p>此次提交变为一次空提交。</p></blockquote><p>如下的情况则不需要添加<code>--allow-empty</code>参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">touch</span> secret.txt bar.txt</span><br><span class="line">$ git add *</span><br><span class="line">$ git commit -m <span class="string">&#x27;添加2个文件&#x27;</span></span><br><span class="line"></span><br><span class="line">$ git <span class="built_in">rm</span> secret.txt</span><br><span class="line"><span class="built_in">rm</span> <span class="string">&#x27;secret.txt&#x27;</span></span><br><span class="line"></span><br><span class="line">$ git commit --amend  -m<span class="string">&#x27;剔除误提交的文件&#x27;</span></span><br><span class="line">[master ce592c7] 剔除误提交的文件</span><br><span class="line"> Date: Tue Apr 2 10:41:47 2024 +0800</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 bar.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="复杂情况：涉及历史提交">复杂情况：涉及历史提交</h3><p>参考：<a href="https://stackoverflow.com/questions/872565/remove-sensitive-files-and-their-commits-from-git-history">remove-sensitive-files-and-their-commits-from-git-history</a></p><h4 id="不推荐使用filter-branch">不推荐使用filter-branch</h4><p>有另一个历史改写的选项，如果想要通过脚本的方式改写大量提交的话可以使用它 - 例如，<strong>全局修改你的邮箱地址</strong>或<strong>从每一个提交中移除一个文件</strong>。 这个命令是 <code>filter-branch</code>，它可以<strong>改写历史中大量的提交</strong>。</p><p>除非你的项目还<strong>没有公开</strong>并且<strong>其他人没有基于要改写的工作的提交做的工作</strong>，你<strong>不应当使用它</strong>。 然而，它可以很有用。 你将会学习到几个常用的用途，这样就得到了它适合使用地方的想法。</p><p>注意：<strong>git-filter-branch(1) Manual Page</strong>中都不推荐使用<code>filter-branch</code>，推荐使用的是 <a href="https://github.com/newren/git-filter-repo/">git filter-repo</a>：</p><blockquote><p><em>git filter-branch</em> has a plethora of pitfalls that can produce non-obvious manglings of the intended history rewrite (and can leave you with little time to investigate such problems since it has such abysmal performance). These safety and performance issues <strong>cannot be backward</strong> compatibly fixed and as such, its use is <strong>not recommended</strong>. <strong>Please use an alternative history filtering tool such as</strong> <a href="https://github.com/newren/git-filter-repo/">git filter-repo</a>.</p></blockquote><h4 id="安装git-filter-repo">安装git filter-repo</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ pip install git-filter-repo</span><br><span class="line">Looking <span class="keyword">in</span> indexes: https://mirrors.aliyun.com/pypi/simple</span><br><span class="line">Collecting git-filter-repo</span><br><span class="line">  Downloading https://mirrors.aliyun.com/pypi/packages/8d/0b/49d4d620327b717fdc072b2efdfcb3588eb3cf780e60ed5ba98ebedb5637/git_filter_repo-2.38.0-py2.py3-none-any.whl (99 kB)</span><br><span class="line">     ---------------------------------------- 99.1/99.1 kB 1.4 MB/s eta 0:00:00</span><br><span class="line">Installing collected packages: git-filter-repo</span><br><span class="line">Successfully installed git-filter-repo-2.38.0</span><br></pre></td></tr></table></figure><h4 id="从每一个提交移除敏感文件、大文件">从每一个提交移除敏感文件、大文件</h4><p>命令格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git filter-repo --path path/to/remove1 --path path/to/remove2 --invert-paths</span><br></pre></td></tr></table></figure><p>这经常发生。 有人粗心地提交了一个<strong>巨大的二进制文件</strong><code>largefile.iso</code>，你希望从git仓库中<strong>彻底删除该文件</strong>：</p><p>①：误提交了大文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ ll -h  largefile.iso</span><br><span class="line">-rw-r--r-- 1 86182 197609 1000M  4月  1 14:33 largefile.iso</span><br><span class="line"></span><br><span class="line">$ git status -s</span><br><span class="line">A  largefile.iso <span class="comment"># 误提交</span></span><br><span class="line"></span><br><span class="line">$ git commit -m <span class="string">&#x27;提交iso文件&#x27;</span></span><br><span class="line">[master 98cca66] 提交iso文件</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 largefile.iso</span><br></pre></td></tr></table></figure><p>此时你可能想通过<code>git rm</code>删除该文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> git <span class="built_in">rm</span> largefile.iso</span><br><span class="line"><span class="built_in">rm</span> <span class="string">&#x27;largefile.iso&#x27;</span></span><br><span class="line"></span><br><span class="line">$ git commit -m <span class="string">&#x27;删除错误提交的iso文件&#x27;</span></span><br><span class="line">[master a45b192] 删除错误提交的iso文件</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> delete mode 100644 largefile.iso</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">$ git <span class="built_in">log</span> --oneline</span><br><span class="line">a45b192 (HEAD -&gt; master) 删除错误提交的iso文件</span><br><span class="line">98cca66 提交iso文件</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>此时工作区中，确实已经没有该文件，但是git仓库中仍然存在该文件，我们只需要检出到提交该大文件的版本，就可以找到该文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout 98cca66</span><br><span class="line">Note: switching to <span class="string">&#x27;98cca66&#x27;</span>.</span><br><span class="line"></span><br><span class="line">$ ll -h</span><br><span class="line">total 1001M</span><br><span class="line">-rw-r--r-- 1 86182 197609   649  4月  1 10:38 A.java</span><br><span class="line">...</span><br><span class="line">-rw-r--r-- 1 86182 197609 1000M  4月  1 14:41 largefile.iso</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><ul class="lvl-1"><li class="lvl-2">无法通过将<code>largefile.iso</code>加入<code>.gitignore</code>的方法实现从历史提交中彻底删除文件的效果，<code>.gitignore</code>仅针对未提交的文件。</li></ul></blockquote><p>如果我们想彻底从git仓库中删除该文件，可以通过如下的命令实现：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git filter-repo --force --path largefile.iso --invert-paths</span><br><span class="line">Parsed 21 commitsHEAD is now at 2592cd4 删除错误提交的iso文件</span><br><span class="line">Enumerating objects: 49, <span class="keyword">done</span>.</span><br><span class="line">Counting objects: 100% (49/49), <span class="keyword">done</span>.</span><br><span class="line">Delta compression using up to 16 threads</span><br><span class="line">Compressing objects: 100% (44/44), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (49/49), <span class="keyword">done</span>.</span><br><span class="line">Total 49 (delta 20), reused 0 (delta 0), pack-reused 0</span><br><span class="line"></span><br><span class="line">New <span class="built_in">history</span> written <span class="keyword">in</span> 0.21 seconds; now repacking/cleaning...</span><br><span class="line">Repacking your repo and cleaning out old unneeded objects</span><br><span class="line">Completely finished after 0.82 seconds.</span><br></pre></td></tr></table></figure><p>此时我们再次切换到当初提交大文件的版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MINGW64 /d/coding/git-playground (master)</span><br><span class="line">$ git <span class="built_in">log</span> --all --oneline --graph</span><br><span class="line">* 2592cd4 (HEAD -&gt; master) 删除错误提交的iso文件</span><br><span class="line">* d6aea11 提交iso文件</span><br><span class="line">...</span><br></pre></td></tr></table></figure><blockquote><p>注意：由于重写了提交历史，因此git log中的<strong>commit id</strong>会发生<strong>改变</strong></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout d6aea11</span><br><span class="line">Note: switching to <span class="string">&#x27;d6aea11&#x27;</span>.</span><br><span class="line"></span><br><span class="line">MINGW64 /d/coding/git-playground ((d6aea11...))</span><br><span class="line">$ ll</span><br><span class="line">total 6</span><br><span class="line">-rw-r--r-- 1 86182 197609 649  4月  1 10:38 A.java</span><br><span class="line">-rw-r--r-- 1 86182 197609 205  4月  1 13:43 B.java</span><br><span class="line">-rw-r--r-- 1 86182 197609   5  3月 29 15:57 C.java</span><br><span class="line">-rw-r--r-- 1 86182 197609   0  4月  1 13:43 D.java</span><br></pre></td></tr></table></figure><p>此时在历史版本<code>d6aea11</code>中的大文件<code>largefile.iso</code>已经被彻底删除。</p><p>如果你的仓库已经推送到远程目录，还需要执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push -f</span><br></pre></td></tr></table></figure><h3 id="替换git历史提交中某个字符串">替换git历史提交中某个字符串</h3><p>参考<a href="https://stackoverflow.com/questions/46950829/how-to-replace-a-string-in-whole-git-history/64153992#64153992">how-to-replace-a-string-in-whole-git-history</a></p><p>假设我们在某次提交中新增了一个<code>app.properties</code>文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> app.properties</span><br><span class="line">passwd=12345</span><br><span class="line"></span><br><span class="line">86182@yawen MINGW64 /d/coding/git-playground (master)</span><br><span class="line">$ git add app.properties</span><br><span class="line"></span><br><span class="line">86182@yawen MINGW64 /d/coding/git-playground (master)</span><br><span class="line">$ git commit -m <span class="string">&#x27;提交app.properties文件&#x27;</span></span><br><span class="line">[master 1ebee67] 提交app.properties文件</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 app.properties</span><br></pre></td></tr></table></figure><p>然后再后续的提交中又陆续修该了该文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m <span class="string">&#x27;app.properties中新增env变量&#x27;</span></span><br><span class="line">[master a067387] app.properties中新增<span class="built_in">env</span>变量</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> </span><br><span class="line">$ git <span class="built_in">log</span> --all --oneline --graph</span><br><span class="line">* a067387 (HEAD -&gt; master) app.properties中新增<span class="built_in">env</span>变量</span><br><span class="line">* 1ebee67 提交app.properties文件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MINGW64 /d/coding/git-playground (master)</span><br><span class="line">$ <span class="built_in">cat</span> app.properties</span><br><span class="line">passwd=12345 <span class="comment"># 旧密码</span></span><br><span class="line">env_name=dev</span><br></pre></td></tr></table></figure><p>如果我们将各个提交历史中的<code>app.properties</code>中的<code>12345</code>替换成<code>abc123</code>,可以通过如下的命令实现：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;literal:12345==&gt;abc123&#x27;</span> &gt; expressions.txt <span class="comment"># 将替换规则写入到一个文件中,替换完成后可以删除</span></span><br><span class="line"></span><br><span class="line">$ git-filter-repo --replace-text expressions.txt <span class="comment"># 执行替换命令</span></span><br><span class="line">Parsed 21 commitsHEAD is now at d945ca3 app.properties中新增<span class="built_in">env</span>变量</span><br><span class="line">Enumerating objects: 55, <span class="keyword">done</span>.</span><br><span class="line">Counting objects: 100% (55/55), <span class="keyword">done</span>.</span><br><span class="line">Delta compression using up to 16 threads</span><br><span class="line">Compressing objects: 100% (28/28), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (55/55), <span class="keyword">done</span>.</span><br><span class="line">Total 55 (delta 24), reused 46 (delta 20), pack-reused 0</span><br><span class="line"></span><br><span class="line">New <span class="built_in">history</span> written <span class="keyword">in</span> 0.21 seconds; now repacking/cleaning...</span><br><span class="line">Repacking your repo and cleaning out old unneeded objects</span><br><span class="line">Completely finished after 0.77 seconds.</span><br><span class="line"></span><br><span class="line">MINGW64 /d/coding/git-playground (master)</span><br><span class="line">$ git <span class="built_in">log</span> --all --oneline --graph </span><br><span class="line">* d945ca3 (HEAD -&gt; master) app.properties中新增<span class="built_in">env</span>变量 <span class="comment"># 由于重写了提交，因此commit id发生了改变</span></span><br><span class="line">* 0ca4f99 提交app.properties文件</span><br><span class="line">...</span><br></pre></td></tr></table></figure><blockquote><p>–replace-text &lt;expressions_file&gt;::<br>A file with expressions that, if found, will be replaced. By<br>default, each expression is treated as literal text, but<br><code>regex:</code> and <code>glob:</code> prefixes are supported. You can end the<br>line with <code>==&gt;</code> and some replacement text to choose a<br>replacement choice other than the default of <code>***REMOVED***</code>.</p></blockquote><p>此时我们分别查看工作区和历史版本中的密码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> app.properties</span><br><span class="line">passwd=abc123</span><br><span class="line">env_name=dev</span><br><span class="line"></span><br><span class="line">MINGW64 /d/coding/git-playground (master)</span><br><span class="line">$ git show 0ca4f99</span><br><span class="line">commit 0ca4f99f453b9211a19c08de968e05579775cbc3</span><br><span class="line">Author: slimterry &lt;slimterry@qq.com&gt;</span><br><span class="line">Date:   Tue Apr 2 10:02:20 2024 +0800</span><br><span class="line"></span><br><span class="line">    提交app.properties文件</span><br><span class="line"></span><br><span class="line">diff --git a/app.properties b/app.properties</span><br><span class="line">new file mode 100644</span><br><span class="line">index 0000000..ed9939e</span><br><span class="line">--- /dev/null</span><br><span class="line">+++ b/app.properties</span><br><span class="line">@@ -0,0 +1 @@</span><br><span class="line">+passwd=abc123 <span class="comment">#此处也被重写为新的密码</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><ul class="lvl-1"><li class="lvl-2">该方法会重写所有分支的所有提交，如果需要限制分支和提交范围，请参考： <a href="https://stackoverflow.com/questions/59315574/git-filter-repo-can-it-be-used-on-a-specific-branch">git filter-repo: can it be used on a specific branch?</a>和<a href="https://stackoverflow.com/questions/64154624/how-to-modify-only-a-range-of-commits-with-git-filter-repo-instead-of-the-entire/64155801#64155801">How to modify only a range of commits with git filter-repo instead of the entire branch history?</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git工具(1)</title>
      <link href="/2024/03/29/git%E5%B7%A5%E5%85%B7(1)/"/>
      <url>/2024/03/29/git%E5%B7%A5%E5%85%B7(1)/</url>
      
        <content type="html"><![CDATA[<h2 id="git-show命令">git show命令</h2><p><code>git show</code>使用方法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git show [&lt;options&gt;] [&lt;object&gt;…]</span><br></pre></td></tr></table></figure><p>该命令命令可以查看git中多种类型的对象，比如<strong>blobs</strong>、<strong>trees</strong>、<strong>commits</strong>、<strong>tags</strong></p><ul class="lvl-0"><li class="lvl-2"><p>对于提交<strong>commits</strong>：显示log信息以及文本差异（<strong>textual diff.</strong>）</p></li><li class="lvl-2"><p>对于<strong>tags</strong>:显示<code>tag</code>的信息以及其引用的对象</p></li><li class="lvl-2"><p>对于<strong>tree</strong>:显示名称，相当于<code>git ls-tree with --name-only</code></p></li><li class="lvl-2"><p>对于普通(<strong>plain</strong>)<strong>blobs</strong>:显示其内容</p></li></ul><h2 id="选择修订版本">选择修订版本</h2><h3 id="获取单个修订版本">获取单个修订版本</h3><h4 id="通过commit-id（SHA-1）">通过commit id（SHA-1）</h4><p>只需要提供 SHA-1 的前几个字符就可以获得对应的那次提交，当然你提供的 SHA-1 字符数量不<strong>得少于 4 个</strong>，并且没有歧义——也就是说，当前仓库中只有一个对象以这段 SHA-1 开头。</p><p>例如查看一次指定的提交，假设你执行 <code>git log</code> 命令来查看之前新增一个功能的那次提交:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">MINGW64 /d/coding/git-playground (master)</span><br><span class="line">$  git <span class="built_in">log</span> -3</span><br><span class="line">commit 81d81eb4595b06d26e7fbeab31fce91816bd8aa4 (HEAD -&gt; master, origin/master)</span><br><span class="line">Author: slimterry &lt;slimterry@qq.com&gt;</span><br><span class="line">Date:   Tue Mar 26 10:14:48 2024 +0800</span><br><span class="line"></span><br><span class="line">    其他人在master上的提交2</span><br><span class="line"></span><br><span class="line">commit 144b12af62f83bbb3e85448371d67afbea999ba8</span><br><span class="line">Author: slimterry &lt;slimterry@qq.com&gt;</span><br><span class="line">Date:   Tue Mar 26 10:14:14 2024 +0800</span><br><span class="line"></span><br><span class="line">    其他人在master上的提交</span><br></pre></td></tr></table></figure><p>以下3个<code>git show</code>命令查看的是同一版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git show 81d81eb4595b06d26e7fbeab31fce91816bd8aa4</span><br><span class="line">$ git show 81d81eb4595b06d26e7</span><br><span class="line">$ git show  81d81eb</span><br></pre></td></tr></table></figure><p>通常 <strong>8 到 10 个字符</strong>就已经足够在一个项目中避免 SHA-1 的歧义。</p><h4 id="通过分支引用">通过分支引用</h4><p>指明一次提交最直接的方法是有一个<strong>指向它的分支引用</strong>。 这样你就可以在任意一个 Git 命令中使用这个分支名来<strong>代替对应的提交对象或者 SHA-1 值</strong>。</p><p>假设我们有如下的git log信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --all --oneline --graph</span><br><span class="line">* a1c6f33 (origin/serverfix, serverfix) 新增index.html[serverfix]</span><br><span class="line">* 81d81eb (HEAD -&gt; master, origin/master) 其他人在master上的提交2</span><br></pre></td></tr></table></figure><blockquote><p><code>serverfix</code>指针指向提交对象<code>a1c6f33</code></p></blockquote><p>例如，你想要查看一个分支的最后一次提交的对象，那么以下的命令是等价的:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git show a1c6f33</span><br><span class="line">$ git show serverfix</span><br></pre></td></tr></table></figure><p>如果你想知道<strong>某个分支指向哪个特定的 SHA-1</strong>，或者想看任何一个例子中被简写的 SHA-1 ，你可以使用一个叫做 <code>rev-parse</code> 的 Git 探测工具。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git rev-parse serverfix <span class="comment"># 查看分支指向哪个提交对象</span></span><br><span class="line">a1c6f33925730cb10158c912f1b321fb688bae62</span><br><span class="line"></span><br><span class="line">$ git rev-parse a1c6f33 <span class="comment"># 查看该字符串是哪个提交对象id的简写</span></span><br><span class="line">a1c6f33925730cb10158c912f1b321fb688bae62</span><br></pre></td></tr></table></figure><h4 id="通过引用日志（reflog）">通过引用日志（reflog）</h4><p>当你在工作时， Git 会在后台保存一个引用日志(<code>reflog</code>)，引用日志记录了最近几个月你的 <code>HEAD</code> 和分支引用所指向的历史。你可以使用 <code>git reflog</code> 来查看引用日志：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MINGW64 /d/coding/git-playground (master)</span><br><span class="line">$ git checkout serverfix <span class="comment"># 切换分支</span></span><br><span class="line">Switched to branch <span class="string">&#x27;serverfix&#x27;</span></span><br><span class="line">Your branch is up to <span class="built_in">date</span> with <span class="string">&#x27;origin/serverfix&#x27;</span>.</span><br><span class="line"></span><br><span class="line">MINGW64 /d/coding/git-playground (serverfix)</span><br><span class="line">$ git reflog</span><br><span class="line">a1c6f33 (HEAD -&gt; serverfix, origin/serverfix) HEAD@&#123;0&#125;: checkout: moving from master to serverfix <span class="comment"># 记录从master切换到serverfix</span></span><br><span class="line">81d81eb (origin/master, master) HEAD@&#123;1&#125;: checkout: moving from serverfix to master</span><br><span class="line">a1c6f33 (HEAD -&gt; serverfix, origin/serverfix) HEAD@&#123;2&#125;: commit: 新增index.html[serverfix]</span><br></pre></td></tr></table></figure><p>每当你的 HEAD 所指向的位置发生了变化，Git 就会将这个信息存储到引用日志这个历史记录里。 通过这些数据，你可以很方便地获取之前的提交历史。</p><p>你可以使用 <code>@&#123;n&#125;</code> 来引用 <code>reflog</code> 中输出的提交记录, 如果你想查看仓库中 HEAD 在3次前的所指向的提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git show HEAD@&#123;3&#125;</span><br><span class="line">commit 81d81eb4595b06d26e7fbeab31fce91816bd8aa4 (origin/master, master)</span><br><span class="line">Author: slimterry &lt;slimterry@qq.com&gt;</span><br><span class="line">Date:   Tue Mar 26 10:14:48 2024 +0800</span><br><span class="line"></span><br><span class="line">    其他人在master上的提交2</span><br><span class="line"></span><br><span class="line">diff --git a/B.java b/B.java</span><br><span class="line">index e69de29..ad1ece6 100644</span><br><span class="line">--- a/B.java</span><br><span class="line">+++ b/B.java</span><br><span class="line">@@ -0,0 +1 @@</span><br><span class="line">+// 其他人在master上的提交2</span><br></pre></td></tr></table></figure><p>你同样可以使用这个语法来查看某个分支在一定时间前的位置。 例如，查看你的 <code>master</code> 分支在昨天的时候指向了哪个提交，你可以输入:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git show master@&#123;yesterday&#125;</span><br><span class="line">commit 81d81eb4595b06d26e7fbeab31fce91816bd8aa4 (origin/master, master)</span><br><span class="line">Author: slimterry &lt;slimterry@qq.com&gt;</span><br><span class="line">Date:   Tue Mar 26 10:14:48 2024 +0800</span><br><span class="line"></span><br><span class="line">    其他人在master上的提交2</span><br><span class="line"></span><br><span class="line">diff --git a/B.java b/B.java</span><br><span class="line">index e69de29..ad1ece6 100644</span><br><span class="line">--- a/B.java</span><br><span class="line">+++ b/B.java</span><br><span class="line">@@ -0,0 +1 @@</span><br><span class="line">+// 其他人在master上的提交2</span><br></pre></td></tr></table></figure><p>就会显示昨天该分支的顶端指向了哪个提交。 这个方法<strong>只对还在你引用日志里的数据有用</strong>，所以<strong>不能用来查好几个月之前的提交</strong>。</p><p>可以运行 <code>git log -g</code> 来查看类似于 <code>git log</code> 输出格式的引用日志信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> -g serverfix</span><br><span class="line">commit a1c6f33925730cb10158c912f1b321fb688bae62 (HEAD -&gt; serverfix, origin/serverfix)</span><br><span class="line">Reflog: serverfix@&#123;0&#125; (slimterry &lt;slimterry@qq.com&gt;)</span><br><span class="line">Reflog message: commit: 新增index.html[serverfix]</span><br><span class="line">Author: slimterry &lt;slimterry@qq.com&gt;</span><br><span class="line">Date:   Tue Mar 26 14:26:29 2024 +0800</span><br><span class="line"></span><br><span class="line">    新增index.html[serverfix]</span><br><span class="line"></span><br><span class="line">commit 81d81eb4595b06d26e7fbeab31fce91816bd8aa4 (origin/master, master)</span><br><span class="line">Reflog: serverfix@&#123;1&#125; (slimterry &lt;slimterry@qq.com&gt;)</span><br><span class="line">Reflog message: branch: Created from HEAD</span><br><span class="line">Author: slimterry &lt;slimterry@qq.com&gt;</span><br><span class="line">Date:   Tue Mar 26 10:14:48 2024 +0800</span><br><span class="line"></span><br><span class="line">    其他人在master上的提交2</span><br></pre></td></tr></table></figure><p>值得注意的是，引用日志<strong>只存在于本地仓库</strong>，一个记录你<strong>在你自己的仓库里做过什么的日志</strong>。 其他人拷贝的仓库里的引用日志不会和你的相同；而你新克隆一个仓库的时候，引用日志是空的，因为你在仓库里还没有操作。 <code>git show HEAD@&#123;2.months.ago&#125;</code> 这条命令只有在你克隆了一个项目至少两个月时才会有用——如果你是五分钟前克隆的仓库，那么它将不会有结果返回。</p><h4 id="通过祖先引用">通过祖先引用</h4><p>祖先引用是另一种指明一个提交的方式。 如果你在引用的尾部加上一个 <code>^</code>， Git 会将其解析为该引用的<strong>上一个</strong>提交。 假设你的提交历史是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --oneline --graph</span><br><span class="line">* 81d81eb (HEAD -&gt; master, origin/master) 其他人在master上的提交2</span><br><span class="line">* 144b12a 其他人在master上的提交</span><br><span class="line">* ed9cf4a 提交.gitignore</span><br><span class="line">*   152d12e Merge branch <span class="string">&#x27;hotfix&#x27;</span></span><br><span class="line">|\</span><br><span class="line">| * 068a534 修复XX问题[hotfix]</span><br><span class="line">* | 8507b7f 修改A.java文件[master]</span><br><span class="line">|/</span><br><span class="line">* 519c74f 提交git ignore</span><br><span class="line">* dcd138e first commit</span><br></pre></td></tr></table></figure><p>你可以使用 <code>HEAD^</code> 来查看上一个提交，也就是 “HEAD 的父提交”：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git show HEAD <span class="comment"># 查看HEAD所指版本</span></span><br><span class="line">commit 81d81eb4595b06d26e7fbeab31fce91816bd8aa4 (HEAD -&gt; master, origin/master)</span><br><span class="line"></span><br><span class="line">$ git show HEAD^ <span class="comment"># 查看HEAD所指的上一个版本</span></span><br><span class="line">commit 144b12af62f83bbb3e85448371d67afbea999ba8</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><ul class="lvl-1"><li class="lvl-2"><p>命令<code>git show HEAD^</code>等价于<code>git show HEAD^1</code></p></li><li class="lvl-2"><p><code>git show HEAD^2</code>会直接报错,正确的写法应该是<code>HEAD~2</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git show HEAD^2</span><br><span class="line">fatal: ambiguous argument <span class="string">&#x27;HEAD^2&#x27;</span>: unknown revision or path not <span class="keyword">in</span> the working tree.</span><br><span class="line">Use <span class="string">&#x27;--&#x27;</span> to separate paths from revisions, like this:</span><br><span class="line"><span class="string">&#x27;git &lt;command&gt; [&lt;revision&gt;...] -- [&lt;file&gt;...]&#x27;</span></span><br></pre></td></tr></table></figure></li></ul></blockquote><p>你也可以在 <code>^</code> 后面添加一个数字——例如 <code>152d12e^2</code> 代表 “<code>152d12e</code> 的<strong>第二父</strong>提交” 这个语法只适用于合并(<code>merge</code>)的提交，因为合并提交会有多个父提交。 第一父提交是你合并时所在分支，而第二父提交是你所合并的分支：</p><p>比如本例中，我们有一次合并提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --oneline --graph</span><br><span class="line">...</span><br><span class="line">*   152d12e Merge branch <span class="string">&#x27;hotfix&#x27;</span></span><br><span class="line">|\</span><br><span class="line">| * 068a534 修复XX问题[hotfix]  <span class="comment"># 第二父提交</span></span><br><span class="line">* | 8507b7f 修改A.java文件[master] <span class="comment"># 第一父提交</span></span><br><span class="line">|/</span><br><span class="line">* 519c74f 提交git ignore </span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>查看此处合并提交的2个父提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git show 152d12e^ <span class="comment"># 第一父提交</span></span><br><span class="line">commit 8507b7fea93ba1c6db233f8cf8e9d7b977fff4e1</span><br><span class="line"></span><br><span class="line">$ git show 152d12e^2</span><br><span class="line">commit 068a534984eea6b400ccc574fa0b528bd144ce53 <span class="comment"># 第二父提交</span></span><br></pre></td></tr></table></figure><p>这个语法只适用于合并(<code>merge</code>)的提交，如果不是合并提交，比如对于本例中的提交<code>81d81eb</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --oneline --graph</span><br><span class="line">* 81d81eb (HEAD -&gt; master, origin/master) 其他人在master上的提交2</span><br><span class="line">* 144b12a 其他人在master上的提交</span><br><span class="line">* ed9cf4a 提交.gitignore</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">$ git show 81d81eb^</span><br><span class="line">commit 144b12af62f83bbb3e85448371d67afbea999ba8</span><br><span class="line"></span><br><span class="line">$ git show 81d81eb^2</span><br><span class="line">fatal: ambiguous argument <span class="string">&#x27;81d81eb^2&#x27;</span>: unknown revision or path not <span class="keyword">in</span> the working tree.</span><br><span class="line">Use <span class="string">&#x27;--&#x27;</span> to separate paths from revisions, like this:</span><br><span class="line"><span class="string">&#x27;git &lt;command&gt; [&lt;revision&gt;...] -- [&lt;file&gt;...]&#x27;</span></span><br></pre></td></tr></table></figure><p>尝试查看版本<code>81d81eb^2</code>时，会直接报错！</p><p>另一种指明祖先提交的方法是 <code>~</code>。 同样是指向第一父提交，因此 <code>HEAD~</code> 和 <code>HEAD^</code> 是等价的。 而区别在于你在后面加数字的时候。 <code>HEAD~2</code> 代表 “第一父提交的第一父提交”，也就是 “祖父提交” —— Git 会根据你指定的次数获取对应的第一父提交。 例如，在之前的列出的提交历史中，<code>HEAD~2</code> 就是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git show HEAD~2</span><br><span class="line">commit ed9cf4a352ba55396c603eb9c0431653305dab5e</span><br></pre></td></tr></table></figure><p>你也可以组合使用这两个语法 —— 你可以通过 <code>HEAD~3^2</code> 来取得之前引用的**第二父提交（**假设它是一个合并提交）。</p><h3 id="获取提交区间内的所有版本、">获取提交区间内的所有版本、</h3><p>你已经学会如何单次的提交，现在来看看如何指明一定区间的提交。 当你有很多分支时，这对管理你的分支时十分有用，你可以用提交区间来解决 “这个分支还有哪些提交尚未合并到主分支？” 的问题</p><h3 id="双点">双点</h3><p>最常用的指明提交区间语法是<strong>双点</strong>。 这种语法可以让 Git 选出<strong>在一个分支中而不在另一个分支中的提交</strong>。假设你的提交历史如下：</p><p><img src="image-20240329104500695.png" alt="image-20240329104500695"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MINGW64 /d/coding/git-playground (master)</span><br><span class="line">$ git <span class="built_in">log</span> --oneline --graph --all</span><br><span class="line">* 06a5c98 (experiment) D-experiment</span><br><span class="line">* ee0b728 c-experiment</span><br><span class="line">| * 1c31a26 (HEAD -&gt; master) F-master</span><br><span class="line">| * de64ba7 E-master</span><br><span class="line">|/</span><br><span class="line">* e611884 B-master</span><br><span class="line">* 72b163e A-master</span><br></pre></td></tr></table></figure><p><img src="image-20240329105708676.png" alt="image-20240329105708676"></p><p>你想要查看 <code>experiment</code> 分支中还有哪些提交尚未被合并入 <code>master</code> 分支。 你可以使用 <code>master..experiment</code> 来让 Git 显示这些提交。也就是 “在 <code>experiment</code> 分支中而不在 <code>master</code> 分支中的提交”。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> master..experiment</span><br><span class="line">commit 06a5c98b0ed10fba3c62e466bc91c5c8314107a9 (experiment)</span><br><span class="line">Author: slimterry &lt;slimterry@qq.com&gt;</span><br><span class="line">Date:   Fri Mar 29 10:51:23 2024 +0800</span><br><span class="line"></span><br><span class="line">    D-experiment</span><br><span class="line"></span><br><span class="line">commit ee0b72818537fdfd8528c27a481597cb27528add</span><br><span class="line">Author: slimterry &lt;slimterry@qq.com&gt;</span><br><span class="line">Date:   Fri Mar 29 10:51:10 2024 +0800</span><br><span class="line"></span><br><span class="line">    c-experiment</span><br></pre></td></tr></table></figure><p>反过来，如果你想查看在 <code>master</code> 分支中而不在 <code>experiment</code> 分支中的提交，你只要交换分支名即可。 <code>experiment..master</code> 会显示在 <code>master</code> 分支中而不在 <code>experiment</code> 分支中的提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> experiment..master</span><br><span class="line">commit 1c31a26869fb13b45b7bd2d7c4178333a39d5bad (HEAD -&gt; master)</span><br><span class="line">Author: slimterry &lt;slimterry@qq.com&gt;</span><br><span class="line">Date:   Fri Mar 29 10:48:56 2024 +0800</span><br><span class="line"></span><br><span class="line">    F-master</span><br><span class="line"></span><br><span class="line">commit de64ba762c2b18fad604d3b0a801176c8fedb2a8</span><br><span class="line">Author: slimterry &lt;slimterry@qq.com&gt;</span><br><span class="line">Date:   Fri Mar 29 10:48:28 2024 +0800</span><br><span class="line"></span><br><span class="line">    E-master</span><br></pre></td></tr></table></figure><p>这可以让你保持 <code>experiment</code> 分支<strong>跟随最新的进度</strong>以及查看你即将合并的内容。</p><p>另一个常用的场景是查看你<strong>即将推送到远端</strong>的内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> origin/master..HEAD</span><br></pre></td></tr></table></figure><blockquote><p>即在<code>HEAD</code>(当前分支)上，但是不在 <code>origin/master</code>上的提交。</p></blockquote><p>这个命令会输出<strong>在你当前分支</strong>中而不在远程 <code>origin</code> 中的提交。 如果你执行了 <code>git push</code> 并且你的当前分支正在跟踪 <code>origin/master</code>，<code>git log origin/master..HEAD</code> 所输出的提交将会被传输到远端服务器。 如果你留空了其中的一边， Git 会默认为 HEAD。 例如， <code>git log origin/master..</code> 将会输出与之前例子相同的结果 —— Git 使用 <strong>HEAD</strong> 来<strong>代替留空</strong>的一边。</p><p>比如上述的例子中<code>git log experiment..master</code>等价于<code>git log experiment..</code>，注意前提是此时在master分支（即：<code>HEAD -&gt; master</code>）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">MINGW64 /d/coding/git-playground (master) <span class="comment"># 当前分支为master</span></span><br><span class="line">$ git <span class="built_in">log</span> experiment.. <span class="comment"># 默认添加HEAD,而此时HEAD指向master</span></span><br><span class="line">commit 1c31a26869fb13b45b7bd2d7c4178333a39d5bad (HEAD -&gt; master)</span><br><span class="line">Author: slimterry &lt;slimterry@qq.com&gt;</span><br><span class="line">Date:   Fri Mar 29 10:48:56 2024 +0800</span><br><span class="line"></span><br><span class="line">    F-master</span><br><span class="line"></span><br><span class="line">commit de64ba762c2b18fad604d3b0a801176c8fedb2a8</span><br><span class="line">Author: slimterry &lt;slimterry@qq.com&gt;</span><br><span class="line">Date:   Fri Mar 29 10:48:28 2024 +0800</span><br><span class="line"></span><br><span class="line">    E-master</span><br></pre></td></tr></table></figure><h3 id="多点">多点</h3><p>双点语法<code>..</code>很好用，但有时候你可能需要<strong>两个以上的分支</strong>才能确定你所需要的修订，比如查看哪些提交是被包含在某些分支中的一个，但是<strong>不在你当前的分支上</strong>。 Git 允许你在任意引用前加上 <code>^</code> 字符或者 <code>--not</code> 来指明你不希望提交被包含其中的分支。 因此下列3个命令是等价的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> refA..refB</span><br><span class="line">$ git <span class="built_in">log</span> ^refA refB</span><br><span class="line">$ git <span class="built_in">log</span> refB --not refA</span><br></pre></td></tr></table></figure><p>这个语法很好用，因为你可以在查询中指定超过两个的引用，这是<strong>双点语法无法实现的</strong>。 比如，你想查看所有被 <code>refA</code> 或 <code>refB</code> 包含的但是不被 <code>refC</code> 包含的提交，你可以输入下面中的任意一个命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> refA refB ^refC</span><br><span class="line">$ git <span class="built_in">log</span> refA refB --not refC</span><br></pre></td></tr></table></figure><p>这就构成了一个十分强大的修订查询系统，你可以通过它来查看你的分支里包含了哪些东西。</p><p>比如：我们的仓库分支情况如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MINGW64 /d/coding/git-playground (client)</span><br><span class="line">$ git <span class="built_in">log</span> --oneline --graph --all</span><br><span class="line">* 308a75c (HEAD -&gt; client) G</span><br><span class="line">* 1c31a26 (master) F-master</span><br><span class="line">* de64ba7 E-master</span><br><span class="line">| * 06a5c98 (experiment) D-experiment</span><br><span class="line">| * ee0b728 c-experiment</span><br><span class="line">|/</span><br><span class="line">* e611884 B-master</span><br><span class="line">* 72b163e A-master</span><br></pre></td></tr></table></figure><p><img src="image-20240329133942065.png" alt="image-20240329133942065"></p><p>我们可以查看那些提交被<code>client</code>和<code>master</code>包括，但是不被<code>experiment</code>包括时，可以通过如下命令查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> client master ^experiment</span><br><span class="line">commit 308a75ca60002f29227278b42896dde24c587971 (HEAD -&gt; client)</span><br><span class="line">Author: slimterry &lt;slimterry@qq.com&gt;</span><br><span class="line">Date:   Fri Mar 29 13:36:34 2024 +0800</span><br><span class="line"></span><br><span class="line">    G</span><br><span class="line"></span><br><span class="line">commit 1c31a26869fb13b45b7bd2d7c4178333a39d5bad (master)</span><br><span class="line">Author: slimterry &lt;slimterry@qq.com&gt;</span><br><span class="line">Date:   Fri Mar 29 10:48:56 2024 +0800</span><br><span class="line"></span><br><span class="line">    F-master</span><br><span class="line"></span><br><span class="line">commit de64ba762c2b18fad604d3b0a801176c8fedb2a8</span><br><span class="line">Author: slimterry &lt;slimterry@qq.com&gt;</span><br><span class="line">Date:   Fri Mar 29 10:48:28 2024 +0800</span><br><span class="line"></span><br><span class="line">    E-master</span><br></pre></td></tr></table></figure><h3 id="三点">三点</h3><p>最后一种主要的区间选择语法是三点，这个语法可以选择出被两个引用中的一个包含但又不被两者同时包含的提交。 再看看之前多点例子中的提交历史：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --oneline --graph --all</span><br><span class="line">* 308a75c (HEAD -&gt; client) G</span><br><span class="line">* 1c31a26 (master) F-master</span><br><span class="line">* de64ba7 E-master</span><br><span class="line">| * 06a5c98 (experiment) D-experiment</span><br><span class="line">| * ee0b728 c-experiment</span><br><span class="line">|/</span><br><span class="line">* e611884 B-master</span><br><span class="line">* 72b163e A-master</span><br></pre></td></tr></table></figure><p>如果你想看 <code>master</code> 或者 <code>experiment</code> 中包含的但不是两者共有的提交，你可以执行:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> master...experiment</span><br><span class="line">commit 06a5c98b0ed10fba3c62e466bc91c5c8314107a9 (experiment)</span><br><span class="line">Author: slimterry &lt;slimterry@qq.com&gt;</span><br><span class="line">Date:   Fri Mar 29 10:51:23 2024 +0800</span><br><span class="line"></span><br><span class="line">    D-experiment</span><br><span class="line"></span><br><span class="line">commit ee0b72818537fdfd8528c27a481597cb27528add</span><br><span class="line">Author: slimterry &lt;slimterry@qq.com&gt;</span><br><span class="line">Date:   Fri Mar 29 10:51:10 2024 +0800</span><br><span class="line"></span><br><span class="line">    c-experiment</span><br><span class="line"></span><br><span class="line">commit 1c31a26869fb13b45b7bd2d7c4178333a39d5bad (master)</span><br><span class="line">Author: slimterry &lt;slimterry@qq.com&gt;</span><br><span class="line">Date:   Fri Mar 29 10:48:56 2024 +0800</span><br><span class="line"></span><br><span class="line">    F-master</span><br><span class="line"></span><br><span class="line">commit de64ba762c2b18fad604d3b0a801176c8fedb2a8</span><br><span class="line">Author: slimterry &lt;slimterry@qq.com&gt;</span><br><span class="line">Date:   Fri Mar 29 10:48:28 2024 +0800</span><br><span class="line"></span><br><span class="line">    E-master</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><ul class="lvl-1"><li class="lvl-2">这里的 <code>master</code> 或者 <code>experiment</code> 中包含指的<strong>不是同时包含</strong>于这2个分支的</li><li class="lvl-2">三点命令的2个参数<strong>可以交换顺序</strong>,不影响结果的展示。</li></ul></blockquote><p>这和通常 <code>log</code> 按日期排序的输出一样，仅仅给出了4个提交的信息。</p><p>这种情形下，<code>log</code> 命令的一个常用参数是 <code>--left-right</code>，它会显示每个提交到底处于哪一侧的分支。 这会让输出数据更加清晰。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> experiment...master --left-right</span><br><span class="line">commit &lt; 06a5c98b0ed10fba3c62e466bc91c5c8314107a9 (experiment) <span class="comment"># 属于左侧</span></span><br><span class="line">Author: slimterry &lt;slimterry@qq.com&gt;</span><br><span class="line">Date:   Fri Mar 29 10:51:23 2024 +0800</span><br><span class="line"></span><br><span class="line">    D-experiment</span><br><span class="line"></span><br><span class="line">commit &lt; ee0b72818537fdfd8528c27a481597cb27528add   <span class="comment"># 属于左侧</span></span><br><span class="line">Author: slimterry &lt;slimterry@qq.com&gt;</span><br><span class="line">Date:   Fri Mar 29 10:51:10 2024 +0800</span><br><span class="line"></span><br><span class="line">    c-experiment</span><br><span class="line"></span><br><span class="line">commit &gt; 1c31a26869fb13b45b7bd2d7c4178333a39d5bad (master)  <span class="comment"># 属于右侧</span></span><br><span class="line">Author: slimterry &lt;slimterry@qq.com&gt;</span><br><span class="line">Date:   Fri Mar 29 10:48:56 2024 +0800</span><br><span class="line"></span><br><span class="line">    F-master</span><br><span class="line"></span><br><span class="line">commit &gt; de64ba762c2b18fad604d3b0a801176c8fedb2a8  <span class="comment"># 属于右侧</span></span><br><span class="line">Author: slimterry &lt;slimterry@qq.com&gt;</span><br><span class="line">Date:   Fri Mar 29 10:48:28 2024 +0800</span><br><span class="line"></span><br><span class="line">    E-master</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><ul class="lvl-1"><li class="lvl-2">此处的左侧右侧指的是三点命令中，分支处于<code>...</code>的左侧还是右侧。</li></ul></blockquote><h2 id="储藏与清理">储藏与清理</h2><p>有时，当你在项目的一部分上已经工作一段时间后，所有东西都进入了<strong>混乱的状态</strong>，而这时你想要切换到另一个分支做一点别的事情。 问题是，你<strong>不想仅仅因为过会儿回到这一点而为做了一半的工作创建一次提交</strong>。 针对这个问题的答案是 <code>git stash</code> 命令。</p><p>储藏会处理工作目录的<strong>脏的状态</strong> - 即，修改的跟踪文件与暂存改动 - 然后将未完成的修改保存到一个栈上，而你可以在任何时候重新应用这些改动。</p><blockquote><p>注意：</p><ul class="lvl-1"><li class="lvl-2">针对已追踪文件的修改才会被stash,无论是否已经</li></ul></blockquote><h3 id="储藏工作">储藏工作</h3><p>为了演示，进入项目并改动几个文件，然后可能暂存其中的一个改动。 如果运行 <code>git status</code>，可以看到有改动的状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MINGW64 /d/coding/git-playground (master)</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git restore --staged &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line">        modified:   C.java</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>现在想要切换分支到分支<code>hotfix</code>，但是还不想要提交之前的工作；所以储藏修改。 将新的储藏推送到栈上，运行 <code>git stash</code> 或 <code>git stash save</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MINGW64 /d/coding/git-playground (master)</span><br><span class="line">$ git stash</span><br><span class="line">Saved working directory and index state WIP on master: 67e2ce0 c</span><br></pre></td></tr></table></figure><p>储藏之后，工作目录是干净的了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MINGW64 /d/coding/git-playground (master)</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><p>在这时，你能够轻易地切换分支并在其他地方工作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MINGW64 /d/coding/git-playground (master)</span><br><span class="line">$ git checkout hotfix</span><br><span class="line">Switched to branch <span class="string">&#x27;hotfix&#x27;</span></span><br></pre></td></tr></table></figure><p>你的修改被存储在栈上。 要查看储藏的东西，可以使用 <code>git stash list</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MINGW64 /d/coding/git-playground (hotfix)</span><br><span class="line">$ git stash list</span><br><span class="line">stash@&#123;0&#125;: WIP on hotfix: b5e0e78 提交D.java</span><br><span class="line">stash@&#123;1&#125;: WIP on master: 67e2ce0 c</span><br></pre></td></tr></table></figure><p>在本例中，有一个之前做的储藏，所以你接触到了2个不同的储藏工作。</p><p>可以通过原来 <code>stash</code> 命令的帮助提示中的命令将你刚刚储藏的工作<strong>重新应用</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> MINGW64 /d/coding/git-playground (hotfix)</span><br><span class="line">$ git stash apply</span><br><span class="line">On branch hotfix</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git restore &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">        modified:   B.java</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">&quot;git add&quot;</span> and/or <span class="string">&quot;git commit -a&quot;</span>)</span><br></pre></td></tr></table></figure><p>注意<code>git stash apply</code>默认会应用最近的一次储藏<code>stash@&#123;0&#125;</code>,如果想要应用其中一个更旧的储藏，可以通过名字指定它,比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MINGW64 /d/coding/git-playground (hotfix)</span><br><span class="line">$ git stash apply stash@&#123;1&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是：执行<code>git stash apply</code>不会清除相应的储藏内容，本例中经过上面2次<code>stash</code>命令后，储藏内容仍然存在：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git stash list</span><br><span class="line">stash@&#123;0&#125;: WIP on hotfix: b5e0e78 提交D.java</span><br><span class="line">stash@&#123;1&#125;: WIP on master: 67e2ce0 c</span><br></pre></td></tr></table></figure><p>可以看到 Git 重新修改了当你保存储藏时撤消的文件。 在本例中，当尝试应用储藏时有一个干净的工作目录，并且尝试将它应用在保存它时所在的分支；</p><p>但是有一个干净的工作目录与应用在同一分支并<strong>不是成功应用储藏的充分必要条件</strong>。 可以在一个分支上保存一个储藏，切换到另一个分支，然后尝试重新应用这些修改。</p><p>当应用储藏时工作目录中也可以有修改与未提交的文件 - 如果有任何东西不能干净地应用，Git 会产生<strong>合并冲突</strong></p><h4 id="应用储藏可能发生冲突">应用储藏可能发生冲突</h4><p>当我们通过<code>git stash apply</code>应用储藏内容时，可能会发生冲突,比如：假设我们已经修改了<code>B.java</code>,我们储藏中的内容也对该文件的内容进行了修改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git stash apply</span><br><span class="line">error: Your <span class="built_in">local</span> changes to the following files would be overwritten by merge:</span><br><span class="line">        B.java</span><br><span class="line">Please commit your changes or stash them before you merge.</span><br><span class="line">Aborting</span><br><span class="line">On branch hotfix</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git restore &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">        modified:   B.java</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">&quot;git add&quot;</span> and/or <span class="string">&quot;git commit -a&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="查看储藏内容">查看储藏内容</h4><p>通过git show可以查看储藏的内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">86182@yawen MINGW64 /d/coding/git-playground (hotfix)</span><br><span class="line">$ git show stash@&#123;0&#125;</span><br><span class="line">commit 35faa92dcb85683c7af1ce488efbd93014fdaf8a (refs/stash)</span><br><span class="line">Merge: b5e0e78 32f769b</span><br><span class="line">Author: slimterry &lt;slimterry@qq.com&gt;</span><br><span class="line">Date:   Fri Mar 29 14:34:22 2024 +0800</span><br><span class="line"></span><br><span class="line">    WIP on hotfix: b5e0e78 提交D.java</span><br><span class="line"></span><br><span class="line">diff --cc B.java</span><br><span class="line">index e69de29,e69de29..27d92bf</span><br><span class="line">--- a/B.java</span><br><span class="line">+++ b/B.java</span><br><span class="line">@@@ -1,0 -1,0 +1,1 @@@</span><br><span class="line">++<span class="comment">###########</span></span><br></pre></td></tr></table></figure><h4 id="删除储藏内容">删除储藏内容</h4><p>通过<code>git stash drop stashname</code>可以删除某个stash</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git stash list</span><br><span class="line">stash@&#123;0&#125;: WIP on hotfix: b5e0e78 提交D.java</span><br><span class="line">stash@&#123;1&#125;: WIP on master: 67e2ce0 c</span><br><span class="line"></span><br><span class="line">86182@yawen MINGW64 /d/coding/git-playground (hotfix)</span><br><span class="line">$ git stash drop stash@&#123;0&#125;</span><br><span class="line">Dropped stash@&#123;0&#125; (35faa92dcb85683c7af1ce488efbd93014fdaf8a)</span><br><span class="line"></span><br><span class="line">86182@yawen MINGW64 /d/coding/git-playground (hotfix)</span><br><span class="line">$ git stash list</span><br><span class="line">stash@&#123;0&#125;: WIP on master: 67e2ce0 c</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>也可以运行 <code>git stash pop</code> 来应用储藏然后立即从栈上扔掉它：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">MINGW64 /d/coding/git-playground (hotfix)</span><br><span class="line">$ git stash list</span><br><span class="line">stash@&#123;0&#125;: WIP on master: 67e2ce0 c</span><br><span class="line"></span><br><span class="line">MINGW64 /d/coding/git-playground (hotfix)</span><br><span class="line">$ git stash pop</span><br><span class="line">On branch hotfix</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git restore &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">        modified:   C.java</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">&quot;git add&quot;</span> and/or <span class="string">&quot;git commit -a&quot;</span>)</span><br><span class="line">Dropped refs/stash@&#123;0&#125; (ac1f4723b275d86c14127b17395be9d2cd759f59)</span><br></pre></td></tr></table></figure><h4 id="–index选项">–index选项</h4><p>如果不添加<code>--index</code>选项，则应用（<code>apply</code>）储藏对象时，原本已暂存的对象不会被重新暂存，比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ git status -s</span><br><span class="line">M  B.java <span class="comment"># 已暂存</span></span><br><span class="line"> M C.java <span class="comment"># 未暂存</span></span><br><span class="line"> </span><br><span class="line">$ git stash <span class="comment"># 创建储藏</span></span><br><span class="line">Saved working directory and index state WIP on testchange2: f9ae487 xxx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接应用储藏</span></span><br><span class="line">$ git stash pop</span><br><span class="line">On branch testchange2</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git restore &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">        modified:   B.java</span><br><span class="line">        modified:   C.java</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">&quot;git add&quot;</span> and/or <span class="string">&quot;git commit -a&quot;</span>)</span><br><span class="line">Dropped refs/stash@&#123;0&#125; (071d62cc3c4bd28dcc7874c035ff272b13385ff1)</span><br><span class="line"></span><br><span class="line">$ git status -s</span><br><span class="line"> M B.java <span class="comment"># 变为未暂存状态</span></span><br><span class="line"> M C.java</span><br></pre></td></tr></table></figure><p>同样的情况，如果我们加上<code>--index</code>选项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ git status -s</span><br><span class="line">M  B.java <span class="comment"># 已暂存</span></span><br><span class="line"> M C.java <span class="comment"># 未暂存</span></span><br><span class="line"></span><br><span class="line">$ git stash</span><br><span class="line">Saved working directory and index state WIP on testchange2: f9ae487 xxx</span><br><span class="line"></span><br><span class="line">$ git stash apply --index</span><br><span class="line">On branch testchange2</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git restore --staged &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line">        modified:   B.java</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git restore &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">        modified:   C.java</span><br><span class="line"></span><br><span class="line">$ git status -s</span><br><span class="line">M  B.java <span class="comment"># 仍然是已暂存的状态</span></span><br><span class="line"> M C.java</span><br></pre></td></tr></table></figure><h4 id="–keep-index选项">–keep-index选项</h4><p>有几个储藏的变种可能也很有用。 第一个非常流行的选项是 <code>stash save</code> 命令的 <code>--keep-index</code> 选项。 它告诉 Git 不要储藏任何你通过 <code>git add</code> 命令已暂存的东西。</p><p>当你做了几个改动并只想提交其中的一部分，过一会儿再回来处理剩余改动时，这个功能会很有用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ git st</span><br><span class="line">On branch hotfix</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git restore --staged &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line">        modified:   B.java</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git restore &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">        modified:   C.java</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 若使用-s命令,显示如下:</span></span><br><span class="line">$ git st -s</span><br><span class="line">M  B.java <span class="comment"># 已暂存</span></span><br><span class="line"> M C.java <span class="comment"># 未暂存</span></span><br></pre></td></tr></table></figure><p>此时执行<code>git stash --keep-index</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git stash --keep-index</span><br><span class="line">Saved working directory and index state WIP on hotfix: b5e0e78 提交D.java</span><br><span class="line"></span><br><span class="line">$ git status -s</span><br><span class="line">M  B.java</span><br></pre></td></tr></table></figure><p>可以看到：之前已经暂存过的文件<code>B.java</code>并没有被放到stash中，未暂存的文件<code>C.java</code>的改动被放到了stash中。</p><p>如果上面的<code>stash</code>操作不添加 <code>--keep-index</code> 选项，则会同时储藏如上2个更改的文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch hotfix</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git restore --staged &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line">        modified:   B.java</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git restore &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">        modified:   C.java</span><br><span class="line"></span><br><span class="line">$ git stash</span><br><span class="line">Saved working directory and index state WIP on hotfix: b5e0e78 提交D.java</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch hotfix</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><h4 id="–include-untracked选项">–include-untracked选项</h4><p><code>git stash</code> 只会储藏已经在索引中的文件。 如果指定 <code>--include-untracked</code> 或 <code>-u</code> 标记，Git 也会储藏任何创建的<strong>未跟踪文件</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git status -s</span><br><span class="line"> M B.java</span><br><span class="line"> M C.java</span><br><span class="line">?? X.java</span><br></pre></td></tr></table></figure><p>执行 <code>git stash -u</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git stash -u</span><br><span class="line">Saved working directory and index state WIP on hotfix: b5e0e78 提交D.java</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch hotfix</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><p>若同样的操作不添加<code>-u</code>选项，则结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Saved working directory and index state WIP on hotfix: b5e0e78 提交D.java</span><br><span class="line"></span><br><span class="line">86182@yawen MINGW64 /d/coding/git-playground (hotfix)</span><br><span class="line">$ git status -s</span><br><span class="line">?? X.java <span class="comment"># 不会暂存未跟踪的文件</span></span><br></pre></td></tr></table></figure><h4 id="–patch选项（交互式）">–patch选项（交互式）</h4><p>如果指定了 <code>--patch</code> 标记，Git <strong>不会储藏所有修改过的任何东西</strong>，但是<strong>会交互式地提示哪些改动想要储藏、哪些改动需要保存在工作目录中</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$ git status -s</span><br><span class="line"> M B.java</span><br><span class="line"> M C.java</span><br><span class="line">?? X.java <span class="comment"># 未追踪文件</span></span><br><span class="line"></span><br><span class="line">$ git stash --patch</span><br><span class="line">diff --git a/B.java b/B.java <span class="comment"># B.java文件</span></span><br><span class="line">index e69de29..190a180 100644</span><br><span class="line">--- a/B.java</span><br><span class="line">+++ b/B.java</span><br><span class="line">@@ -0,0 +1 @@</span><br><span class="line">+123</span><br><span class="line">(1/1) Stash this hunk [y,n,q,a,d,e,?]? y <span class="comment"># yes</span></span><br><span class="line"></span><br><span class="line">diff --git a/C.java b/C.java <span class="comment">#  C.java</span></span><br><span class="line">index e69de29..3bd9bce 100644</span><br><span class="line">--- a/C.java</span><br><span class="line">+++ b/C.java</span><br><span class="line">@@ -0,0 +1 @@</span><br><span class="line">+3333</span><br><span class="line">(1/1) Stash this hunk [y,n,q,a,d,e,?]? n <span class="comment"># no </span></span><br><span class="line"></span><br><span class="line">Saved working directory and index state WIP on hotfix: b5e0e78 提交D.java</span><br><span class="line"></span><br><span class="line">$ git status -s</span><br><span class="line"> M C.java</span><br><span class="line">?? X.java</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><ul class="lvl-1"><li class="lvl-2"><p>因为没有添加<code>-u</code>选项，因此交互式stash询问的文件列表中不包含<code>X.java</code>，另外，这2个选项不能一起使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git stash --patch -u</span><br><span class="line">Can<span class="string">&#x27;t use --patch and --include-untracked or --all at the same time</span></span><br></pre></td></tr></table></figure></li></ul></blockquote><h3 id="从储创建分支">从储创建分支</h3><p>如果储藏了一些工作，将它留在那儿了一会儿，然后继续在储藏的分支上工作，在重新应用工作时<strong>可能会有问题</strong>。 如果应用尝试修改刚刚修改的文件，你会得到一个合并冲突并不得不解决它。 如果想要一个轻松的方式来再次测试储藏的改动，可以运行 <code>git stash branch</code> <strong>创建一个新分支</strong>，检出储藏工作时所在的提交，重新在那应用工作，然后在应用成功后扔掉储藏：</p><p>首先创建演示用的stash:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">MINGW64 /d/coding/git-playground (hotfix)</span><br><span class="line">$ git st -s</span><br><span class="line"> M B.java</span><br><span class="line"> M C.java</span><br><span class="line">?? X.java</span><br><span class="line"></span><br><span class="line">MINGW64 /d/coding/git-playground (hotfix)</span><br><span class="line">$ git stash</span><br><span class="line">Saved working directory and index state WIP on hotfix: b5e0e78 提交D.java</span><br><span class="line"></span><br><span class="line">MINGW64 /d/coding/git-playground (hotfix)</span><br><span class="line">$ git stash list</span><br><span class="line">stash@&#123;0&#125;: WIP on hotfix: b5e0e78 提交D.java</span><br></pre></td></tr></table></figure><p>将储藏内容应用到一个新创建的分支上：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> MINGW64 /d/coding/git-playground (hotfix)</span><br><span class="line">$ git stash branch testchanges</span><br><span class="line">Switched to a new branch <span class="string">&#x27;testchanges&#x27;</span></span><br><span class="line">On branch testchanges</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git restore &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">        modified:   B.java</span><br><span class="line">        modified:   C.java</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to include <span class="keyword">in</span> what will be committed)</span><br><span class="line">        X.java</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">&quot;git add&quot;</span> and/or <span class="string">&quot;git commit -a&quot;</span>)</span><br><span class="line">Dropped refs/stash@&#123;0&#125; (b5efc71b50efa1ddd809903925f9c6b022bb8752)</span><br><span class="line"></span><br><span class="line">MINGW64 /d/coding/git-playground (testchanges) <span class="comment"># 注意已经自动切换到新分支上</span></span><br><span class="line">$ git status -s</span><br><span class="line"> M B.java</span><br><span class="line"> M C.java</span><br><span class="line">?? X.java</span><br><span class="line"></span><br><span class="line">n MINGW64 /d/coding/git-playground (testchanges)</span><br><span class="line">$ git stash list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时stash中内容已经被弹出</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><ul class="lvl-1"><li class="lvl-2">如果有多个stash,该命令也只会应用最新的一个stash,即：<code>stash@&#123;0&#125;</code>。</li></ul></blockquote><h3 id="清理工作目录">清理工作目录</h3><p>对于工作目录中一些工作或文件，你想做的也许不是储藏而是<strong>移除</strong>。 <code>git clean</code> 命令会帮你做这些事。</p><p>有一些通用的原因比如说为了移除由<strong>合并或外部工具生成的东西</strong>，或是为了运行一个干净的构建而移除之前构建的残留。</p><p>你需要<strong>谨慎地使用这个命令</strong>，因为它被设计为<strong>从工作目录中移除未被追踪的文件</strong>。 如果你改变主意了，你也不一定能找回来那些文件的内容。 一个更安全的选项是运行 <code>git stash --all</code> 来移除每一样东西并存放在栈中。</p><p>你可以使用<code>git clean</code>命令去除冗余文件或者清理工作目录。 使用<code>git clean -f -d</code>命令来移除工作目录中所有未追踪的文件以及空的子目录。 <code>-f</code> 意味着 <em>强制</em> 或 “确定移除”。</p><p>如果只是想要看看它会做什么，可以使用 <code>-n</code> 选项来运行命令，这意味着 “做一次演习然后告诉你 <em>将要</em> 移除什么”。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ git status -s</span><br><span class="line">A  X.java <span class="comment"># 已暂存</span></span><br><span class="line">?? YY.java <span class="comment"># 未跟踪</span></span><br><span class="line"></span><br><span class="line">$ git clean -d -n</span><br><span class="line">Would remove YY.java <span class="comment"># 将会删除YY.java文件</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ git clean -d</span><br><span class="line">fatal: clean.requireForce defaults to <span class="literal">true</span> and neither -i, -n, nor -f given; refusing to clean</span><br><span class="line"></span><br><span class="line">$ git clean -d -f</span><br><span class="line">Removing YY.java</span><br><span class="line"></span><br><span class="line">$ git status -s</span><br><span class="line">A  X.java</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><ul class="lvl-1"><li class="lvl-2">直接执行<code>git clean -d</code>会报错，需要配置参数 <code>-i</code>,<code> -n</code>,或 <code>-f</code> 使用</li></ul></blockquote><p>默认情况下，<code>git clean</code> 命令只会移除<strong>没有忽略的未跟踪文件</strong>。 任何与 <code>.gitiignore</code> 或其他忽略文件中的模式匹配的文件都不会被移除。 如果你也想要移除那些文件，例如为了做一次完全干净的构建而移除所有由构建生成的 <code>.o</code> 文件，可以给 <code>clean</code> 命令增加一个 <code>-x</code> 选项。</p><blockquote><p>-x</p><p>Don’t use the standard ignore rules (see <a href="gitignore.html">gitignore(5)</a>), but still use the ignore rules given with <code>-e</code> options from the command line. This allows removing all untracked files, including build products. This can be used (possibly in conjunction with <em>git restore</em> or <em>git reset</em>) to create a pristine working directory to test a clean build.</p></blockquote><p>如果不知道 <code>git clean</code> 命令将会做什么，在将 <code>-n</code> 改为 <code>-f</code> 来真正做之前总是先用 <code>-n</code> 来运行它做双重检查。 另一个小心处理过程的方式是使用 <code>-i</code> 或 “interactive” 标记来运行它。</p><p>这将会以交互模式运行 clean 命令。</p><h2 id="搜索">搜索</h2><p>无论仓库里的代码量有多少，你经常需要查找一个函数是在哪里调用或者定义的，或者一个方法的变更历史。 Git 提供了两个有用的工具来快速地从它的数据库中<strong>浏览代码和提交</strong>。</p><h3 id="文件内容搜索-Git-Grep">文件内容搜索 Git Grep</h3><h4 id="查看工作区文件">查看工作区文件</h4><p>Git 提供了一个 <code>grep</code> 命令，你可以很方便地从<strong>提交历史</strong>或者<strong>工作目录</strong>中查找<strong>一个字符串</strong>或者<strong>正则表达式</strong>。</p><p>默认情况下 Git 会<strong>查找你工作目录</strong>的文件。 你可以传入 <code>-n</code> 参数来<strong>输出</strong> Git 所找到的<strong>匹配行行号</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git grep -n <span class="string">&#x27;preorderTraversal&#x27;</span></span><br><span class="line">A.java:1: public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;</span><br></pre></td></tr></table></figure><p>该命令相当于：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ grep -rn <span class="string">&#x27;preorderTraversal&#x27;</span> <span class="comment"># 注意此处是直接使用系统的grep命令</span></span><br><span class="line">java:1: public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;</span><br></pre></td></tr></table></figure><p><code>grep</code> 命令还有一些其他有趣的选项：</p><ul class="lvl-0"><li class="lvl-3"><p><code>--count</code>：使 Git 输出概述的信息，仅仅包括哪些文件包含匹配以及每个文件包含了多少个匹配：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git grep --count <span class="string">&#x27;preorderTraversal&#x27;</span></span><br><span class="line">A.java:1 <span class="comment"># 匹配一次</span></span><br><span class="line">B.java:1 <span class="comment"># 匹配一次</span></span><br></pre></td></tr></table></figure><p>相当于：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ grep -c <span class="string">&#x27;preorderTraversal&#x27;</span> *</span><br><span class="line">A.java:1</span><br><span class="line">B.java:1</span><br><span class="line">C.java:0</span><br><span class="line"><span class="comment"># 注意：不加-r选项，否则会递归搜索当前层级的目录</span></span><br></pre></td></tr></table></figure></li><li class="lvl-2"><p><code>-p</code>:等价于<code>--show-function</code>看匹配的行是属于哪一个<strong>方法</strong>或者<strong>函数</strong></p></li><li class="lvl-2"><p><code>--and</code>:也就是在同一行同时包含多个匹配，比如查看同时包含字符串<code>isEmpty</code>和<code>root</code></p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$  git grep --<span class="built_in">break</span> --heading -n -e isEmpty --and -e root</span><br><span class="line">A.java</span><br><span class="line">7:        <span class="keyword">while</span> (!stack.isEmpty() || null != root) &#123;</span><br><span class="line"></span><br><span class="line">B.java</span><br><span class="line">7:        <span class="keyword">while</span> (!stack.isEmpty() || null != root) &#123;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p><code>--break</code></p><p>Print an empty line between matches from different files.</p><p><code>--heading</code></p><p>Show the filename above the matches in that file instead of at the start of each shown line.</p></blockquote></li></ul><h4 id="搜索某个tag">搜索某个tag</h4><p>可以直接为<code>git grep</code>命令传递一个<code>tag</code>名称，来查找该<code>tag</code>中的内容（<strong>无需检出</strong>该<code>tag</code>）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git tag</span><br><span class="line">V1.0</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cat</span> B.java</span><br><span class="line">import java.util.*; <span class="comment"># 工作区中的B.java只有一行</span></span><br><span class="line"></span><br><span class="line">$ git grep preorderTraversal V1.0 <span class="comment"># 查找V1.0版本</span></span><br><span class="line">V1.0:A.java: public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;</span><br><span class="line">V1.0:B.java: public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;</span><br><span class="line"><span class="comment"># V1.0版本的B.java中版本目标字符串</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><p>不添加具体的搜索对象，比如此处的tag时，默认搜索的是<strong>工作区间</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git grep preorderTraversal</span><br><span class="line">A.java: public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;</span><br><span class="line"><span class="comment"># B.java中不包含目标字符串</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="搜索某个提交版本">搜索某个提交版本</h4><p>比如查看<strong>某个版本</strong>中是否包含字符串<code>MAX_CLIENT_NUM</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">MINGW64 /d/coding/git-playground (master)</span><br><span class="line">$ git <span class="built_in">log</span> --all --oneline --graph</span><br><span class="line">* edf6a15 (HEAD -&gt; master) 修改b.java 4</span><br><span class="line">* 3fd607e 修改b.java 3</span><br><span class="line">* c12c285 修改b.java 2</span><br><span class="line">* 8bb668c 修改b.java 1</span><br><span class="line">* c5c685c 修改b.java</span><br><span class="line">* f651a30 (tag: V1.0) 修改B.java</span><br><span class="line">* dbc734b 修改A.java</span><br><span class="line">* 7141c32 yyysdfk</span><br><span class="line">| *   4e40fd0 (refs/stash) WIP on testchange2: f9ae487 xxx</span><br><span class="line">| |\</span><br><span class="line">| | * 9f6b560 index on testchange2: f9ae487 xxx</span><br><span class="line">| |/</span><br><span class="line">| * f9ae487 (testchange2) xxx</span><br><span class="line">| * b5e0e78 (testchanges, hotfix) 提交D.java</span><br><span class="line">|/</span><br><span class="line">* 67e2ce0 c</span><br><span class="line">* c9c8710 B</span><br><span class="line">* 9749b1c A</span><br><span class="line"></span><br><span class="line">MINGW64 /d/coding/git-playground (master)</span><br><span class="line">$ git grep <span class="string">&#x27;MAX_CLIENT_NUM&#x27;</span> 8bb668c <span class="comment"># 提交ID</span></span><br><span class="line">8bb668c:B.java: private  static final string MAX_CLIENT_NUM = 5; <span class="comment"># 匹配到结果</span></span><br><span class="line"></span><br><span class="line">MINGW64 /d/coding/git-playground (master)</span><br><span class="line">$ git grep <span class="string">&#x27;MAX_CLIENT_NUM&#x27;</span> f651a30  <span class="comment"># 未匹配到结果</span></span><br></pre></td></tr></table></figure><h4 id="相比grep等系统命令的优点">相比grep等系统命令的优点</h4><p>相比于一些常用的搜索命令比如 <code>grep</code> 和 <code>ack</code>，<code>git grep</code> 命令有一些的优点。 第一就是<strong>速度非常快</strong>，第二是你不仅仅可以<strong>可以搜索工作目录</strong>，还可以搜索<strong>任意的 Git 树</strong>。 在上一个例子中，我们在一个旧版本的<code>V1.0</code>中查找，而<strong>不是当前检出的版本</strong>。</p><h3 id="提交日志搜索">提交日志搜索</h3><p>如果你想知道是什么 <strong>时候</strong> 存在或者引入的。 <code>git log</code> 命令有许多强大的工具可以通过<strong>提交信息</strong>甚至是 <strong>diff 的内容</strong>来找到某个特定的提交。</p><h4 id="搜索新增或删除某个字符串的提交">搜索新增或删除某个字符串的提交</h4><blockquote><p>注意：</p><ul class="lvl-1"><li class="lvl-2">查找的是文件改动的内容，而不是<strong>commit message</strong></li></ul></blockquote><p>比如查看新增或删除了字符串<code>MAX_CLIENT_NU</code>的提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> -SMAX_CLIENT_NUM</span><br><span class="line">commit edf6a156f91ba3682273e3488c166d009beb13fe (HEAD -&gt; master)</span><br><span class="line">Author: slimterry &lt;slimterry@qq.com&gt;</span><br><span class="line">Date:   Mon Apr 1 10:22:59 2024 +0800</span><br><span class="line"></span><br><span class="line">    修改b.java 4</span><br><span class="line"></span><br><span class="line">commit 8bb668c784541ad5cf34f8d22685db727fb9175c</span><br><span class="line">Author: slimterry &lt;slimterry@qq.com&gt;</span><br><span class="line">Date:   Mon Apr 1 10:20:49 2024 +0800</span><br><span class="line"></span><br><span class="line">    修改b.java 1</span><br></pre></td></tr></table></figure><blockquote><p>本例中：在<code>8bb668c</code>中引入了字符串<code>MAX_CLIENT_NU</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ git show 8bb668c</span><br><span class="line">commit 8bb668c784541ad5cf34f8d22685db727fb9175c</span><br><span class="line">Author: slimterry &lt;slimterry@qq.com&gt;</span><br><span class="line">Date:   Mon Apr 1 10:20:49 2024 +0800</span><br><span class="line"></span><br><span class="line">    修改b.java 1</span><br><span class="line"></span><br><span class="line">diff --git a/B.java b/B.java</span><br><span class="line">index 017d7d3..fd03efe 100644</span><br><span class="line">--- a/B.java</span><br><span class="line">+++ b/B.java</span><br><span class="line">@@ -1 +1,5 @@</span><br><span class="line"> import java.util.*;</span><br><span class="line">+</span><br><span class="line">+public class B&#123;</span><br><span class="line">+       private  static final string MAX_CLIENT_NUM = 5; <span class="comment"># 新增该行</span></span><br><span class="line">+&#125;</span><br></pre></td></tr></table></figure><p>在<code>edf6a15</code>中移除了该行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ git show edf6a15</span><br><span class="line">commit edf6a156f91ba3682273e3488c166d009beb13fe (HEAD -&gt; master)</span><br><span class="line">Author: slimterry &lt;slimterry@qq.com&gt;</span><br><span class="line">Date:   Mon Apr 1 10:22:59 2024 +0800</span><br><span class="line"></span><br><span class="line">    修改b.java 4</span><br><span class="line"></span><br><span class="line">diff --git a/B.java b/B.java</span><br><span class="line">index 2e68846..6b97f2c 100644</span><br><span class="line">--- a/B.java</span><br><span class="line">+++ b/B.java</span><br><span class="line">@@ -1,7 +1,6 @@</span><br><span class="line"> import java.util.*;</span><br><span class="line"></span><br><span class="line"> public class B&#123;</span><br><span class="line">-       private  static final string MAX_CLIENT_NUM = 5; <span class="comment"># 移除该行</span></span><br><span class="line">        private  static final string MAX_WAIT_SEC = 10;</span><br><span class="line">        private  static final string MAX_POOL_SIZE = 10;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="行日志搜索">行日志搜索</h3><p>行日志搜索是另一个相当<strong>高级并且有用</strong>的日志搜索功能。 这是一个最近新增的不太知名的功能，但却是十分有用。 在 <code>git log</code> 后加上 <code>-L</code> 选项即可调用，它可以展示代码中<strong>一行</strong>或者<strong>一个函数</strong>的历史。</p><blockquote><p>-L<start>,<end>:<file></p><p>-L:<funcname>:<file></p><p>Trace the <strong>evolution</strong> of the line range given by <em><start>,<end></em>, or by the function name regex <em><funcname></em>, within the <em><file></em>. You may not give any pathspec limiters. This is currently limited to a walk starting from a single revision, i.e., you may only give zero or one positive revision arguments, and <em><start></em> and <em><end></em> (or <em><funcname></em>) must exist in the starting revision. You can specify this option more than once. Implies <code>--patch</code>. Patch output can be suppressed using <code>--no-patch</code>, but other diff formats (namely <code>--raw</code>, <code>--numstat</code>, <code>--shortstat</code>, <code>--dirstat</code>, <code>--summary</code>, <code>--name-only</code>, <code>--name-status</code>, <code>--check</code>) are not currently implemented.</p></blockquote><p>一般可以通过:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> -L :funcname:file </span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">git <span class="built_in">log</span> -L start,end:file</span><br></pre></td></tr></table></figure><p>的形式查找，但是很有可能查不到，所以可以直接换成正则表示式的形式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> -L <span class="string">&#x27;/匹配函数名的正则表示式/&#x27;</span>:file</span><br></pre></td></tr></table></figure><p>比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> -L <span class="string">&#x27;/test1/&#x27;</span>:B.java</span><br><span class="line">commit 5e5996c6423c49855f481af7a81294d33e96cfbf (HEAD -&gt; master)</span><br><span class="line">Author: slimterry &lt;slimterry@qq.com&gt;</span><br><span class="line">Date:   Mon Apr 1 10:39:09 2024 +0800</span><br><span class="line"></span><br><span class="line">    修改b.java 6</span><br><span class="line"></span><br><span class="line">diff --git a/B.java b/B.java</span><br><span class="line">--- a/B.java</span><br><span class="line">+++ b/B.java</span><br><span class="line">@@ -6,5 +6,6 @@</span><br><span class="line">        public void <span class="function"><span class="title">test1</span></span>()&#123;</span><br><span class="line">                // <span class="keyword">do</span> something 1</span><br><span class="line">+               // <span class="keyword">do</span> something 2</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">commit cce2144ca890e26d313d18a23f1e1015191ba2c6</span><br><span class="line">Author: slimterry &lt;slimterry@qq.com&gt;</span><br><span class="line">Date:   Mon Apr 1 10:38:44 2024 +0800</span><br><span class="line"></span><br><span class="line">    修改b.java 5</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">86182@yawen MINGW64 /d/coding/git-playground (master)</span><br><span class="line">$ git <span class="built_in">log</span> -L <span class="string">&#x27;/test1\(\)/&#x27;</span>:B.java</span><br><span class="line">commit 5e5996c6423c49855f481af7a81294d33e96cfbf (HEAD -&gt; master)</span><br><span class="line">Author: slimterry &lt;slimterry@qq.com&gt;</span><br><span class="line">Date:   Mon Apr 1 10:39:09 2024 +0800</span><br><span class="line"></span><br><span class="line">    修改b.java 6</span><br><span class="line"></span><br><span class="line">diff --git a/B.java b/B.java</span><br><span class="line">--- a/B.java</span><br><span class="line">+++ b/B.java</span><br><span class="line">@@ -6,5 +6,6 @@</span><br><span class="line">        public void <span class="function"><span class="title">test1</span></span>()&#123;</span><br><span class="line">                // <span class="keyword">do</span> something 1</span><br><span class="line">+               // <span class="keyword">do</span> something 2</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">commit cce2144ca890e26d313d18a23f1e1015191ba2c6</span><br><span class="line">Author: slimterry &lt;slimterry@qq.com&gt;</span><br><span class="line">Date:   Mon Apr 1 10:38:44 2024 +0800</span><br><span class="line"></span><br><span class="line">    修改b.java 5</span><br></pre></td></tr></table></figure><p>你也可以提供单行或者一个范围的行号来获得相同的输出。</p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git专题之rebase</title>
      <link href="/2024/03/26/git%E4%B8%93%E9%A2%98%E4%B9%8Brebase/"/>
      <url>/2024/03/26/git%E4%B8%93%E9%A2%98%E4%B9%8Brebase/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是变基？">什么是变基？</h2><p>在 Git 中<strong>整合来自不同分支的修改</strong>主要有两种方法：<code>merge</code> 以及 <code>rebase</code>。</p><h2 id="回顾merge案例">回顾merge案例</h2><p>考虑如下的例子：</p><p>开发任务分叉到两个不同分支，又各自提交了更新：</p><p><img src="image-20240327102927640.png" alt="image-20240327102927640"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> MINGW64 /d/tmp/git-play-merge (master)</span><br><span class="line">$ git <span class="built_in">log</span> --all --oneline --graph</span><br><span class="line">* 1872aaf (experiment) 新增D.java [C4-experiment]</span><br><span class="line">| * b1d77e8 (HEAD -&gt; master) 新增C.java [c3-master]</span><br><span class="line">|/</span><br><span class="line">* c411031 修改B.java [c2-master]</span><br><span class="line">* 4b88828 修改A.java [c1-master]</span><br><span class="line">* 56c457b 初次提交[c0-master]</span><br></pre></td></tr></table></figure><p><img src="image-20240327104639994.png" alt="image-20240327104639994"></p><p>整合分支最容易的方法是 <code>merge</code> 命令。 它会把两个分支的<strong>最新快照</strong>（<code>C3</code> 和 <code>C4</code>）以及二者最近的<strong>共同祖先</strong>（<code>C2</code>）进行<strong>三方合并</strong>，合并的结果是生成一个<strong>新的快照</strong>（并提交）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git merge experiment</span><br><span class="line">Merge made by the <span class="string">&#x27;ort&#x27;</span> strategy.</span><br><span class="line"> D.java | 0</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 D.java</span><br></pre></td></tr></table></figure><p>此时<code>git log</code>如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --all --oneline --graph</span><br><span class="line">*   a278b29 (HEAD -&gt; master) Merge branch <span class="string">&#x27;experiment&#x27;</span> [C5--master]</span><br><span class="line">|\</span><br><span class="line">| * 1872aaf (experiment) 新增D.java [C4-experiment]</span><br><span class="line">* | b1d77e8 新增C.java [c3-master]</span><br><span class="line">|/</span><br><span class="line">* c411031 修改B.java [c2-master]</span><br><span class="line">* 4b88828 修改A.java [c1-master]</span><br><span class="line">* 56c457b 初次提交[c0-master]</span><br></pre></td></tr></table></figure><p><img src="image-20240327105206916.png" alt="image-20240327105206916"></p><p><img src="image-20240327105238883.png" alt="image-20240327105238883"></p><p>其实，还有一种方法：你可以提取在 <code>C4</code> 中引入的补丁和修改，然后在 <code>C3</code> 的基础上<strong>应用一次</strong>。 在 Git 中，这种操作就叫做 <em>变基</em>。</p><h2 id="rebase操作和原理">rebase操作和原理</h2><p>你可以使用 <code>rebase</code> 命令<strong>将提交到某一分支上的所有修改都移至另一分支上</strong>，就好像“<strong>重新播放</strong>”一样。</p><p>在上面这个例子中，运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MINGW64 /d/tmp/git-play-rebase (experiment)</span><br><span class="line">$ git checkout experiment</span><br><span class="line"></span><br><span class="line">MINGW64 /d/tmp/git-play-rebase (experiment)</span><br><span class="line">$ git rebase master</span><br><span class="line">Successfully rebased and updated refs/heads/experiment.</span><br></pre></td></tr></table></figure><blockquote><p>注意：以下2组命令是等价的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout experiment </span><br><span class="line">$ git rebase master </span><br><span class="line"><span class="comment"># 相当于</span></span><br><span class="line">$ git rebase master experiment</span><br><span class="line"><span class="comment"># rebase过后会直接停留在experiment，不需要单独checkout过去</span></span><br></pre></td></tr></table></figure><p>比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MINGW64 /d/tmp/git-play-rebase2 (master)</span><br><span class="line">$ git rebase master experiment</span><br><span class="line">Successfully rebased and updated refs/heads/experiment.</span><br><span class="line"></span><br><span class="line">MINGW64 /d/tmp/git-play-rebase2 (experiment) <span class="comment"># 停留在experiment分支</span></span><br></pre></td></tr></table></figure></blockquote><p><code>rebase</code>前的<code>git log</code>如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MINGW64 /d/tmp/git-play-rebase (experiment)</span><br><span class="line">$ git <span class="built_in">log</span> --all --oneline --graph</span><br><span class="line">* 1872aaf (HEAD -&gt; experiment) 新增D.java [C4-experiment]</span><br><span class="line">| * b1d77e8 (master) 新增C.java [c3-master]</span><br><span class="line">|/</span><br><span class="line">* c411031 修改B.java [c2-master]</span><br><span class="line">* 4b88828 修改A.java [c1-master]</span><br><span class="line">* 56c457b 初次提交[c0-master]</span><br></pre></td></tr></table></figure><p><img src="image-20240327104639994.png" alt="image-20240327104639994"></p><p><code>rebase</code>后的<code>git log</code>如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MINGW64 /d/tmp/git-play-rebase (experiment)</span><br><span class="line">$ git <span class="built_in">log</span> --all --oneline --graph</span><br><span class="line">* f12abe6 (HEAD -&gt; experiment) 新增D.java [C4-experiment]</span><br><span class="line">* b1d77e8 (master) 新增C.java [c3-master]</span><br><span class="line">* c411031 修改B.java [c2-master]</span><br><span class="line">* 4b88828 修改A.java [c1-master]</span><br><span class="line">* 56c457b 初次提交[c0-master]</span><br></pre></td></tr></table></figure><p><img src="image-20240327110153272.png" alt="image-20240327110153272"></p><blockquote><p>注意：<code>git rebase master</code>不会改变<code>master</code>分支！因为我们是在<code>experiment</code>分支上操作的！若此时查看<code>master</code>分支，可以发现<strong>根本没有发生变化</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">&#x27;master&#x27;</span></span><br><span class="line"></span><br><span class="line">$ git <span class="built_in">log</span> --oneline</span><br><span class="line">b1d77e8 (HEAD -&gt; master) 新增C.java [c3-master]</span><br><span class="line">c411031 修改B.java [c2-master]</span><br><span class="line">4b88828 修改A.java [c1-master]</span><br><span class="line">56c457b 初次提交[c0-master]</span><br></pre></td></tr></table></figure></blockquote><p><code>rebase</code>的原理是首先找到这两个分支（即当前分支 <code>experiment</code>、变基操作的<strong>目标基底分支</strong> <code>master</code>）的最近共同祖先 <code>C2</code>，然后<strong>对比当前分支experiment相对于该祖先C2的历次提交</strong>（本例中只有<code>C4</code>），<strong>提取相应的修改并存为临时文件</strong>，然后将当前分支指向目标基底 <code>C3</code>（即把<code>C3</code>当作父提交对象）, 最后以此将之前另存为临时文件的修改依序应用:</p><p><code>rebase</code>前：</p><p><img src="image-20240327111051896.png" alt="image-20240327111051896"></p><p><code>rebase</code>后：</p><p><img src="image-20240327111030422.png" alt="image-20240327111030422"></p><p>现在回到 <code>master</code> 分支，进行合并操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git merge experiment</span><br><span class="line">Updating b1d77e8..f12abe6</span><br><span class="line">Fast-forward</span><br><span class="line"> D.java | 0</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 D.java</span><br></pre></td></tr></table></figure><p>可以看到此时的<code>merge</code>是通过<code>Fast-forward</code>完成的，而不是<strong>三方合并</strong>（即仅移动了<code>master</code>指针，并未生成新的提交）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MINGW64 /d/tmp/git-play-rebase (master)</span><br><span class="line">$ git <span class="built_in">log</span> --all --oneline --graph</span><br><span class="line">* f12abe6 (HEAD -&gt; master, experiment) 新增D.java [C4-experiment]</span><br><span class="line">* b1d77e8 新增C.java [c3-master]</span><br><span class="line">* c411031 修改B.java [c2-master]</span><br><span class="line">* 4b88828 修改A.java [c1-master]</span><br><span class="line">* 56c457b 初次提交[c0-master]</span><br></pre></td></tr></table></figure><p><img src="image-20240327111624936.png" alt="image-20240327111624936"></p><p><img src="image-20240327111706456.png" alt="image-20240327111706456"></p><p>此时，<code>C4'</code> 指向的快照就和上面使用 <code>merge</code> 命令的例子中 <code>C5</code> 指向的快照一模一样了。 这两种整合方法的最终结果没有任何区别，但是<strong>变基使得提交历史更加整洁</strong>。 你在查看一个经过变基的分支的历史记录时会发现，尽管实际的开发工作是并行的，但它们看上去就像是串行的一样，提交历史是一条直线<strong>没有分叉</strong>。</p><p>一般我们这样做的<strong>目的是</strong>为了确保在向远程分支推送时能<strong>保持提交历史的整洁</strong>——例如向某个其他人维护的项目贡献代码时。 在这种情况下，你首先在自己的分支里进行开发，当开发完成时你需要先将你的代码变基到 <code>origin/master</code> 上，然后再向主项目提交修改。 这样的话，该项目的维护者就不再需要进行整合工作，只需要快进合并便可。</p><p>请注意，无论是通过变基，还是通过三方合并，整合的最终结果所指向的快照始终是一样的，只不过提交历史不同罢了。 <strong>变基是将一系列提交按照原有次序依次应用到另一分支上，而合并是把最终结果合在一起。</strong></p><h2 id="移植（transplant-）分支">移植（transplant ）分支</h2><h3 id="示例1">示例1</h3><blockquote><p>注：以下例子来自<code>git rebase --help</code>文档</p></blockquote><p>如下的过程演示了如何通过<code>git rebase --onto</code>将一个依赖了其他分支(<code>next</code>)的分支（<code>topic</code>）<strong>移植</strong>到另外一个分支<code>master</code>上:</p><p>关于<code>--onto</code> 选项的说明如下：</p><blockquote><p>–onto <newbase></p><p><strong>Starting point at which to create the new commits.</strong> If the <code>--onto</code> option is not specified, the starting point is <code>&lt;upstream&gt;</code>. May be any valid commit, and not just an existing branch name.</p></blockquote><p>首先假设我们的<code>topic</code>分支是基于<code>next</code>分支创建的，各分支的关系如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">o---o---o---o---o  master</span><br><span class="line">       \</span><br><span class="line">        o---o---o---o---o  next</span><br><span class="line">                         \</span><br><span class="line">                          o---o---o  topic</span><br></pre></td></tr></table></figure><p>其中<code>topic</code>分支依赖了<code>next</code>分支上的一些特性或功能。</p><p>我们希望将<code>topic</code>分支移植到<code>master</code>分支上，因为<code>topic</code>分支所依赖的<code>next</code>上的特性和功能已经被合并到更为稳定的分支<code>master</code>上，我们期望的结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">o---o---o---o---o  master</span><br><span class="line">    |            \</span><br><span class="line">    |             o<span class="string">&#x27;--o&#x27;</span>--o<span class="string">&#x27;  topic</span></span><br><span class="line"><span class="string">     \</span></span><br><span class="line"><span class="string">      o---o---o---o---o  next</span></span><br></pre></td></tr></table></figure><p>我们可以通过如下的命令实现这样的效果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase --onto master next topic</span><br></pre></td></tr></table></figure><p>该命令解释如下为：</p><ul class="lvl-0"><li class="lvl-2"><p>取出<code>topic</code>分支上<code>topic</code>和<code>next</code>分支的共同祖先之后的提交，嫁接到分支<code>master</code>上</p></li></ul><h3 id="示例2">示例2</h3><p>假设目前我们的分支情况如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">                        H---I---J topicB</span><br><span class="line">                       /</span><br><span class="line">              E---F---G  topicA</span><br><span class="line">             /</span><br><span class="line">A---B---C---D  master</span><br></pre></td></tr></table></figure><p>通过如下的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase --onto master topicA topicB</span><br></pre></td></tr></table></figure><p>可以将我们的分支调整为如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">             H<span class="string">&#x27;--I&#x27;</span>--J<span class="string">&#x27;  topicB</span></span><br><span class="line"><span class="string">            /</span></span><br><span class="line"><span class="string">            | E---F---G  topicA</span></span><br><span class="line"><span class="string">            |/</span></span><br><span class="line"><span class="string">A---B---C---D  master</span></span><br></pre></td></tr></table></figure><p>在<code>topicB</code>没有依赖<code>topicA</code>时，这种操作很有用。</p><h2 id="一个更有趣的变基例子">一个更有趣的变基例子</h2><p>在对两个分支进行变基时，所生成的“<strong>重放</strong>”并<strong>不一定要在目标分支上应用</strong>，你也<strong>可以指定另外的一个分支</strong>进行应用。 就像 <a href="https://www.progit.cn/#rbdiag_e">从一个特性分支里再分出一个特性分支的提交历史</a> 中的例子那样。 你创建了一个特性分支 <code>server</code>，为服务端添加了一些功能，提交了 <code>C3</code> 和 <code>C4</code>。 然后从 <code>C3</code> 上创建了特性分支 <code>client</code>，为客户端添加了一些功能，提交了 <code>C8</code> 和 <code>C9</code>。 最后，你回到 <code>server</code> 分支，又提交了 <code>C10</code>。</p><p><img src="image-20240327133411280.png" alt="image-20240327133411280"></p><p>假设你希望将 <code>client</code> 中的修改合并到主分支并发布，但暂时并不想合并 <code>server</code> 中的修改，因为它们还需要经过更全面的测试。 这时，你就可以使用 <code>git rebase</code> 命令的 <code>--onto</code> 选项，选中在 <code>client</code> 分支里但不在 <code>server</code> 分支里的修改（即 <code>C8</code> 和 <code>C9</code>），将它们在 <code>master</code> 分支上重放：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase --onto master server client</span><br></pre></td></tr></table></figure><p>以上命令的意思是：“取出 <code>client</code> 分支，找出处于 <code>client</code> 分支和 <code>server</code> 分支的<strong>共同祖先之后的修改</strong>(即：<code>C8</code> 和 <code>C9</code>)，然后把它们在 <code>master</code> 分支上重放一遍”。</p><p>指向该命令后的分支情况如下：</p><p><img src="image-20240327150510213.png" alt="image-20240327150510213"></p><p>实操演示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">MINGW64 /d/tmp/git-transplant (client)</span><br><span class="line">$ git <span class="built_in">log</span> --all --oneline --graph</span><br><span class="line">* a4136d6 (HEAD -&gt; client) C9-client</span><br><span class="line">* b59cca4 C8-client</span><br><span class="line">| * 4921a6c (server) C10-server</span><br><span class="line">| * ea431ca C4-server</span><br><span class="line">|/</span><br><span class="line">* 77a40ff C3-server</span><br><span class="line">| * 9f852d7 (master) C6-master</span><br><span class="line">| * c66c195 C5-master</span><br><span class="line">|/</span><br><span class="line">* a72cd5b C2-master</span><br><span class="line">* 2f087f3 C1-master</span><br></pre></td></tr></table></figure><p><img src="image-20240327155102154.png" alt="image-20240327155102154"></p><p>指向<code>rebase</code>操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 需要先切换到client分支 ！！！</span></span><br><span class="line">MINGW64 /d/tmp/git-transplant (client)</span><br><span class="line">$ git rebase --onto master server  client</span><br><span class="line">Successfully rebased and updated refs/heads/client.</span><br></pre></td></tr></table></figure><p>操作后：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> MINGW64 /d/tmp/git-transplant (client)</span><br><span class="line">$ git <span class="built_in">log</span> --all --oneline --graph</span><br><span class="line">* 4ad6f32 (HEAD -&gt; client) C9-client</span><br><span class="line">* e8a779b C8-client</span><br><span class="line">* 9f852d7 (master) C6-master</span><br><span class="line">* c66c195 C5-master</span><br><span class="line">| * 4921a6c (server) C10-server</span><br><span class="line">| * ea431ca C4-server</span><br><span class="line">| * 77a40ff C3-server</span><br><span class="line">|/</span><br><span class="line">* a72cd5b C2-master</span><br><span class="line">* 2f087f3 C1-master</span><br></pre></td></tr></table></figure><p><img src="image-20240327160328529.png" alt="image-20240327160328529"></p><p>现在可以快进合并(<strong>fast-forward</strong>) <code>master</code> 分支了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">&#x27;master&#x27;</span></span><br><span class="line"></span><br><span class="line">$ git <span class="built_in">log</span> --all --oneline --graph</span><br><span class="line">* 4ad6f32 (client) C9-client <span class="comment"># client在这里!!!</span></span><br><span class="line">* e8a779b C8-client</span><br><span class="line">* 9f852d7 (HEAD -&gt; master) C6-master  <span class="comment"># master在这里！！！</span></span><br><span class="line">* c66c195 C5-master</span><br><span class="line">| * 4921a6c (server) C10-server</span><br><span class="line">| * ea431ca C4-server</span><br><span class="line">| * 77a40ff C3-server</span><br><span class="line">|/</span><br><span class="line">* a72cd5b C2-master</span><br><span class="line">* 2f087f3 C1-master</span><br><span class="line"></span><br><span class="line">$ git merge client</span><br><span class="line">Updating 9f852d7..4ad6f32</span><br><span class="line">Fast-forward  <span class="comment"># 可以发现是Fast-forward模式</span></span><br><span class="line">....</span><br><span class="line"> 2 files changed, 0 insertions(+), 0 deletions(-)</span><br></pre></td></tr></table></figure><p>此时再次查看<code>git log</code>如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">* 4ad6f32 (HEAD -&gt; master, client) C9-client <span class="comment"># 只是后移了HEAD、master指针</span></span><br><span class="line">* e8a779b C8-client</span><br><span class="line">* 9f852d7 C6-master</span><br><span class="line">* c66c195 C5-master</span><br><span class="line">| * 4921a6c (server) C10-server</span><br><span class="line">| * ea431ca C4-server</span><br><span class="line">| * 77a40ff C3-server</span><br><span class="line">|/</span><br><span class="line">* a72cd5b C2-master</span><br><span class="line">* 2f087f3 C1-master</span><br></pre></td></tr></table></figure><h2 id="变基的风险">变基的风险</h2><h3 id="原则">原则</h3><p>呃，奇妙的变基也并非完美无缺，要用它得遵守一条准则：</p><p><strong>不要对在你的仓库外有副本的分支执行变基</strong></p><blockquote><p>简而言之就是：如果分支已经推送到远端，则不要针对该分支进行变基操作！</p></blockquote><p>如果你遵循这条金科玉律，就不会出差错。</p><p>变基操作的实质是<strong>丢弃一些现有的提交</strong>，然后相应地<strong>新建一些内容一样但实际上不同的提交</strong>。</p><p>如果你已经将提交推送至某个仓库，而其他人也已经从该仓库拉取提交并进行了后续工作，此时，如果你用 <code>git rebase</code> 命令重新整理了提交并再次推送，你的同伴因此将不得不再次将他们手头的工作与你的提交进行整合，如果接下来你还要拉取并整合他们修改过的提交，事情就会变得一团糟。</p><h3 id="风险演示">风险演示</h3><p>让我们来看一个在公开的仓库上执行变基操作所带来的问题。 假设你从一个中央服务器克隆然后在它的基础上进行了一些开发。 你的提交历史如图所示：</p><p><img src="image-20240327162649219.png" alt="image-20240327162649219"></p><p>然后，<strong>某人</strong>又向中央服务器提交了一些修改，其中还包括一次<strong>合并</strong>（此处为：合并提交）。 你抓取了这些在远程分支上的修改，并将其<strong>合并到你本地的开发分支</strong>，然后你的提交历史就会变成这样：</p><p><img src="image-20240327163100756.png" alt="image-20240327163100756"></p><blockquote><p>其中</p><ul class="lvl-1"><li class="lvl-2"><code>teamone</code>为远程分支的名字</li><li class="lvl-2"><code>C7</code>为一次合并提交</li></ul></blockquote><p>接下来，<strong>这个人</strong>又决定把合并操作回滚，<strong>改用变基</strong>；继而又用 <code>git push --force</code> 命令覆盖了服务器上的提交历史。 之后你从服务器抓取更新，会发现多出来一些新的提交。</p><p><img src="image-20240327165019386.png" alt="image-20240327165019386"></p><blockquote><p>本地的<code>C4</code>及之前合并提交产生的<code>C6</code>仍然存在</p></blockquote><p>结果就是你们两人的处境都十分尴尬。 如果你执行 <code>git pull</code> 命令，你将合并来自两条提交历史的内容，生成一个新的合并提交，最终仓库会如图所示：</p><p><img src="image-20240327165351710.png" alt="image-20240327165351710"></p><p>此时如果你执行 <code>git log</code> 命令，你会发现有<strong>两个提交的作者、日期、日志居然是一样的</strong>，这会令人感到混乱。 此外，如果你将这一堆又推送到服务器上，你实际上是将那些已经被变基抛弃的提交又找了回来，这会令人感到更加混乱。 很明显对方并不想在提交历史中看到 <code>C4</code> 和 <code>C6</code>，因为之前就是他把这两个提交通过变基丢弃的。</p><h3 id="用变基解决变基">用变基解决变基</h3><p>果你 <strong>真的</strong> 遭遇了类似的处境，Git 还有一些高级魔法可以帮到你。 如果团队中的某人强制推送并覆盖了一些你所基于的提交，你需要做的就是检查你做了哪些修改，以及他们覆盖了哪些修改。</p><p>实际上，Git 除了对整个提交计算 SHA-1 校验和以外，也对本次提交所引入的修改计算了校验和—— 即 “patch-id”。</p><p>如果你拉取被覆盖过的更新并将你手头的工作基于此进行变基的话，一般情况下 Git 都能成功分辨出哪些是你的修改，并把它们应用到新分支上。</p><p>举个例子，如果遇到前面提到的 <a href="https://www.progit.cn/#_pre_merge_rebase_work">有人推送了经过变基的提交，并丢弃了你的本地开发所基于的一些提交</a> 那种情境，如果我们不是执行合并，而是执行 <code>git rebase teamone/master</code>, Git 将会：</p><ul class="lvl-0"><li class="lvl-2"><p>检查哪些提交是我们的分支上独有的（C2，C3，C4，C6，C7）</p></li><li class="lvl-2"><p>检查其中哪些提交不是合并操作的结果（C2，C3，C4）</p></li><li class="lvl-2"><p>检查哪些提交在对方覆盖更新时并没有被纳入目标分支（只有 C2 和 C3，因为 C4 其实就是 C4’）</p></li><li class="lvl-2"><p>把查到的这些提交应用在 <code>teamone/master</code> 上面</p></li></ul><p>从而我们将得到与 <a href="https://www.progit.cn/#_merge_rebase_work">你将相同的内容又合并了一次，生成了一个新的提交</a> 中不同的结果，如图 <a href="https://www.progit.cn/#_rebase_rebase_work">在一个被变基然后强制推送的分支上再次执行变基</a> 所示。</p><p><img src="image-20240327165628965.png" alt="image-20240327165628965"></p><p>要想上述方案有效，还需要对方在变基时确保 C4’ 和 C4 是几乎一样的。 否则变基操作将无法识别，并新建另一个类似 C4 的补丁（而这个补丁很可能无法整洁的整合入历史，因为补丁中的修改已经存在于某个地方了）。</p><p>在本例中另一种简单的方法是使用 <code>git pull --rebase</code> 命令而不是直接 <code>git pull</code>。 又或者你可以自己手动完成这个过程，先 <code>git fetch</code>，再 <code>git rebase teamone/master</code>。</p><p>如果你习惯使用 <code>git pull</code> ，同时又希望默认使用选项 <code>--rebase</code>，你可以执行这条语句 <code>git config --global pull.rebase true</code> 来更改 <code>pull.rebase</code> 的默认配置。</p><p>只要你把变基命令当作是在推送前清理提交使之整洁的工具，并且只在从未推送至共用仓库的提交上执行变基命令，就不会有事。 假如在那些已经被推送至共用仓库的提交上执行变基命令，并因此丢弃了一些别人的开发所基于的提交，那你就有大麻烦了，你的同事也会因此鄙视你。</p><p>如果你或你的同事在某些情形下决意要这么做，请一定要通知每个人执行 <code>git pull --rebase</code> 命令，这样尽管不能避免伤痛，但能有所缓解。</p><h2 id="变基-VS-合并">变基 VS 合并</h2><p>至此，你已在实战中学习了变基和合并的用法，你一定会想问，到底哪种方式更好。 在回答这个问题之前，让我们退后一步，想讨论一下<strong>提交历史到底意味着什么</strong>。</p><p>有一种观点认为，仓库的提交历史即是 <strong>记录实际发生过什么</strong>。 它是针对历史的文档，本身就有价值，不能乱改。 从这个角度看来，改变提交历史是一种亵渎，你使用_谎言_掩盖了实际发生过的事情。 如果由合并产生的提交历史是一团糟怎么办？ 既然事实就是如此，那么这些痕迹就应该被保留下来，让后人能够查阅。</p><p>另一种观点则正好相反，他们认为提交历史是 <strong>项目过程中发生的事</strong>。 没人会出版一本书的第一版草稿，软件维护手册也是需要反复修订才能方便使用。 持这一观点的人会使用 <strong>rebase</strong> 及 <strong>filter-branch</strong> 等工具来编写故事，怎么方便后来的读者就怎么写。</p><p>现在，让我们回到之前的问题上来，到底合并还是变基好？希望你能明白，这并没有一个简单的答案。 Git 是一个非常强大的工具，它允许你对提交历史做许多事情，但每个团队、每个项目对此的需求并不相同。 既然你已经分别学习了两者的用法，相信你能够根据实际情况作出明智的选择。</p><p>总的原则是，只对尚未推送或分享给别人的本地修改执行变基操作清理历史，从不对已推送至别处的提交执行变基操作，这样，你才能享受到两种方式带来的便利。</p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> rebase </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>技术白话解读之JWT</title>
      <link href="/2024/03/22/%E6%8A%80%E6%9C%AF%E7%99%BD%E8%AF%9D%E8%A7%A3%E8%AF%BB%E4%B9%8BJWT/"/>
      <url>/2024/03/22/%E6%8A%80%E6%9C%AF%E7%99%BD%E8%AF%9D%E8%A7%A3%E8%AF%BB%E4%B9%8BJWT/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 技术白话解读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES </tag>
            
            <tag> 技术白话解读 </tag>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM进阶</title>
      <link href="/2024/03/22/JVM%E8%BF%9B%E9%98%B6/"/>
      <url>/2024/03/22/JVM%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM基础</title>
      <link href="/2024/03/22/JVM%E5%9F%BA%E7%A1%80/"/>
      <url>/2024/03/22/JVM%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES基础</title>
      <link href="/2024/03/22/ES%E5%9F%BA%E7%A1%80/"/>
      <url>/2024/03/22/ES%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> ES </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES进阶</title>
      <link href="/2024/03/22/ES%E8%BF%9B%E9%98%B6/"/>
      <url>/2024/03/22/ES%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> ES </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue3进阶</title>
      <link href="/2024/03/22/vue3%E8%BF%9B%E9%98%B6/"/>
      <url>/2024/03/22/vue3%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> vue3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue3基础</title>
      <link href="/2024/03/22/vue3%E5%9F%BA%E7%A1%80/"/>
      <url>/2024/03/22/vue3%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> vue3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker进阶</title>
      <link href="/2024/03/22/docker%E8%BF%9B%E9%98%B6/"/>
      <url>/2024/03/22/docker%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker基础</title>
      <link href="/2024/03/22/docker%E5%9F%BA%E7%A1%80/"/>
      <url>/2024/03/22/docker%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript进阶</title>
      <link href="/2024/03/22/TypeScript%E8%BF%9B%E9%98%B6/"/>
      <url>/2024/03/22/TypeScript%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> TypeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript基础</title>
      <link href="/2024/03/22/TypeScript%E5%9F%BA%E7%A1%80/"/>
      <url>/2024/03/22/TypeScript%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> TypeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git进阶</title>
      <link href="/2024/03/21/git%E8%BF%9B%E9%98%B6/"/>
      <url>/2024/03/21/git%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git分支管理</title>
      <link href="/2024/03/21/git%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/"/>
      <url>/2024/03/21/git%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="分支简介">分支简介</h2><p>Git 保存的不是文件的变化或者差异，而是一系列<strong>不同时刻</strong>的<strong>文件快照</strong>。在进行提交操作时，Git 会保存一个提交对象（<strong>commit object</strong>）。该提交对象包含如下的内容：</p><ul class="lvl-0"><li class="lvl-2"><p>一个指向暂存<strong>内容快照</strong>的<strong>指针</strong></p></li><li class="lvl-2"><p>作者的姓名和邮箱</p></li><li class="lvl-2"><p>提交时输入的信息以及指向它的<strong>父对象的指针</strong></p><blockquote><p>首次提交产生的提交对象没有父对象，普通提交操作产生的提交对象有一个父对象，而由多个分支合并产生的提交对象有多个父对象。</p></blockquote></li></ul><p>当使用 <code>git commit</code> 进行提交操作时，Git 会先计算<strong>每一个</strong>子目录的<strong>校验和（SHA-1 哈希算法）</strong>，然后在 Git 仓库中将这些校验和保存为<strong>树对象</strong>。 随后，Git 便会创建<strong>一个提交对象</strong>，它除了包含上面提到的那些信息外，还包含指向这个<strong>树对象</strong>（项目根目录）的指针。如此一来，Git 就可以在需要的时候重现此次保存的快照。</p><p><strong>举例</strong>：</p><p>假设现在有一个工作目录，里面包含了三个将要被暂存和提交的文件。 暂存操作会为每一个文件计算校验和（SHA-1 哈希算法），然后会把当前版本的文件快照保存到 Git 仓库中（Git 使用 blob 对象来保存它们），最终将校验和加入到暂存区域等待提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git add README test.rb LICENSE</span><br><span class="line">$ git commit -m <span class="string">&#x27;The initial commit of my project&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="image-20240322162237470.png" alt="image-20240322162237470"></p><p>现在，Git 仓库中有<strong>五个</strong>对象：</p><ul class="lvl-0"><li class="lvl-2"><p>三个 <strong>blob</strong> 对象（保存着文件快照）,每个文件对应一个blob对象</p></li><li class="lvl-2"><p>一个树对象（记录着<strong>目录结构</strong>和 <strong>blob</strong> 对象索引）</p></li><li class="lvl-2"><p>一个提交对象（包含着指向前述树对象的指针和所有提交信息）</p></li></ul><p>做些<strong>修改后再次提交</strong>，那么这次产生的<strong>提交对象</strong>会包含一个<strong>指向上次提交对象</strong>（父对象）的指针。</p><p><img src="image-20240322162833807.png" alt="image-20240322162833807"></p><blockquote><p>注意：首次提交的产生的commit object中的<code>parent</code>为空</p></blockquote><p>Git 的<strong>分支</strong>，其实本质上仅仅是指向<strong>提交对象（commit object）<strong>的</strong>可变指针</strong>。 Git 的默认分支名字是 <code>master</code>。 在多次提交操作之后，你其实已经有一个指向最后那个<strong>提交对象</strong>的 <code>master</code> 分支。 它会在每次的提交操作中自动向前移动。</p><blockquote><p>Git 的 “master” 分支<strong>并不是一个特殊分支</strong>。 它就跟其它分支完全<strong>没有区别</strong>。 之所以几乎每一个仓库都有 master 分支，是因为 <code>git init</code> 命令默认创建它，并且大多数人都懒得去改动它。</p></blockquote><p>下图展示了分支及提交历史的关系：</p><p><img src="image-20240322163634261.png" alt="image-20240322163634261"></p><h2 id="分支创建">分支创建</h2><p>Git 是怎么创建新分支的呢？ 很简单，它只是为你创建了一个<strong>可以移动的新的指针</strong>。 比如，创建一个 testing 分支， 你需要使用 <code>git branch</code> 命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch testing</span><br></pre></td></tr></table></figure><p>这会在<strong>当前所在的提交对象</strong>上创建一个指针。</p><p><img src="image-20240323205914983.png" alt="image-20240323205914983"></p><p>那么，Git 又是<strong>怎么知道当前在哪一个分支上呢</strong>？</p><p>也很简单，它有一个名为 <code>HEAD</code> 的<strong>特殊指针</strong>。 请注意它和许多其它版本控制系统（如 Subversion 或 CVS）里的 <code>HEAD</code> 概念<strong>完全不同</strong>。 在 Git 中，它是一个指针，指向当前所在的本地分支</p><blockquote><p>（译注：将 <code>HEAD</code> 想象为<strong>当前分支的别名</strong>）。</p></blockquote><p>在本例中，你<strong>仍然在</strong> <code>master</code> 分支上。 因为 <code>git branch</code> 命令仅仅创建一个新分支，并<strong>不会自动切换到新分支</strong>中去。</p><p><img src="image-20240324132721322.png" alt="image-20240324132721322"></p><p>你可以简单地使用 <code>git log</code> 命令查看<strong>各个分支当前所指的对象</strong>。 提供这一功能的参数是 <code>--decorate</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --oneline --decorate</span><br><span class="line">f30ab (HEAD -&gt; master, testing) add feature <span class="comment">#32 - ability to add new</span></span><br><span class="line">34ac2 fixed bug <span class="comment">#1328 - stack overflow under certain conditions</span></span><br><span class="line">98ca9 initial commit of my project</span><br></pre></td></tr></table></figure><p>正如你所见，当前 <code>master</code> 和 <code>testing</code>分支均指向校验和以 <code>f30ab</code> 开头的提交对象。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f30ab (HEAD -&gt; master, testing) add feature</span><br></pre></td></tr></table></figure><blockquote><p>注意：新版本的git中不用添加<code>--decorate</code>也可以显示<code>HEAD</code>指针</p></blockquote><h2 id="分支切换">分支切换</h2><p>要切换到一个已存在的分支，你需要使用 <code>git checkout</code> 命令。 我们现在切换到新创建的 <code>testing</code> 分支去：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout testing</span><br></pre></td></tr></table></figure><p>这样 <code>HEAD</code> 就指向 <code>testing</code> 分支了。</p><p><img src="image-20240324133312362.png" alt="image-20240324133312362"></p><p>此时通过<code>git log</code>命令，可以发现<code>HEAD</code>指针已经指向<code>testing</code>分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --oneline</span><br><span class="line">f30ab (HEAD -&gt; testing, master) add feature <span class="comment">#32 - ability to add new</span></span><br></pre></td></tr></table></figure><p>那么，这样的实现方式会给我们带来什么好处呢？ 现在不妨再提交一次：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当前已经处于testing分支</span></span><br><span class="line">$ vim test.rb</span><br><span class="line">$ git commit -a -m <span class="string">&#x27;made a change&#x27;</span></span><br></pre></td></tr></table></figure><p>此时通过<code>git log</code>命令，发现<code>testing</code>分支向前移动了，但是 <code>master</code> 分支却没有：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --oneline</span><br><span class="line">87ab2 (HEAD -&gt; testing) made a change</span><br><span class="line">f30ab (master) add feature <span class="comment">#32 - ability to add new</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><img src="image-20240324134345432.png" alt="image-20240324134345432"></p><p>现在我们切换回<code>master</code>分支看看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">$ git <span class="built_in">log</span> --oneline</span><br><span class="line">f30ab (HEAD -&gt; master) add feature</span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>可见<code>master</code>分支上的log中不不能看到<code>testing</code>分支的相关提交，此时各个提交的关系图如下：</p><p><img src="image-20240324164918642.png" alt="image-20240324164918642"></p><p><code> git checkout master</code>命令做了两件事情：</p><ul class="lvl-0"><li class="lvl-2"><p>一是使 <code>HEAD</code> 指回 <code>master</code> 分支</p></li><li class="lvl-2"><p>二是将<strong>工作目录</strong>恢复成 <code>master</code> 分支所指向的<strong>快照内容</strong></p></li></ul><p>也就是说，你现在做修改的话，项目将始于一个<strong>较旧</strong>的版本。 本质上来讲，这就是忽略 <code>testing</code> 分支所做的修改，以便于向<strong>另一个方向</strong>进行开发。</p><blockquote><p>注意：</p><p>分支切换会<strong>改变</strong>你<strong>工作目录</strong>中的文件</p><p>在切换分支时，一定要注意你工作目录里的文件会被改变。 如果是切换到一个较旧的分支，你的工作目录会恢复到该分支最后一次提交时的样子。 如果 Git <strong>不能干净利落地完成这个任务，它将禁止切换分支</strong>。</p></blockquote><p>此时，我们不妨再稍微做些修改并提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ vim test.rb</span><br><span class="line">$ git commit -a -m <span class="string">&#x27;made other changes&#x27;</span></span><br></pre></td></tr></table></figure><p>现在，这个项目的提交历史已经产生了分叉（参见 <a href="https://www.progit.cn/#divergent_history">项目分叉历史</a>）。 因为刚才你创建了一个新分支，并切换过去进行了一些工作，随后又切换回 <code>master</code> 分支进行了另外一些工作。 上述两次改动针对的是不同分支：你可以在不同分支间不断地来回切换和工作，并在时机成熟时将它们合并起来。 而所有这些工作，你需要的命令只有 <code>branch</code>、<code>checkout</code> 和 <code>commit</code>。</p><p><img src="image-20240324165619046.png" alt="image-20240324165619046"></p><p>你可以简单地使用 <code>git log</code> 命令查看分叉历史。 运行 <code>git log --oneline --decorate --graph --all</code> ，它会输出你的提交历史、各个分支的指向以及项目的分支分叉情况:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --oneline --decorate --graph --all</span><br><span class="line">* c2b9e (HEAD -&gt; master) made other changes</span><br><span class="line">| * 87ab2 (testing) made a change</span><br><span class="line">|/</span><br><span class="line">* f30ab add feature <span class="comment">#32 - ability to add new formats to the</span></span><br><span class="line">* 34ac2 fixed bug <span class="comment">#1328 - stack overflow under certain conditions</span></span><br><span class="line">* 98ca9 initial commit of my project</span><br></pre></td></tr></table></figure><p>此时的<code>HEAD</code>指针指向<code>master</code>分支。</p><p>由于 Git 的分支实质上仅是包含所指对象校验和（长度为 40 的 SHA-1 值字符串）的文件，所以它的创建和销毁都异常高效。 创建一个新分支就相当于往一个文件中写入 41 个字节（40 个字符和 1 个换行符），如此的简单能不快吗？</p><h2 id="分支的新建与合并">分支的新建与合并</h2><h3 id="场景描述">场景描述</h3><p>让我们来看一个简单的分支新建与分支合并的例子，实际工作中你可能会用到类似的工作流。 你将经历如下步骤：</p><ol><li class="lvl-3"><p>开发某个网站。</p></li><li class="lvl-3"><p>为实现某个新的需求，创建一个分支。</p></li><li class="lvl-3"><p>在这个分支上开展工作。</p></li></ol><p>正在此时，你突然接到一个电话说有个很严重的问题需要紧急修补。 你将按照如下方式来处理：</p><ol><li class="lvl-3"><p>切换到你的<strong>线上分支</strong>（production branch）。</p></li><li class="lvl-3"><p>为这个紧急任务新建一个分支，并在其中修复它。</p></li><li class="lvl-3"><p>在测试通过之后，切换回线上分支，然后合并这个修补分支，最后将改动推送到线上分支。</p></li><li class="lvl-3"><p>切换回你最初工作的分支上，继续工作。</p></li></ol><h3 id="新建分支开发正常需求">新建分支开发正常需求</h3><p>首先，我们假设你正在你的项目上工作，并且已经有一些提交。</p><p><img src="image-20240325122812363.png" alt="image-20240325122812363"></p><p>比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --oneline</span><br><span class="line">7ed5243 (HEAD -&gt; master) 实现功能XX</span><br><span class="line">cf11a97 提交.gitignore</span><br><span class="line">9292896 初次提交</span><br></pre></td></tr></table></figure><p>现在，你已经决定要解决你的公司使用的问题追踪系统中的 #53 问题。 想要新建一个分支并同时切换到那个分支上，你可以运行一个带有 <code>-b</code> 参数的 <code>git checkout</code> 命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b <span class="string">&#x27;iss53&#x27;</span></span><br><span class="line">Switched to a new branch <span class="string">&#x27;iss53&#x27;</span></span><br></pre></td></tr></table></figure><p>这条命令相当于如下2条命令的缩写：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch iss53 <span class="comment"># 创建分支</span></span><br><span class="line">$ git checkout iss53 <span class="comment"># 切换分支</span></span><br></pre></td></tr></table></figure><p>此时 <code>git log --oneline</code>的输出如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --oneline</span><br><span class="line">7ed5243 (HEAD -&gt; iss53, master) 实现功能XX</span><br><span class="line">cf11a97 提交.gitignore</span><br><span class="line">9292896 初次提交</span><br></pre></td></tr></table></figure><p><img src="image-20240325123414402.png" alt="image-20240325123414402"></p><p>你继续在 <code>#53</code> 问题上工作，并且做了一些提交。 在此过程中，<code>iss53</code> 分支在不断的向前推进，因为你已经检出到该分支（也就是说，你的 <code>HEAD</code> 指针指向了 <code>iss53</code> 分支）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -am <span class="string">&quot;实现功能YY [issue 53]&quot;</span></span><br><span class="line">[iss53 6b79000] 实现功能YY [issue 53]</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><p>此时<code>git log</code>输出如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --oneline</span><br><span class="line">6b79000 (HEAD -&gt; iss53) 实现功能YY [issue 53]</span><br><span class="line">7ed5243 (master) 实现功能XX</span><br><span class="line">cf11a97 提交.gitignore</span><br><span class="line">9292896 初次提交</span><br></pre></td></tr></table></figure><p><img src="image-20240325124954793.png" alt="image-20240325124954793"></p><h3 id="创建hotfix分支处理紧急问题">创建hotfix分支处理紧急问题</h3><p>现在你接到那个电话，有个紧急问题等待你来解决。 有了 Git 的帮助，你不必把这个紧急问题和 <code>iss53</code> 的修改混在一起，你也不需要花大力气来还原关于 <code>#53</code>问题的修改，然后再添加关于这个紧急问题的修改，最后将这个修改提交到线上分支。 你所要做的仅仅是切换回 <code>master</code> 分支。</p><p>但是，在你这么做之前，要留意你的<strong>工作目录和暂存区里那些还没有被提交的修改</strong>，它可能会和你即将检出的分支产生冲突从而阻止 Git 切换到该分支。 最好的方法是，在你<strong>切换分支之前，保持好一个干净的状态</strong>。 有一些方法可以绕过这个问题（即，保存进度（<strong>stashing</strong>） 和 修补提交（<strong>commit amending</strong>）），我们会在 <a href="https://www.progit.cn/#_git_stashing">储藏与清理</a> 中看到关于这两个命令的介绍。 现在，我们<strong>假设你已经把你的修改全部提交了</strong>，这时你可以切换回 <code>master</code> 分支了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">&#x27;master&#x27;</span></span><br></pre></td></tr></table></figure><p>此时，你的工作目录和你在开始 <code>#53</code> 问题之前一模一样，现在你<strong>可以专心修复紧急问题</strong>了。</p><blockquote><p>请牢记：当你切换分支的时候，Git 会<strong>重置</strong>你的<strong>工作目录</strong>，使其看起来像回到了你在那个分支上最后一次提交的样子。 Git 会自动添加、删除、修改文件以确保此时你的工作目录和这个分支最后一次提交时的样子<strong>一模一样</strong>。</p></blockquote><p>接下来，你要修复这个紧急问题。 让我们建立一个针对该紧急问题的分支（<code>hotfix</code> branch），在该分支上工作<strong>直到问题解决</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ vim A.java <span class="comment"># 修复问题</span></span><br><span class="line"></span><br><span class="line">$ git commit -am <span class="string">&#x27;修复紧急问题[hotfix]&#x27;</span></span><br><span class="line">[hotfix bf3f569] 修复紧急问题[hotfix]</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><p>此时查看<code>git log</code>日志如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --oneline --graph --all</span><br><span class="line">* bf3f569 (HEAD -&gt; hotfix) 修复紧急问题[hotfix]</span><br><span class="line">| * 6b79000 (iss53) 实现功能YY [issue 53]</span><br><span class="line">|/</span><br><span class="line">* 7ed5243 (master) 实现功能XX</span><br><span class="line">* cf11a97 提交.gitignore</span><br><span class="line">* 9292896 初次提交</span><br></pre></td></tr></table></figure><p><img src="image-20240325130324493.png" alt="image-20240325130324493"></p><h3 id="将hotfix分支合并回master分支">将hotfix分支合并回master分支</h3><p>你可以运行你的测试，确保你的修改是正确的，然后将<code>hotfix</code>分支上的改动合并回你的 <code>master</code> 分支来部署到线上。 你可以使用 <code>git merge</code> 命令来达到上述目的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master  <span class="comment"># 切换回master分支</span></span><br><span class="line">Switched to branch <span class="string">&#x27;master&#x27;</span></span><br><span class="line"></span><br><span class="line">$ git merge hotfix   <span class="comment"># 合并分支</span></span><br><span class="line">Updating 7ed5243..bf3f569</span><br><span class="line">Fast-forward</span><br><span class="line"> A.java | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><p>在合并的时候，你应该注意到了&quot;快进（<strong>fast-forward</strong>）&quot;这个词。 由于当前 <code>master</code> 分支所指向的提交是你当前提交（有关 <code>hotfix</code> 的提交）的直接上游，所以 Git 只是<strong>简单的将指针向前移动</strong>。</p><blockquote><p>换句话说，当你试图合并两个分支时，如果<strong>顺着一个分支走下去能够到达另一个分</strong>支，那么 Git 在合并两者的时候，只会简单的将指针向前推进（<strong>指针右移</strong>），因为这种情况下的合并操作没有需要解决的分歧——这就叫做 “快进（<strong>fast-forward</strong>）”。</p></blockquote><blockquote><p>fast-forward模式会直接移动指针，不会创建新的提交记录。</p></blockquote><p>此时<code>git log</code>的输出如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --oneline --all --graph</span><br><span class="line">* bf3f569 (HEAD -&gt; master, hotfix) 修复紧急问题[hotfix]</span><br><span class="line">| * 6b79000 (iss53) 实现功能YY [issue 53]</span><br><span class="line">|/</span><br><span class="line">* 7ed5243 实现功能XX</span><br><span class="line">* cf11a97 提交.gitignore</span><br><span class="line">* 9292896 初次提交</span><br></pre></td></tr></table></figure><p>现在，最新的修改已经在 <code>master</code> 分支所指向的提交快照中，你可以着手发布该修复了。</p><p><img src="image-20240325131420197.png" alt="image-20240325131420197"></p><h3 id="删除hotfix分支-恢复原先正常工作">删除hotfix分支,恢复原先正常工作</h3><p>关于这个紧急问题的解决方案发布之后，你准备回到被打断之前时的工作中。 然而，你应该先删除 <code>hotfix</code> 分支，因为你已经不再需要它了 —— <code>master</code> 分支已经指向了同一个位置。 你可以使用带 <code>-d</code> 选项的 <code>git branch</code> 命令来删除分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MINGW64 /d/coding/git-playground (master)</span><br><span class="line">$ git branch -d hotfix</span><br><span class="line">Deleted branch hotfix (was bf3f569).</span><br><span class="line"></span><br><span class="line">$ git <span class="built_in">log</span> --oneline --all --graph</span><br><span class="line">* bf3f569 (HEAD -&gt; master) 修复紧急问题[hotfix]</span><br><span class="line">| * 6b79000 (iss53) 实现功能YY [issue 53]</span><br><span class="line">|/</span><br><span class="line">* 7ed5243 实现功能XX</span><br><span class="line">* cf11a97 提交.gitignore</span><br><span class="line">* 9292896 初次提交</span><br></pre></td></tr></table></figure><p>现在你可以切换回你正在工作的分支<strong>继续你的工作</strong>，也就是针对 <code>#53</code> 问题的那个分支（<code>iss53</code> 分支）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ vim B.java</span><br><span class="line"></span><br><span class="line">$ git commit -am <span class="string">&#x27;修改B.java [issue 53]&#x27;</span></span><br><span class="line">[iss53 6d6d7e6] 修改B.java [issue 53]</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><p>此时的<code>git log</code>输出如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --oneline --all --graph</span><br><span class="line">* 6d6d7e6 (HEAD -&gt; iss53) 修改B.java [issue 53] <span class="comment"># iss53分支往后推进</span></span><br><span class="line">* 6b79000 实现功能YY [issue 53] </span><br><span class="line">| * bf3f569 (master) 修复紧急问题[hotfix] <span class="comment"># master分支中已经合并了之前的hotfix</span></span><br><span class="line">|/</span><br><span class="line">* 7ed5243 实现功能XX</span><br><span class="line">* cf11a97 提交.gitignore</span><br><span class="line">* 9292896 初次提交</span><br></pre></td></tr></table></figure><p><img src="image-20240325132430471.png" alt="image-20240325132430471"></p><p>你在 <code>hotfix</code> 分支上所做的工作并没有包含到 <code>iss53</code> 分支中。</p><ul class="lvl-0"><li class="lvl-2"><p>如果你需要拉取 <code>hotfix</code> 所做的修改，你可以使用 <code>git merge master</code> 命令将 <code>master</code> 分支合并入 <code>iss53</code> 分支</p></li><li class="lvl-2"><p>或者你也可以等到 <code>iss53</code> 分支完成其使命，再将其合并回 <code>master</code> 分支</p></li></ul><h3 id="分支合并">分支合并</h3><p>假设你已经修正了 <code>#53</code> 问题，并且打算将你的工作合并入 <code>master</code> 分支。 为此，你需要合并 <code>iss53</code> 分支到 <code>master</code> 分支，这和之前你合并 <code>hotfix</code> 分支所做的工作差不多。 你只需要检出到你想合并入的分支，然后运行 <code>git merge</code> 命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">&#x27;master&#x27;</span></span><br><span class="line"></span><br><span class="line">$ git merge iss53</span><br></pre></td></tr></table></figure><p>此时会弹窗提示你输出一个提交信息：</p><p><img src="image-20240325133120168.png" alt="image-20240325133120168"></p><p>输入完成后：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git merge iss53</span><br><span class="line">Merge made by the <span class="string">&#x27;ort&#x27;</span> strategy.</span><br><span class="line"> B.java | 2 ++</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此时再次查看<code>git log</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --oneline --all --graph</span><br><span class="line">*   a324538 (HEAD -&gt; master) Merge branch <span class="string">&#x27;iss53&#x27;</span> : iss53处理完成，需合并回master分支</span><br><span class="line">|\</span><br><span class="line">| * 6d6d7e6 (iss53) 修改B.java [issue 53]</span><br><span class="line">| * 6b79000 实现功能YY [issue 53]</span><br><span class="line">* | bf3f569 修复紧急问题[hotfix]</span><br><span class="line">|/</span><br><span class="line">* 7ed5243 实现功能XX</span><br><span class="line">* cf11a97 提交.gitignore</span><br><span class="line">* 9292896 初次提交</span><br></pre></td></tr></table></figure><p>这和你之前合并 <code>hotfix</code> 分支的时候看起来有一点不一样。 在这种情况下，你的开发历史从一个更早的地方开始分叉开来（<strong>diverged</strong>）。 因为，<code>master</code> 分支所在提交并不是 <code>iss53</code> 分支所在提交的直接祖先，Git 不得不做一些额外的工作。 出现这种情况的时候，Git 会使用两个分支的末端所指的快照（<code>C4</code> 和 <code>C5</code>）以及这两个分支的工作祖先（<code>C2</code>），做一个简单的<strong>三方合并</strong>。</p><p><strong>合并前</strong>的分支图如下：</p><p><img src="image-20240325133814455.png" alt="image-20240325133814455"></p><p>和之前将分支<strong>指针向前推进</strong>所不同的是，Git 将此次三方合并的结果做了一个新的快照并且自动创建一个新的提交指向它。 这个被称作一次<strong>合并提交</strong>，它的特别之处在于他有<strong>不止一个父提交</strong>。</p><p><strong>合并后</strong>的分支图如下：</p><p><img src="image-20240325135637615.png" alt="image-20240325135637615"></p><p><img src="image-20240325134716055.png" alt="image-20240325134716055"></p><p><img src="image-20240325135924375.png" alt="image-20240325135924375"></p><p>注意：</p><ul class="lvl-0"><li class="lvl-2"><p>看每条线上的<code>*</code>即可</p></li></ul><p><img src="image-20240325140319801.png" alt="image-20240325140319801"></p><p>和之前将分支指针向前推进所不同的是，Git 将此次三方合并的结果做了<strong>一个新的快照</strong>（即：<code>C6</code>）并且自动创建一个新的提交指向它。 这个被称作一次<strong>合并提交</strong>，它的特别之处在于他有<strong>不止一个父提交</strong>(<code>C6</code>有<code>C5</code>、<code>C4</code>两个父提交)。</p><p>要指出的是，Git 会<strong>自行决定选取哪一个提交作为最优的共同祖先，并以此作为合并的基础</strong>；这和更加古老的 CVS 系统或者 Subversion （1.5 版本之前）不同，在这些古老的版本管理系统中，用户需要自己选择最佳的合并基础。 Git 的这个优势使其在合并操作上比其他系统要简单很多。</p><p>既然你的修改已经合并进来了，你已经不再需要 <code>iss53</code> 分支了。 现在你可以在任务追踪系统中关闭此项任务，并删除这个分支。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d iss53</span><br></pre></td></tr></table></figure><h2 id="遇到冲突时的分支合并">遇到冲突时的分支合并</h2><p>有时候合并操作不会如此顺利。 如果你在<strong>两个不同的分支中</strong>，对同一个文件的同一个部分进行了不同的修改，Git 就没法干净的合并它们。 如果你对 <code>hotfix</code> 问题的修改和有关 <code>master</code> 的修改都涉及到同一个文件的同一处，在合并它们的时候就会产生<strong>合并冲突</strong>,比如我们的<code>master</code>分支如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/d/coding/git-playground (master)</span><br><span class="line">$ ll</span><br><span class="line">total 0</span><br><span class="line">-rw-r--r-- 1 86182 197609 0  3月 25 19:53 A.java</span><br><span class="line">-rw-r--r-- 1 86182 197609 0  3月 25 19:53 B.java</span><br><span class="line">-rw-r--r-- 1 86182 197609 0  3月 25 19:53 README.md</span><br><span class="line"></span><br><span class="line">/d/coding/git-playground (master)</span><br><span class="line">$ git <span class="built_in">log</span> --oneline</span><br><span class="line">519c74f (HEAD -&gt; master) 提交git ignore</span><br><span class="line">dcd138e first commit</span><br></pre></td></tr></table></figure><p>此时我们创建了一个<code>hotfix</code>分支，并在该分支上对<code>A.java</code>的第一行做了修改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> A.java</span><br><span class="line">// 在hotfix上的改动</span><br><span class="line"></span><br><span class="line">$ git commit -am <span class="string">&#x27;修复XX问题[hotfix]&#x27;</span></span><br><span class="line">[hotfix 068a534] 修复XX问题[hotfix]</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> </span><br><span class="line">MINGW64 /d/coding/git-playground (hotfix)</span><br><span class="line">$ git <span class="built_in">log</span> --oneline --all</span><br><span class="line">068a534 (HEAD -&gt; hotfix) 修复XX问题[hotfix]</span><br><span class="line">519c74f (master) 提交git ignore</span><br><span class="line">dcd138e first commit</span><br></pre></td></tr></table></figure><p>期间，<code>master</code>分支针对<code>A.java</code>的第一行做了也做了修改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MINGW64 /d/coding/git-playground (master)</span><br><span class="line">$ vim A.java</span><br><span class="line"></span><br><span class="line">MINGW64 /d/coding/git-playground (master)</span><br><span class="line">$ git commit -am <span class="string">&#x27;修改A.java文件[master]&#x27;</span></span><br><span class="line">[master 8507b7f] 修改A.java文件[master]</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> </span><br><span class="line">MINGW64 /d/coding/git-playground (master)</span><br><span class="line">$ <span class="built_in">cat</span> A.java</span><br><span class="line">// master上也修改了第一行</span><br></pre></td></tr></table></figure><p>此时的<code>git log</code>如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --oneline --all --graph</span><br><span class="line">* 8507b7f (HEAD -&gt; master) 修改A.java文件[master]</span><br><span class="line">| * 068a534 (hotfix) 修复XX问题[hotfix]</span><br><span class="line">|/</span><br><span class="line">* 519c74f 提交git ignore</span><br><span class="line">* dcd138e first commit</span><br></pre></td></tr></table></figure><p>此时我们尝试将<code>hotfix</code>分支的内容合并入<code>master</code>分支:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MINGW64 /d/coding/git-playground (master)</span><br><span class="line">$ git merge hotfix</span><br><span class="line">Auto-merging A.java</span><br><span class="line">CONFLICT (content): Merge conflict <span class="keyword">in</span> A.java</span><br><span class="line">Automatic merge failed; fix conflicts and <span class="keyword">then</span> commit the result.</span><br></pre></td></tr></table></figure><p>此时 Git <strong>做了合并</strong>，但是提示在<code>A.java</code>中存在冲突，因此自动合并失败<code>Automatic merge failed;</code>,此时我们需要根据提示：<code>fix conflicts and then commit the result.</code>先解决<code>A.java</code>中存在的冲突，你可以在<strong>合并冲突后</strong>的任意时刻使用 <code>git status</code> 命令来查看那些因包含合并冲突而处于未合并（<strong>unmerged</strong>）状态的文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> MINGW64 /d/coding/git-playground (master|MERGING)</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">You have unmerged paths.</span><br><span class="line">  (fix conflicts and run <span class="string">&quot;git commit&quot;</span>)</span><br><span class="line">  (use <span class="string">&quot;git merge --abort&quot;</span> to abort the merge)</span><br><span class="line"></span><br><span class="line">Unmerged paths:    <span class="comment"># 此处提示冲突的问题列表</span></span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to mark resolution) <span class="comment"># 通过git add可以将文件标记为已解决冲突</span></span><br><span class="line">        both modified:   A.java</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">&quot;git add&quot;</span> and/or <span class="string">&quot;git commit -a&quot;</span>)</span><br></pre></td></tr></table></figure><p>任何因包含合并冲突而有<strong>待解决的文件</strong>，都会以<strong>未合并状态标识</strong>出来:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MINGW64 /d/coding/git-playground (master|MERGING) <span class="comment"># 注意此处会提示merging</span></span><br><span class="line">git status -s</span><br><span class="line">UU A.java <span class="comment"># 两个红色的UU</span></span><br></pre></td></tr></table></figure><p><img src="image-20240325201334424.png" alt="image-20240325201334424"></p><p>此时的<code>git log</code>信息如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MINGW64 /d/coding/git-playground (master|MERGING)</span><br><span class="line">$ git <span class="built_in">log</span> --oneline --all --graph</span><br><span class="line">* 8507b7f (HEAD -&gt; master) 修改A.java文件[master]</span><br><span class="line">| * 068a534 (hotfix) 修复XX问题[hotfix]</span><br><span class="line">|/</span><br><span class="line">* 519c74f 提交git ignore</span><br><span class="line">* dcd138e first commit</span><br></pre></td></tr></table></figure><p>Git 会在有冲突的文件中加入标准的冲突解决标记，这样你可以打开这些包含冲突的文件然后手动解决冲突。 出现冲突的文件会包含一些特殊区段，比如此处的<code>A.java</code>，看起来像下面这个样子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MINGW64 /d/coding/git-playground (master|MERGING)</span><br><span class="line">$ <span class="built_in">cat</span> A.java</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; <span class="string">HEAD</span></span><br><span class="line"><span class="string">// master上也修改了第一行</span></span><br><span class="line"><span class="string">=======</span></span><br><span class="line"><span class="string">// 在hotfix上的改动</span></span><br><span class="line"><span class="string">&gt;&gt;&gt;&gt;&gt;&gt;&gt; hotfix</span></span><br></pre></td></tr></table></figure><p>这表示 <code>HEAD</code> 所指示的版本（此处<code>HEAD -&gt; master</code>,也就是你的 <code>master</code> 分支所在的位置，因为你在运行 <code>merge</code> 命令的时候已经检出到了这个分支）在这个区段的上半部分（<code>=======</code> 的上半部分），而 <code>hotfix</code> 分支所指示的版本在 <code>=======</code> 的下半部分。 为了解决冲突，你必须选择使用由 <code>=======</code> 分割的两部分中的一个，或者你也可以自行合并这些内容。 例如，你可以通过把这段内容换成下面的样子来解决冲突：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MINGW64 /d/coding/git-playground (master|MERGING)</span><br><span class="line">$ <span class="built_in">cat</span> A.java</span><br><span class="line">// master上也修改了第一行  + hotfix上的改动</span><br></pre></td></tr></table></figure><blockquote><p>解决冲突时需删除<code>=======</code>和<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</code>与<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt; hotfix</code>等内容。</p></blockquote><p>上述的冲突解决后， <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code> , <code>=======</code> , 和 <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code> 这些行被完全删除了。 在你解决了所有文件里的冲突之后，对每个文件使用 <code>git add</code> 命令来将其<strong>标记为冲突已解决</strong>。 一旦暂存这些原本有冲突的文件，Git 就会将它们标记为冲突已解决。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MINGW64 /d/coding/git-playground (master|MERGING)</span><br><span class="line">$ git add A.java <span class="comment"># 标记为已解决冲突</span></span><br><span class="line"></span><br><span class="line">MINGW64 /d/coding/git-playground (master|MERGING) <span class="comment"># 此时仓库的MERGING还在</span></span><br><span class="line">$ git status <span class="comment"># 查看仓库状态</span></span><br><span class="line">On branch master</span><br><span class="line">All conflicts fixed but you are still merging.</span><br><span class="line">  (use <span class="string">&quot;git commit&quot;</span> to conclude merge) <span class="comment"># 直接git commit就可以完成合并</span></span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">        modified:   A.java</span><br></pre></td></tr></table></figure><p>如果你对结果感到满意，并且确定之前有冲突的的文件都已经暂存了，这时你可以输入 <code>git commit</code> 来完成合并提交。 默认情况下提交信息看起来像下面这个样子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MINGW64 /d/coding/git-playground (master|MERGING) <span class="comment"># MERGING还在</span></span><br><span class="line">$ git commit</span><br><span class="line">[master 152d12e] Merge branch <span class="string">&#x27;hotfix&#x27;</span></span><br><span class="line"></span><br><span class="line">MINGW64 /d/coding/git-playground (master) <span class="comment"># MERGING没了</span></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><p>此时可以通过<code>git log</code>查看仓库的状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --oneline --all --graph</span><br><span class="line">*   152d12e (HEAD -&gt; master) Merge branch <span class="string">&#x27;hotfix&#x27;</span> <span class="comment"># 生成的合并提交</span></span><br><span class="line">|\</span><br><span class="line">| * 068a534 (hotfix) 修复XX问题[hotfix]</span><br><span class="line">* | 8507b7f 修改A.java文件[master] <span class="comment"># id为左侧那条线上的*号的，写不下才在右边</span></span><br><span class="line">|/</span><br><span class="line">* 519c74f 提交git ignore</span><br><span class="line">* dcd138e first commit</span><br></pre></td></tr></table></figure><p>此时如果通过<code>idea</code>中自带的<code>git</code>可视化工具查看，展示如下：</p><p><img src="image-20240325203727263.png" alt="image-20240325203727263"></p><p>可见：</p><p><img src="image-20240325203840607.png" alt="image-20240325203840607"></p><h2 id="分支管理">分支管理</h2><h3 id="查看有哪些分支">查看有哪些分支</h3><p>现在已经创建、合并、删除了一些分支，让我们看看一些常用的分支管理工具。</p><p><code>git branch</code> 命令不只是可以创建与删除分支。 如果<strong>不加任何参数运行</strong>它，会得到当前<strong>所有分支</strong>(即包含所有合并或者未合并到当前分支的分支)的一个列表：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">  hotfix</span><br><span class="line">* master</span><br></pre></td></tr></table></figure><p>注意 <code>master</code> 分支前的 <code>*</code> 字符：它代表现在检出的那一个分支（也就是说，当前 <code>HEAD</code> 指针所指向的分支）:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MINGW64 /d/coding/git-playground (master)</span><br><span class="line">$ git <span class="built_in">log</span> --oneline --all --graph</span><br><span class="line">*   152d12e (HEAD -&gt; master) Merge branch <span class="string">&#x27;hotfix&#x27;</span> <span class="comment">#HEAD指向master分支</span></span><br><span class="line">|\</span><br><span class="line">| * 068a534 (hotfix) 修复XX问题[hotfix]</span><br><span class="line">* | 8507b7f 修改A.java文件[master]</span><br><span class="line">|/</span><br><span class="line">* 519c74f 提交git ignore</span><br><span class="line">* dcd138e first commit</span><br></pre></td></tr></table></figure><p>这意味着如果在这时候提交，<code>master</code> 分支将会随着新的工作向前移动。 如果需要查看<strong>每一个分支的最后一次提交</strong>，可以运行 <code>git branch -v</code> 命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -v</span><br><span class="line">  hotfix 068a534 修复XX问题[hotfix] </span><br><span class="line">* master 152d12e Merge branch <span class="string">&#x27;hotfix&#x27;</span></span><br></pre></td></tr></table></figure><blockquote><p>本例中hotfix已经merged到master上</p></blockquote><h3 id="查看哪些分支已经合并或者尚未合并到本分支">查看哪些分支已经合并或者尚未合并到本分支</h3><p>为了更好的演示本例，我们需要额外创建一个分支<code>testing</code>，并在该分支上做一些提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">MINGW64 /d/coding/git-playground (master)</span><br><span class="line">$ git branch testing</span><br><span class="line"></span><br><span class="line">MINGW64 /d/coding/git-playground (master)</span><br><span class="line">$ git checkout testing</span><br><span class="line">Switched to branch <span class="string">&#x27;testing&#x27;</span></span><br><span class="line"></span><br><span class="line">MINGW64 /d/coding/git-playground (testing)</span><br><span class="line">$ <span class="built_in">touch</span> C.java</span><br><span class="line"></span><br><span class="line"> MINGW64 /d/coding/git-playground (testing)</span><br><span class="line">$ git commit -m <span class="string">&#x27;提交C.java[testing]&#x27;</span></span><br><span class="line">[testing 578f31c] 提交C.java[testing]</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 C.java</span><br></pre></td></tr></table></figure><p>此时我们切换回<code>master</code>分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">&#x27;master&#x27;</span></span><br></pre></td></tr></table></figure><p><code>--merged</code> 与 <code>--no-merged</code> 这两个有用的选项可以过滤这个列表中<strong>已经合并</strong>或<strong>尚未合并</strong>到<strong>当前分支</strong>的分支。</p><ul class="lvl-0"><li class="lvl-2"><p>如果要查看哪些分支已经合并到当前分支，可以运行 <code>git branch --merged</code>:</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MINGW64 /d/coding/git-playground (master)</span><br><span class="line">$ git branch --merged</span><br><span class="line">  hotfix <span class="comment"># hotfix之前已经合并到master</span></span><br><span class="line">* master</span><br></pre></td></tr></table></figure><blockquote><p>此处的当前分支为master</p></blockquote><p>因为之前已经合并了 <code>hotfix</code> 分支，所以现在看到它在列表中。 在这个列表中分支名字前没有 <code>*</code> 号的分支通常可以使用 <code>git branch -d</code> 删除掉；你已经将它们的工作整合到了另一个分支，所以并<strong>不会失去任何东西</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MINGW64 /d/coding/git-playground (master)</span><br><span class="line">$ git branch -d hotfix</span><br><span class="line">Deleted branch hotfix (was 068a534).</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>如果要查看哪些分支尚未合并到当前分支，可以运行 <code>git branch --no-merged</code>:</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MINGW64 /d/coding/git-playground (master)</span><br><span class="line">$ git branch --no-merged</span><br><span class="line">  testing <span class="comment"># testing分支尚未合并到当前分支</span></span><br></pre></td></tr></table></figure><blockquote><p>此处的当前分支为master</p></blockquote><p>因为它包含了还未合并的工作，尝试使用 <code>git branch -d</code> 命令删除它时会失败：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d testing</span><br><span class="line">error: the branch <span class="string">&#x27;testing&#x27;</span> is not fully merged.</span><br><span class="line">If you are sure you want to delete it, run <span class="string">&#x27;git branch -D testing&#x27;</span></span><br></pre></td></tr></table></figure><p>如果真的想要删除分支并丢掉那些工作，如同帮助信息里所指出的，可以使用 <code>-D</code> 选项强制删除它。</p><h2 id="远程分支">远程分支</h2><h3 id="基本使用">基本使用</h3><blockquote><p>远程引用是<strong>对远程仓库的引用</strong>（指针），包括<strong>分支</strong>、<strong>标签</strong>等等。</p></blockquote><p>你可以通过 <code>git ls-remote (remote)</code> 来显式地获得<strong>远程引用</strong>的完整列表:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MINGW64 /d/coding/git-playground (master)</span><br><span class="line">$ git ls-remote</span><br><span class="line">From git@gitee.com:terrylikescoding/git-playground.git</span><br><span class="line">ed9cf4a352ba55396c603eb9c0431653305dab5e        HEAD</span><br><span class="line">ed9cf4a352ba55396c603eb9c0431653305dab5e        refs/heads/master</span><br><span class="line"></span><br><span class="line">$ git ls-remote origin <span class="comment"># remote可选</span></span><br><span class="line">ed9cf4a352ba55396c603eb9c0431653305dab5e        HEAD</span><br><span class="line">ed9cf4a352ba55396c603eb9c0431653305dab5e        refs/heads/master</span><br></pre></td></tr></table></figure><p>或者通过 <code>git remote show (remote)</code> 获得远程分支的更多信息:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git remote show origin</span><br><span class="line">* remote origin</span><br><span class="line">  Fetch URL: git@gitee.com:terrylikescoding/git-playground.git</span><br><span class="line">  Push  URL: git@gitee.com:terrylikescoding/git-playground.git</span><br><span class="line">  HEAD branch: master</span><br><span class="line">  Remote branch:</span><br><span class="line">    master tracked</span><br><span class="line">  Local branch configured <span class="keyword">for</span> <span class="string">&#x27;git pull&#x27;</span>:</span><br><span class="line">    master merges with remote master</span><br><span class="line">  Local ref configured <span class="keyword">for</span> <span class="string">&#x27;git push&#x27;</span>:</span><br><span class="line">    master pushes to master (up to <span class="built_in">date</span>)</span><br></pre></td></tr></table></figure><p>然而，一个更常见的做法是利用<strong>远程跟踪分支</strong>。</p><blockquote><p>远程跟踪分支是远程分支状态的<strong>引用</strong>。 它们是你<strong>不能移动的本地引用</strong>，当你做任何网络通信操作时，它们<strong>会自动移动</strong>。 远程跟踪分支像是你上次连接到远程仓库时，那些分支所处状态的书签。</p></blockquote><p>远程分支以 <code>(remote)/(branch)</code> 形式命名。 例如，如果你想要看你最后一次与远程仓库 <code>origin</code> 通信时 <code>master</code> 分支的状态，你可以查看 <code>origin/master</code> 分支。 你与同事合作解决一个问题并且他们推送了一个 <code>iss53</code> 分支，你可能有自己的本地 <code>iss53</code> 分支；但是在服务器上的分支会指向 <code>origin/iss53</code> 的提交。</p><p>让我们来看一个例子。 假设你的网络里有一个在 <code>git.ourcompany.com</code> 的 Git 服务器。 如果你从这里克隆，Git 的 <code>clone</code> 命令会为你自动将其命名为 <code>origin</code>，拉取它的所有数据，创建一个指向它的 <code>master</code> 分支的指针，并且在本地将其命名为 <code>origin/master</code>。 Git 也会给你一个与 origin 的 <code>master</code> 分支在指向同一个地方的本地 <code>master</code> 分支，这样你就有工作的基础。</p><p><img src="image-20240326100506430.png" alt="image-20240326100506430"></p><blockquote><p>“origin” 并无特殊含义</p><p>远程仓库名字 “<strong>origin</strong>” 与分支名字 “<strong>master</strong>” 一样，在 Git 中并<strong>没有任何特别的含义</strong>一样。 同时 “master” 是当你运行 <code>git init</code> 时默认的起始分支名字，原因仅仅是它的广泛使用，“<strong>origin</strong>” 是当你运行 <code>git clone</code> 时默认的远程仓库名字。 如果你运行 <code>git clone -o booyah</code>，那么你默认的远程分支名字将会是 <code>booyah/master</code>。</p></blockquote><p>如果你在本地的 <code>master</code> 分支做了一些工作，然而在同一时间，其他人推送提交到 <code>git.ourcompany.com</code> 并更新了它的 <code>master</code> 分支，那么你的提交历史将向不同的方向前进。</p><p><img src="image-20240326101153137.png" alt="image-20240326101153137"></p><p>也许，只要你不与 <code>origin</code> 服务器连接，你的 <code>origin/master</code> 指针就不会移动。</p><p>演示说明：</p><p>本地<code>git clone</code>之后：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MINGW64 /d/tmp</span><br><span class="line">$ git <span class="built_in">clone</span> git@gitee.com:terrylikescoding/git-playground.git</span><br><span class="line">Cloning into <span class="string">&#x27;git-playground&#x27;</span>...</span><br><span class="line">remote: Enumerating objects: 18, <span class="keyword">done</span>.</span><br><span class="line">remote: Counting objects: 100% (18/18), <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (13/13), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 18 (delta 4), reused 0 (delta 0), pack-reused 0</span><br><span class="line">Receiving objects: 100% (18/18), <span class="keyword">done</span>.</span><br><span class="line">Resolving deltas: 100% (4/4), <span class="keyword">done</span>.</span><br></pre></td></tr></table></figure><p>在本地分支做了一些改动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> MINGW64 /d/tmp/git-playground (master)</span><br><span class="line">$ git <span class="built_in">log</span> --oneline --all --graph</span><br><span class="line">* 09af026 (HEAD -&gt; master) 添加D.java</span><br><span class="line">* 6bfb728 提交C.java</span><br><span class="line">* ed9cf4a (origin/master, origin/HEAD) 提交.gitignore</span><br><span class="line">*   152d12e Merge branch <span class="string">&#x27;hotfix&#x27;</span></span><br><span class="line">|\</span><br><span class="line">| * 068a534 修复XX问题[hotfix]</span><br><span class="line">* | 8507b7f 修改A.java文件[master]</span><br><span class="line">|/</span><br><span class="line">* 519c74f 提交git ignore</span><br><span class="line">* dcd138e first commit</span><br></pre></td></tr></table></figure><p><img src="image-20240326103002585.png" alt="image-20240326103002585"></p><p>期间其他人往<code>orgin/master</code>上提交了一些内容：</p><p><img src="image-20240326101834006.png" alt="image-20240326101834006"></p><p>本例中<code>git clone</code>时的版本为<code>ed9cf4a3</code>,此时通过<code>git status</code>命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MINGW64 /d/tmp/git-playground (master)</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is ahead of <span class="string">&#x27;origin/master&#x27;</span> by 2 commits.</span><br><span class="line">  (use <span class="string">&quot;git push&quot;</span> to publish your <span class="built_in">local</span> commits)</span><br></pre></td></tr></table></figure><p>可以发现git提示<code>Your branch is ahead of 'origin/master' by 2 commits.</code>,此时的本地master分支相比与刚刚clone时，往后推进了2个版本，而<code>origin/master</code>引用仍然指向版本<code>ed9cf4a3</code>。</p><p>如果需要同步你的工作，运行 <code>git fetch origin</code> 命令。 这个命令查找 “<strong>origin</strong>” 是哪一个服务器（在本例中，它是 <code>git.ourcompany.com</code>），从中<strong>抓取本地没有的数据，并且更新本地数据库</strong>，移动 <code>origin/master</code> 指针指向新的、更新后的位置。</p><p>比如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MINGW64 /d/tmp/git-playground (master)</span><br><span class="line">$ git fetch origin</span><br><span class="line">remote: Enumerating objects: 9, <span class="keyword">done</span>.</span><br><span class="line">remote: Counting objects: 100% (9/9), <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (5/5), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 6 (delta 1), reused 0 (delta 0), pack-reused 0</span><br><span class="line">Unpacking objects: 100% (6/6), 694 bytes | 77.00 KiB/s, <span class="keyword">done</span>.</span><br><span class="line">From gitee.com:terrylikescoding/git-playground</span><br><span class="line">   ed9cf4a..81d81eb  master     -&gt; origin/master</span><br></pre></td></tr></table></figure><p>此时再次运行<code>git log</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">MINGW64 /d/tmp/git-playground (master)</span><br><span class="line">$ git <span class="built_in">log</span> --oneline --all --graph</span><br><span class="line">* 09af026 (HEAD -&gt; master) 添加D.java</span><br><span class="line">* 6bfb728 提交C.java</span><br><span class="line">| * 81d81eb (origin/master, origin/HEAD) 其他人在master上的提交2 <span class="comment"># 新的origin</span></span><br><span class="line">| * 144b12a 其他人在master上的提交</span><br><span class="line">|/</span><br><span class="line">* ed9cf4a 提交.gitignore <span class="comment"># 首次git clone时的版本 ！！！！！！</span></span><br><span class="line">*   152d12e Merge branch <span class="string">&#x27;hotfix&#x27;</span></span><br><span class="line">|\</span><br><span class="line">| * 068a534 修复XX问题[hotfix]</span><br><span class="line">* | 8507b7f 修改A.java文件[master]</span><br><span class="line">|/</span><br><span class="line">* 519c74f 提交git ignore</span><br><span class="line">* dcd138e first commit</span><br></pre></td></tr></table></figure><p>可视化的结果如下</p><p><img src="image-20240326111149500.png" alt="image-20240326111149500"></p><p>此时：</p><p><img src="image-20240326111620621.png" alt="image-20240326111620621"></p><h3 id="关联多个远程仓库">关联多个远程仓库</h3><p>为了演示有多个远程仓库与远程分支的情况，我们假定你有<strong>另一个</strong>内部 Git 服务器，仅用于你的 sprint 小组的开发工作。 这个服务器位于 <code>git.team1.ourcompany.com</code>。 你可以运行 <code>git remote add</code> 命令添加一个新的远程仓库引用到当前的项目，这个命令我们会在 <a href="https://www.progit.cn/#_git_basics_chapter">Git 基础</a> 中详细说明。 将这个远程仓库命名为 <code>teamone</code>，将其作为整个 URL 的缩写。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add git.team1.ourcompany.com</span><br></pre></td></tr></table></figure><p><img src="image-20240326112058245.png" alt="image-20240326112058245"></p><p>现在，可以运行 <code>git fetch teamone</code> 来抓取远程仓库 <code>teamone</code> 有而本地没有的数据。 因为那台服务器上现有的数据是 <code>origin</code> 服务器上的一个<strong>子集</strong>，所以 Git <strong>并不会抓取数据</strong>而是会设置远程跟踪分支 <code>teamone/master</code> 指向 <code>teamone</code> 的 <code>master</code> 分支。</p><p><img src="image-20240326112254915.png" alt="image-20240326112254915"></p><h3 id="推送">推送</h3><p>当你想要公开分享一个分支时，需要将其推送到有<strong>写入权限</strong>的远程仓库上。 本地的分支并不会自动与远程仓库同步 - 你<strong>必须显式地推送</strong>想要分享的分支。 这样，你就可以把不愿意分享的内容放到私人分支上，而将需要和别人协作的内容推送到公开分支。</p><p>如果希望和别人一起在名为 <code>serverfix</code> 的<strong>分支</strong>上工作，你可以像推送第一个分支那样推送它。 运行 <code>git push (remote) (branch)</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin serverfix</span><br><span class="line">Counting objects: 24, <span class="keyword">done</span>.</span><br><span class="line">Delta compression using up to 8 threads.</span><br><span class="line">Compressing objects: 100% (15/15), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (24/24), 1.91 KiB | 0 bytes/s, <span class="keyword">done</span>.</span><br><span class="line">Total 24 (delta 2), reused 0 (delta 0)</span><br><span class="line">To https://github.com/schacon/simplegit</span><br><span class="line"> * [new branch]      serverfix -&gt; serverfix</span><br></pre></td></tr></table></figure><p>这里有些工作被简化了。 Git 自动将 <code>serverfix</code> 分支名字展开为 <code>refs/heads/serverfix:refs/heads/serverfix</code>，那意味着，“推送本地的 serverfix 分支来更新远程仓库上的 <code>serverfix</code> 分支。</p><p>我们将会详细学习 <a href="https://www.progit.cn/#_git_internals">Git 内部原理</a> 的 <code>refs/heads/</code> 部分，但是现在可以先把它放在儿。 你也可以运行 <code>git push origin serverfix:serverfix</code>，它会做同样的事 - 相当于它说，“推送本地的 serverfix 分支，将其作为远程仓库的 serverfix 分支”</p><p>可以通过这种格式来推送本地分支到一个<strong>命名不相同的远程分支</strong>。 如果并不想让远程仓库上的分支叫做 <code>serverfix</code>，可以运行 <code>git push origin serverfix:awesomebranch</code> 来将本地的 <code>serverfix</code> 分支推送到远程仓库上的 <code>awesomebranch</code> 分支。</p><p>下一次其他协作者从服务器上抓取数据时，他们会在本地生成一个远程分支 <code>origin/serverfix</code>，指向服务器的 <code>serverfix</code> 分支的引用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch origin</span><br><span class="line">remote: Counting objects: 7, <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (2/2), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 3 (delta 0), reused 3 (delta 0)</span><br><span class="line">Unpacking objects: 100% (3/3), <span class="keyword">done</span>.</span><br><span class="line">From https://github.com/schacon/simplegit</span><br><span class="line"> * [new branch]      serverfix    -&gt; origin/serverfix</span><br></pre></td></tr></table></figure><p>要特别注意的一点是当抓取到新的远程跟踪分支时，本地不会自动生成一份可编辑的副本（拷贝）。 换一句话说，这种情况下，不会有一个新的 <code>serverfix</code> 分支 - 只有一个不可以修改的 <code>origin/serverfix</code> 指针。</p><p>可以运行 <code>git merge origin/serverfix</code> 将这些工作合并到当前所在的分支。 如果想要在自己的 <code>serverfix</code> 分支上工作，可以将其建立在远程跟踪分支之上：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b serverfix origin/serverfix</span><br><span class="line">Branch serverfix <span class="built_in">set</span> up to track remote branch serverfix from origin.</span><br><span class="line">Switched to a new branch <span class="string">&#x27;serverfix&#x27;</span></span><br></pre></td></tr></table></figure><p>这会给你一个用于工作的本地分支，并且起点位于 <code>origin/serverfix</code>。</p><h3 id="跟踪分支-上游分支upstream">跟踪分支(上游分支upstream)</h3><h4 id="创建跟踪分支">创建跟踪分支</h4><p>从一个远程跟踪分支检出一个本地分支会自动创建一个叫做 “<strong>跟踪分支</strong>”（有时候也叫做 “<strong>上游分支</strong>”）。 跟踪分支是与远程分支<strong>有直接关系的本地分支</strong>。 如果在一个跟踪分支上输入 <code>git pull</code>，Git 能自<strong>动地识别去哪个服务器上抓取、合并到哪个分支</strong>。</p><p>当<strong>克隆</strong>一个仓库时，它通常会自动地创建一个跟踪 <code>origin/master</code> 的 <code>master</code> 分支。 然而，如果你愿意的话可以设置其他的跟踪分支 - <strong>其他远程仓库上的跟踪分支</strong>，或者不跟踪 <code>master</code> 分支。 最简单的就是之前看到的例子，运行 <code>git checkout -b [branch] [remotename]/[branch]</code>。 这是一个十分常用的操作所以 Git 提供了 <code>--track</code> 快捷方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> MINGW64 /d/tmp/git-playground (master)</span><br><span class="line">$ git checkout --track origin/serverfix</span><br><span class="line">Switched to a new branch <span class="string">&#x27;serverfix&#x27;</span></span><br><span class="line">branch <span class="string">&#x27;serverfix&#x27;</span> <span class="built_in">set</span> up to track <span class="string">&#x27;origin/serverfix&#x27;</span>.</span><br></pre></td></tr></table></figure><p>可以看到<code>branch 'serverfix' set up to track 'origin/serverfix'.</code></p><p>如果想要将本地分支与远程分支<strong>设置为不同名字</strong>，你可以轻松地增加一个不同名字的本地分支的上一个命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MINGW64 /d/tmp/git-playground (serverfix)</span><br><span class="line">$ git checkout -b sf origin/serverfix</span><br><span class="line">Switched to a new branch <span class="string">&#x27;sf&#x27;</span></span><br><span class="line">branch <span class="string">&#x27;sf&#x27;</span> <span class="built_in">set</span> up to track <span class="string">&#x27;origin/serverfix&#x27;</span>.</span><br></pre></td></tr></table></figure><p>现在，本地分支 <code>sf</code> 会自动从 <code>origin/serverfix</code> 拉取。</p><p>设置已有的本地分支跟踪一个刚刚拉取下来的远程分支，或者想要修改正在跟踪的<strong>上游分支</strong>，你可以在任意时间使用 <code>-u</code> 或 <code>--set-upstream-to</code> 选项运行 <code>git branch</code> 来显式地设置。</p><blockquote><p>git branch</p><p>-u <upstream></p><p>–set-upstream-to=<upstream></p><p>Set up <branchname>'s tracking information so <upstream> is considered <branchname>'s upstream branch. If no <branchname> is specified, then it defaults to the current branch.</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -u origin/serverfix</span><br><span class="line">Branch serverfix <span class="built_in">set</span> up to track remote branch serverfix from origin.</span><br></pre></td></tr></table></figure><h4 id="查看跟踪分支">查看跟踪分支</h4><p>如果想要查看设置的所<strong>有跟踪分支</strong>，可以使用 <code>git branch</code> 的 <code>-vv</code> 选项。 这会将所有的本地分支列出来并且包含更多的信息，如每一个分支正在跟踪哪个远程分支与本地分支是否是领先、落后或是都有。</p><blockquote><p>-v</p><p>-vv</p><p>–verbose</p><ul class="lvl-1"><li class="lvl-2"><p>When in list mode, show <strong>sha1</strong> and <strong>commit subject</strong> line for each head, along with relationship to upstream branch (if any).</p></li><li class="lvl-2"><p>If given <strong>twice</strong>(即：<code>-vv</code>), print the path of the linked worktree (if any) and the name of the upstream branch, as well (see also <code>git remote show &lt;remote&gt;</code>). Note that the current worktree’s HEAD will not have its path printed (it will always be your current directory).</p></li></ul></blockquote><p>建议直接使用<code>-vv</code>，可以看到最详细的信息，比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -vv</span><br><span class="line">  iss53     7e424c3 [origin/iss53: ahead 2] forgot the brackets</span><br><span class="line">  master    1ae2a45 [origin/master] deploying index fix</span><br><span class="line">* serverfix f8674d9 [teamone/server-fix-good: ahead 3, behind 1] this should <span class="keyword">do</span> it</span><br><span class="line">  testing   5ea463a trying something new</span><br></pre></td></tr></table></figure><p>这里可以看到 <code>iss53</code> 分支正在跟踪 <code>origin/iss53</code> 并且 “ahead” 是 2，意味着本地有两个提交还没有推送到服务器上。 也能看到 <code>master</code> 分支正在跟踪 <code>origin/master</code> 分支并且是最新的。 接下来可以看到 <code>serverfix</code> 分支正在跟踪 <code>teamone</code> 服务器上的 <code>server-fix-good</code> 分支并且领先 2 落后 1，意味着服务器上有一次提交还没有合并入同时本地有三次提交还没有推送。 最后看到 <code>testing</code> 分支并没有跟踪任何远程分支。</p><p>需要重点注意的一点是这些数字的值来自于你从每个服务器上<strong>最后一次抓取(fetch)的数据</strong>。 这个命令并<strong>没有连接服务器</strong>，它只会告诉你关于<strong>本地缓存的服务器数据</strong>。 如果想要统计最新的领先与落后数字，需要在运行此命令前抓取所有的远程仓库。 可以像这样做</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch --all <span class="comment"># Fetch all remotes.</span></span><br><span class="line">$ git branch -vv</span><br></pre></td></tr></table></figure><h3 id="拉取">拉取</h3><p>当 <code>git fetch</code> 命令从服务器上抓取本地没有的数据时，它并<strong>不会修改工作目录中的内容</strong>。 它只会获取数据然后<strong>让你自己合并</strong>。</p><p>然而，有一个命令叫作 <code>git pull</code> 在<strong>大多数情况下</strong>它的含义是一个 <code>git fetch</code> 紧接着一个 <code>git merge</code> 命令。 如果有一个像之前章节中演示的设置好的跟踪分支，不管它是显式地设置还是通过 <code>clone</code> 或 <code>checkout</code> 命令为你创建的，<code>git pull</code> 都会查找当前分支所跟踪的服务器与分支，从服务器上抓取数据然后尝试合并入那个远程分支。</p><blockquote><p>由于 <code>git pull</code> 的魔法经常令人困惑所以通常单独显式地使用 <code>fetch</code> 与 <code>merge</code> 命令会更好一些。</p></blockquote><h3 id="删除远程分支">删除远程分支</h3><p>设你已经通过远程分支做完所有的工作了 - 也就是说你和你的协作者已经完成了一个特性并且将其合并到了远程仓库的 <code>master</code> 分支（或任何其他稳定代码分支）。 可以运行带有 <code>--delete</code> 选项的 <code>git push</code> 命令来删除一个远程分支。 如果想要从服务器上删除 <code>serverfix</code> 分支，运行下面的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin --delete serverfix</span><br><span class="line">To https://github.com/schacon/simplegit</span><br><span class="line"> - [deleted]         serverfix</span><br></pre></td></tr></table></figure><p>基本上这个命令做的只是从服务器上<strong>移除</strong>这个<strong>指针</strong>。 Git 服务器通常会保留数据一段时间直到垃圾回收运行，所以如果不小心删除掉了，通常是很容易恢复的。</p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git基础</title>
      <link href="/2024/03/21/git%E5%9F%BA%E7%A1%80/"/>
      <url>/2024/03/21/git%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="仓库状态查看">仓库状态查看</h2><h3 id="git-status命令">git  status命令</h3><ul class="lvl-0"><li class="lvl-2"><p><code>git status</code>显示详细信息</p></li><li class="lvl-2"><p><code>git status -s</code> 显示简要信息</p></li></ul><h3 id="git-status-s说明">git status -s说明</h3><p><code>??</code>和</p><h2 id="提交文件">提交文件</h2><h3 id="跳过git-add">跳过git add</h3><p><code>git commit</code> 加上 <code>-a</code> 选项，Git 就会自动把所有【已经跟踪过】的文件暂存起来一并提交，从而跳过 git add 步骤,即：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -am <span class="string">&#x27;commit xxx&#x27;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意，<strong>未被追踪</strong>过的数据<strong>不会</strong>被<code>git commit -am</code>提交</p></blockquote><h2 id="删除文件">删除文件</h2><h3 id="方法1-先删除，然后使用git-rm记录">方法1 先删除，然后使用git rm记录</h3><p>如果只是简单地从工作目录中手工删除文件，运行 <code>git status</code> 时就会在 <strong>“Changes not staged for commit”</strong> 部分（也就是未暂存清单）看到，然后再运行 <code>git rm</code> 记录此次移除文件的操作，此时文件的状态才会变为<strong>Changes to be committed</strong>（即：删除操作被暂存）</p><blockquote><p>其实使用<code>git add</code>也可以用来<strong>记录删除操作</strong>，比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">86182@yawen MINGW64 /d/coding/git-playground (master)</span><br><span class="line">$ <span class="built_in">rm</span> download.c <span class="comment"># 直接删除工作区文件（注意是直接删除，不是通过git rm命令删除）</span></span><br><span class="line"></span><br><span class="line">86182@yawen MINGW64 /d/coding/git-playground (master)</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit: <span class="comment"># 提示删除操作尚未添加到暂存区</span></span><br><span class="line">  (use <span class="string">&quot;git add/rm &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git restore &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">        deleted:    download.c</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">&quot;git add&quot;</span> and/or <span class="string">&quot;git commit -a&quot;</span>)</span><br><span class="line"></span><br><span class="line">86182@yawen MINGW64 /d/coding/git-playground (master)</span><br><span class="line">$ git add download.c <span class="comment"># 通过git add也可以记录删除操作</span></span><br><span class="line"></span><br><span class="line">86182@yawen MINGW64 /d/coding/git-playground (master)</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed: <span class="comment"># 已经将删除文件的操作添加到暂存区</span></span><br><span class="line">  (use <span class="string">&quot;git restore --staged &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line">        deleted:    download.c</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><h3 id="方法2-使用git-rm（暂存区中没有改动）">方法2 使用git rm（暂存区中没有改动）</h3><p>针对<strong>暂存区中没有改动</strong>的文件，可以直接使用<code>git rm</code>删除</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">86182@yawen MINGW64 /d/coding/git-playground (master)</span><br><span class="line">$ ll</span><br><span class="line">total 3</span><br><span class="line">-rw-r--r-- 1 86182 197609 20  3月 21 09:21 CONTRIBUTING.md</span><br><span class="line">-rw-r--r-- 1 86182 197609  0  3月 21 10:35 download.c</span><br><span class="line">-rw-r--r-- 1 86182 197609  0  3月 20 16:14 LICENSE</span><br><span class="line">-rw-r--r-- 1 86182 197609  4  3月 20 16:34 main.c</span><br><span class="line">-rw-r--r-- 1 86182 197609  0  3月 20 16:36 out.a</span><br><span class="line">-rw-r--r-- 1 86182 197609  0  3月 20 16:36 out.o</span><br><span class="line">-rw-r--r-- 1 86182 197609 21  3月 21 09:28 README</span><br><span class="line"></span><br><span class="line">86182@yawen MINGW64 /d/coding/git-playground (master)</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line"></span><br><span class="line">86182@yawen MINGW64 /d/coding/git-playground (master)</span><br><span class="line">$ git <span class="built_in">rm</span> download.c <span class="comment"># 通过git rm直接删除</span></span><br><span class="line"><span class="built_in">rm</span> <span class="string">&#x27;download.c&#x27;</span></span><br><span class="line"></span><br><span class="line">86182@yawen MINGW64 /d/coding/git-playground (master)</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:  <span class="comment"># 此时删除操作直接被记录到暂存区</span></span><br><span class="line">  (use <span class="string">&quot;git restore --staged &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line">        deleted:    download.c</span><br></pre></td></tr></table></figure><blockquote><p>注意：如果使用<code>git rm</code>删除<strong>尚未追踪的文件</strong>，会报错<code>fatal: pathspec 'xxx' did not match any files</code>，比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">86182@yawen MINGW64 /d/coding/git-playground (master)</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Untracked files:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to include <span class="keyword">in</span> what will be committed)</span><br><span class="line">        README.md <span class="comment"># 尚未被追踪的文件（即：仅存在与工作区）</span></span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">&quot;git add&quot;</span> and/or <span class="string">&quot;git commit -a&quot;</span>)</span><br><span class="line"></span><br><span class="line">86182@yawen MINGW64 /d/coding/git-playground (master)</span><br><span class="line">$ git <span class="built_in">rm</span> README.md <span class="comment"># 尝试通过git rm删除</span></span><br><span class="line">fatal: pathspec <span class="string">&#x27;README.md&#x27;</span> did not match any files </span><br></pre></td></tr></table></figure></blockquote><h3 id="方法3-使用git-rm-f-暂存区中有改动">方法3 使用git rm -f(暂存区中有改动)</h3><p>如果删除之前修改过并且已<strong>经放到暂存区</strong>的话，则必须要用强制删除选项 <code>-f</code>,否则会提示如下错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: the following file has changes staged in the index</span><br></pre></td></tr></table></figure><p>这是一种安全特性，用于防止误删还没有添加到快照的数据，这样的数据不能被 Git 恢复。比如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">86182@yawen MINGW64 /d/coding/git-playground (master)</span><br><span class="line">$ vim fetch.js <span class="comment"># 修改文件</span></span><br><span class="line"></span><br><span class="line">86182@yawen MINGW64 /d/coding/git-playground (master)</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git restore &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">        modified:   fetch.js</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">&quot;git add&quot;</span> and/or <span class="string">&quot;git commit -a&quot;</span>)</span><br><span class="line"></span><br><span class="line">86182@yawen MINGW64 /d/coding/git-playground (master)</span><br><span class="line">$ git add fetch.js <span class="comment"># 添加到暂存区</span></span><br><span class="line"></span><br><span class="line">86182@yawen MINGW64 /d/coding/git-playground (master)</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed: <span class="comment"># 改动已经保存到暂存区</span></span><br><span class="line">  (use <span class="string">&quot;git restore --staged &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line">        modified:   fetch.js</span><br><span class="line"></span><br><span class="line">86182@yawen MINGW64 /d/coding/git-playground (master)</span><br><span class="line">$ git <span class="built_in">rm</span> fetch.js <span class="comment"># 尝试不添加-f参数直接删除文件</span></span><br><span class="line">error: the following file has changes staged <span class="keyword">in</span> the index: <span class="comment"># 报错</span></span><br><span class="line">    fetch.js</span><br><span class="line">(use --cached to keep the file, or -f to force removal)</span><br><span class="line"></span><br><span class="line">86182@yawen MINGW64 /d/coding/git-playground (master)</span><br><span class="line">$ git <span class="built_in">rm</span> -f fetch.js</span><br><span class="line"><span class="built_in">rm</span> <span class="string">&#x27;fetch.js&#x27;</span></span><br><span class="line"></span><br><span class="line">86182@yawen MINGW64 /d/coding/git-playground (master)</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git restore --staged &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line">        deleted:    fetch.js</span><br></pre></td></tr></table></figure><h2 id="差异对比">差异对比</h2><h3 id="查看尚未暂存部分的差异">查看尚未暂存部分的差异</h3><p>要查看**尚未暂存(unstaged)**的文件更新了哪些部分，不加参数直接输入 <code>git diff</code></p><h3 id="查看已暂存部分的差异">查看已暂存部分的差异</h3><p>若要查看<strong>已暂存的将</strong>要添加到下次提交里的内容，可以用 <code>git diff --cached</code> 命令。（Git 1.6.1 及更高版本还允许使用 <code>git diff --staged</code>，效果是相同的，但更好记些。）</p><h3 id="–staged-和-cached">–staged 和 --cached</h3><p><code>--staged</code> 和 <code>--cached</code> 是同义词</p><h2 id="移动（重命名）文件">移动（重命名）文件</h2><p>不像其它的 VCS 系统，Git 并<strong>不显式跟踪文件移动操作</strong>。 如果在 Git 中重命名了某个文件，仓库中存储的元数据并<strong>不会体现出这是一次改名操作</strong>。</p><p>比如直接通过操作系统重命名一个文件（注意<strong>不是</strong><code>git mv</code>）:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">86182@yawen MINGW64 /d/coding/git-playground (master)</span><br><span class="line">$ <span class="built_in">mv</span> README README.md <span class="comment"># 直接通过系统mv命令重命名</span></span><br><span class="line"></span><br><span class="line">86182@yawen MINGW64 /d/coding/git-playground (master)</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">&quot;git add/rm &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git restore &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">        deleted:    README</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to include <span class="keyword">in</span> what will be committed)</span><br><span class="line">        README.md</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">&quot;git add&quot;</span> and/or <span class="string">&quot;git commit -a&quot;</span>)</span><br></pre></td></tr></table></figure><p>可以看到，git并不认为这是一个重命名操作，而是认为我们：</p><ol><li class="lvl-3"><p>删除了<code>README</code>文件</p></li><li class="lvl-3"><p>新增了一个<code>README.md</code>文件</p></li></ol><p>如果希望git明确的记录重命名操作，可以通过<code>git mv</code>实现，比如同样的操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">86182@yawen MINGW64 /d/coding/git-playground (master)</span><br><span class="line">$ git <span class="built_in">mv</span> README README.md</span><br><span class="line"></span><br><span class="line">86182@yawen MINGW64 /d/coding/git-playground (master)</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git restore --staged &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line">        renamed:    README -&gt; README.md <span class="comment"># 记录的操作类型为rename</span></span><br></pre></td></tr></table></figure><p><code>git mv</code>相当于如下三条命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mv</span> README README.md</span><br><span class="line">git <span class="built_in">rm</span> README</span><br><span class="line">git add README.md</span><br></pre></td></tr></table></figure><h2 id="查看提交历史">查看提交历史</h2><h3 id="基础用法">基础用法</h3><p>在提交了若干更新，又或者克隆了某个项目之后，你也许想回顾下提交历史。 完成这个任务最简单而又有效的工具是 <code>git log</code> 命令，比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span></span><br><span class="line">commit 32b941f804b460b97ba5bc8fc87db57fda654018 (HEAD -&gt; master)</span><br><span class="line">Author: slimterry &lt;slimterry@qq.com&gt;</span><br><span class="line">Date:   Thu Mar 21 10:59:17 2024 +0800</span><br><span class="line"></span><br><span class="line">    重命名Readme.md</span><br><span class="line"></span><br><span class="line">commit 8baa8018574dd11181d5b4943f70c1ad69ee6a49</span><br><span class="line">Author: slimterry &lt;slimterry@qq.com&gt;</span><br><span class="line">Date:   Thu Mar 21 09:55:34 2024 +0800</span><br><span class="line"></span><br><span class="line">    删除fetch.js</span><br></pre></td></tr></table></figure><h3 id="显示每次提交的内容差异-p选项">显示每次提交的内容差异(-p选项)</h3><p>默认情况下，<code>git log</code>不会生成任何<code>diff</code>的输出（见上），一个常用的选项是 <code>-p</code>，用来<strong>显示每次提交的内容差异</strong>，比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> -p</span><br><span class="line">commit 32b941f804b460b97ba5bc8fc87db57fda654018 (HEAD -&gt; master)</span><br><span class="line">Author: slimterry &lt;slimterry@qq.com&gt;</span><br><span class="line">Date:   Thu Mar 21 10:59:17 2024 +0800</span><br><span class="line"></span><br><span class="line">    重命名Readme.md</span><br><span class="line"></span><br><span class="line">diff --git a/README b/README.md</span><br><span class="line">similarity index 100%</span><br><span class="line">rename from README</span><br><span class="line">rename to README.md</span><br><span class="line"></span><br><span class="line">commit 8baa8018574dd11181d5b4943f70c1ad69ee6a49</span><br><span class="line">Author: slimterry &lt;slimterry@qq.com&gt;</span><br><span class="line">Date:   Thu Mar 21 09:55:34 2024 +0800</span><br><span class="line"></span><br><span class="line">    删除fetch.js</span><br><span class="line"></span><br><span class="line">diff --git a/fetch.js b/fetch.js</span><br><span class="line">deleted file mode 100644</span><br><span class="line">index e69de29..0000000</span><br></pre></td></tr></table></figure><blockquote><p>该选项除了显示基本信息之外，还附带了每次 commit 的变化。</p></blockquote><p>你也可以加上 <code>-2</code> 来仅显示<strong>最近两次</strong>提交，比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">86182@yawen MINGW64 /d/coding/git-playground (master)</span><br><span class="line">$ git <span class="built_in">log</span> -p -2</span><br><span class="line">commit 32b941f804b460b97ba5bc8fc87db57fda654018 (HEAD -&gt; master)</span><br><span class="line">Author: slimterry &lt;slimterry@qq.com&gt;</span><br><span class="line">Date:   Thu Mar 21 10:59:17 2024 +0800</span><br><span class="line"></span><br><span class="line">    重命名Readme.md</span><br><span class="line"></span><br><span class="line">diff --git a/README b/README.md</span><br><span class="line">similarity index 100%</span><br><span class="line">rename from README</span><br><span class="line">rename to README.md</span><br><span class="line"></span><br><span class="line">commit 8baa8018574dd11181d5b4943f70c1ad69ee6a49</span><br><span class="line">Author: slimterry &lt;slimterry@qq.com&gt;</span><br><span class="line">Date:   Thu Mar 21 09:55:34 2024 +0800</span><br><span class="line"></span><br><span class="line">    删除fetch.js</span><br><span class="line"></span><br><span class="line">diff --git a/fetch.js b/fetch.js</span><br><span class="line">deleted file mode 100644</span><br><span class="line">index e69de29..0000000</span><br></pre></td></tr></table></figure><h3 id="查看每次提交的简略信息（–stat）">查看每次提交的简略信息（–stat）</h3><p><code>--stat</code> 选项在每次提交的下面列出所有被修改过的文件、有多少文件被修改了以及被修改过的文件的哪些行被移除或是添加了。,在每次提交的最后还有一个<strong>总结</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git log --stat -1</span><br><span class="line">commit 32b941f804b460b97ba5bc8fc87db57fda654018 (HEAD -&gt; master)</span><br><span class="line">Author: slimterry &lt;slimterry@qq.com&gt;</span><br><span class="line">Date:   Thu Mar 21 10:59:17 2024 +0800</span><br><span class="line"></span><br><span class="line">    重命名Readme.md</span><br><span class="line"></span><br><span class="line"> README =&gt; README.md | 0</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br></pre></td></tr></table></figure><h3 id="美化输出-–pretty">美化输出(–pretty)</h3><p>另外一个常用的选项是 <code>--pretty</code>。 这个选项可以指定使用不同于默认格式的方式展示提交历史。 这个选项有一些内建的子选项供你使用。 比如用 <code>oneline</code> 将每个提交放在<strong>一行</strong>显示，查看的提交数很大时非常有用，比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --pretty=oneline</span><br><span class="line">32b941f804b460b97ba5bc8fc87db57fda654018 (HEAD -&gt; master) 重命名Readme.md</span><br><span class="line">8baa8018574dd11181d5b4943f70c1ad69ee6a49 删除fetch.js</span><br><span class="line">9990b44a8dea55760322c98cfe7868b15dd4356f 删除robot.txt</span><br><span class="line">de8fb678dacd2e15ac9ad8f37f6bd7889311ffda 添加robot.txt</span><br><span class="line">2ae831bc8513981ea3bd5e49b80e472d4a3c1fd0 直接使用-am参数提交</span><br><span class="line">6b40dfc09d3710513629e85af3cbe88ac9123fd0 提交CONTRIBUTING.md</span><br><span class="line">15ba6d001ccf53b1979c16556691cf8b49860e03 修改md</span><br><span class="line">2e623a603ecb35719a07b481b141137b511607a0 提交.gitignore</span><br><span class="line">f496a0ffda4529059acca55508b56e99e15a5f02 新增文件</span><br><span class="line">3b4a7a8b032a2a78637a0ff9c8e1becff6243075 新增 new file:   CONTRIBUTING.m</span><br><span class="line">351876e11887dd9d63cf66670737696618860c1e initial project version</span><br></pre></td></tr></table></figure><blockquote><p>还可以直接通过<code>git log --online</code>查看简要输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --oneline</span><br><span class="line">32b941f (HEAD -&gt; master) 重命名Readme.md</span><br><span class="line">8baa801 删除fetch.js</span><br><span class="line">9990b44 删除robot.txt</span><br><span class="line">de8fb67 添加robot.txt</span><br><span class="line">2ae831b 直接使用-am参数提交</span><br><span class="line">6b40dfc 提交CONTRIBUTING.md</span><br><span class="line">15ba6d0 修改md</span><br><span class="line">2e623a6 提交.gitignore</span><br><span class="line">f496a0f 新增文件</span><br><span class="line">3b4a7a8 新增 new file:   CONTRIBUTING.m</span><br><span class="line">351876e initial project version</span><br></pre></td></tr></table></figure></blockquote><p>另外还有 <code>short</code>，<code>full</code> 和 <code>fuller</code> 可以用，展示的信息或多或少有些不同:</p><p>比如<code>short</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --pretty=short -2</span><br><span class="line">commit 32b941f804b460b97ba5bc8fc87db57fda654018 (HEAD -&gt; master)</span><br><span class="line">Author: slimterry &lt;slimterry@qq.com&gt;</span><br><span class="line"></span><br><span class="line">    重命名Readme.md</span><br><span class="line"></span><br><span class="line">commit 8baa8018574dd11181d5b4943f70c1ad69ee6a49</span><br><span class="line">Author: slimterry &lt;slimterry@qq.com&gt;</span><br><span class="line"></span><br><span class="line">    删除fetch.js</span><br></pre></td></tr></table></figure><p><code>fuller</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --pretty=fuller</span><br><span class="line">commit 32b941f804b460b97ba5bc8fc87db57fda654018 (HEAD -&gt; master)</span><br><span class="line">Author:     slimterry &lt;slimterry@qq.com&gt;</span><br><span class="line">AuthorDate: Thu Mar 21 10:59:17 2024 +0800</span><br><span class="line">Commit:     slimterry &lt;slimterry@qq.com&gt;</span><br><span class="line">CommitDate: Thu Mar 21 10:59:17 2024 +0800</span><br><span class="line"></span><br><span class="line">    重命名Readme.md</span><br><span class="line"></span><br><span class="line">commit 8baa8018574dd11181d5b4943f70c1ad69ee6a49</span><br><span class="line">Author:     slimterry &lt;slimterry@qq.com&gt;</span><br><span class="line">AuthorDate: Thu Mar 21 09:55:34 2024 +0800</span><br><span class="line">Commit:     slimterry &lt;slimterry@qq.com&gt;</span><br><span class="line">CommitDate: Thu Mar 21 09:55:34 2024 +0800</span><br><span class="line"></span><br><span class="line">    删除fetch.js</span><br></pre></td></tr></table></figure><p>但最有意思的是 <code>format</code>，可以定制要显示的记录格式。 这样的输出对后期提取分析格外有用 — 因为输出的格式不会随着 Git 的更新而发生改变,比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --pretty=format:<span class="string">&quot;%h - %an, %ar : %s&quot;</span></span><br><span class="line">32b941f - slimterry, 29 minutes ago : 重命名Readme.md</span><br><span class="line">8baa801 - slimterry, 2 hours ago : 删除fetch.js</span><br><span class="line">9990b44 - slimterry, 2 hours ago : 删除robot.txt</span><br><span class="line">de8fb67 - slimterry, 2 hours ago : 添加robot.txt</span><br><span class="line">2ae831b - slimterry, 2 hours ago : 直接使用-am参数提交</span><br><span class="line">6b40dfc - slimterry, 2 hours ago : 提交CONTRIBUTING.md</span><br><span class="line">15ba6d0 - slimterry, 2 hours ago : 修改md</span><br><span class="line">2e623a6 - slimterry, 19 hours ago : 提交.gitignore</span><br><span class="line">f496a0f - slimterry, 19 hours ago : 新增文件</span><br><span class="line">3b4a7a8 - slimterry, 19 hours ago : 新增 new file:   CONTRIBUTING.m</span><br><span class="line">351876e - slimterry, 19 hours ago : initial project version</span><br></pre></td></tr></table></figure><p><code>git log --pretty=format</code>的常用选项如下：</p><table><thead><tr><th style="text-align:left">选项</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><code>%H</code></td><td style="text-align:left">提交对象（commit）的完整哈希字串</td></tr><tr><td style="text-align:left"><code>%h</code></td><td style="text-align:left">提交对象的简短哈希字串</td></tr><tr><td style="text-align:left"><code>%T</code></td><td style="text-align:left">树对象（tree）的完整哈希字串</td></tr><tr><td style="text-align:left"><code>%t</code></td><td style="text-align:left">树对象的简短哈希字串</td></tr><tr><td style="text-align:left"><code>%P</code></td><td style="text-align:left">父对象（parent）的完整哈希字串</td></tr><tr><td style="text-align:left"><code>%p</code></td><td style="text-align:left">父对象的简短哈希字串</td></tr><tr><td style="text-align:left"><code>%an</code></td><td style="text-align:left">作者（author）的名字</td></tr><tr><td style="text-align:left"><code>%ae</code></td><td style="text-align:left">作者的电子邮件地址</td></tr><tr><td style="text-align:left"><code>%ad</code></td><td style="text-align:left">作者修订日期（可以用 --date= 选项定制格式）</td></tr><tr><td style="text-align:left"><code>%ar</code></td><td style="text-align:left">作者修订日期，按多久以前的方式显示</td></tr><tr><td style="text-align:left"><code>%cn</code></td><td style="text-align:left">提交者（committer）的名字</td></tr><tr><td style="text-align:left"><code>%ce</code></td><td style="text-align:left">提交者的电子邮件地址</td></tr><tr><td style="text-align:left"><code>%cd</code></td><td style="text-align:left">提交日期</td></tr><tr><td style="text-align:left"><code>%cr</code></td><td style="text-align:left">提交日期，按多久以前的方式显示</td></tr><tr><td style="text-align:left"><code>%s</code></td><td style="text-align:left">提交说明</td></tr></tbody></table><h3 id="图像化输出提交记录（–graph）">图像化输出提交记录（–graph）</h3><p>当 oneline 或 format 与另一个 <code>log</code> 选项 <code>--graph</code> 结合使用时尤其有用。 这个选项添加了一些ASCII字符串来形象地展示你的分支、合并历史，比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --pretty=format:<span class="string">&quot;%h %s&quot;</span> --graph</span><br><span class="line">* 2d3acf9 ignore errors from SIGCHLD on <span class="built_in">trap</span></span><br><span class="line">*  5e3ee11 Merge branch <span class="string">&#x27;master&#x27;</span> of git://github.com/dustin/grit</span><br><span class="line">|\</span><br><span class="line">| * 420eac9 Added a method <span class="keyword">for</span> getting the current branch.</span><br><span class="line">* | 30e367c <span class="built_in">timeout</span> code and tests</span><br><span class="line">* | 5a09431 add <span class="built_in">timeout</span> protection to grit</span><br><span class="line">* | e1193f8 support <span class="keyword">for</span> heads with slashes <span class="keyword">in</span> them</span><br><span class="line">|/</span><br><span class="line">* d6016bc require time <span class="keyword">for</span> xmlschema</span><br><span class="line">*  11d191e Merge branch <span class="string">&#x27;defunkt&#x27;</span> into <span class="built_in">local</span></span><br></pre></td></tr></table></figure><h3 id="git-log常用选项">git log常用选项</h3><table><thead><tr><th style="text-align:left">选项</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><code>-p</code></td><td style="text-align:left">按补丁格式显示每个更新之间的差异。</td></tr><tr><td style="text-align:left"><code>--stat</code></td><td style="text-align:left">显示每次更新的文件修改<strong>统计信息</strong>。</td></tr><tr><td style="text-align:left"><code>--shortstat</code></td><td style="text-align:left">只显示 --stat 中最后的行数修改添加移除统计。</td></tr><tr><td style="text-align:left"><code>--name-only</code></td><td style="text-align:left">仅在提交信息后显示已修改的文件清单。</td></tr><tr><td style="text-align:left"><code>--name-status</code></td><td style="text-align:left">显示新增、修改、删除的文件清单。</td></tr><tr><td style="text-align:left"><code>--abbrev-commit</code></td><td style="text-align:left">仅显示 SHA-1 的前几个字符，而非所有的 40 个字符。</td></tr><tr><td style="text-align:left"><code>--relative-date</code></td><td style="text-align:left">使用较短的相对时间显示（比如，“2 weeks ago”）。</td></tr><tr><td style="text-align:left"><code>--graph</code></td><td style="text-align:left">显示 ASCII 图形表示的分支合并历史。</td></tr><tr><td style="text-align:left"><code>--pretty</code></td><td style="text-align:left">使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式）。</td></tr></tbody></table><h3 id="限制-筛选-git-log输出">限制(筛选)git log输出</h3><p>除了定制输出格式的选项之外，<code>git log</code> 还有许多非常实用的限制输出长度的选项，也就是只输出部分提交信息。 之前你已经看到过 <code>-2</code> 了，它只显示最近的两条提交， 实际上，这是 <code>-&lt;n&gt;</code> 选项的写法，其中的 <code>n</code> 可以是任何整数，表示仅显示最近的若干条提交。</p><p>另外还有按照<strong>时间作限制的选项</strong>，比如 <code>--since</code> 和 <code>--until</code> 也很有用。 例如，下面的命令列出所有最近两周内的提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --since=2.weeks</span><br></pre></td></tr></table></figure><p>这个命令可以在多种格式下工作，比如说具体的某一天 <code>&quot;2024-03-20&quot;</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --since=<span class="string">&quot;2024-03-20&quot;</span></span><br></pre></td></tr></table></figure><p>还有<strong>筛选作者</strong>的选项<code>--author</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --author=<span class="string">&#x27;slim&#x27;</span></span><br><span class="line">commit 32b941f804b460b97ba5bc8fc87db57fda654018 (HEAD -&gt; master)</span><br><span class="line">Author: slimterry &lt;slimterry@qq.com&gt;</span><br><span class="line">Date:   Thu Mar 21 10:59:17 2024 +0800</span><br><span class="line"></span><br><span class="line">    重命名Readme.md</span><br></pre></td></tr></table></figure><blockquote><p>注意：此处的<code>-author</code>选项是模糊匹配</p></blockquote><p>还有筛选**提交说明(即：commit message)**关键字的选项<code>--grep</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --grep <span class="string">&#x27;重命名&#x27;</span></span><br><span class="line">commit 32b941f804b460b97ba5bc8fc87db57fda654018 (HEAD -&gt; master)</span><br><span class="line">Author: slimterry &lt;slimterry@qq.com&gt;</span><br><span class="line">Date:   Thu Mar 21 10:59:17 2024 +0800</span><br><span class="line"></span><br><span class="line">    重命名Readme.md</span><br></pre></td></tr></table></figure><blockquote><p>类似地，<code>--grep</code>也是模糊匹配</p></blockquote><blockquote><p>“请注意，如果要得到<strong>同时满足</strong>这两个选项搜索条件的提交，就必须用 <code>--all-match</code> 选项。否则，满足任意一个条件的提交都会被匹配出来” — <a href="https://www.progit.cn/#_git_basics_chapter">https://www.progit.cn/#_git_basics_chapter</a></p></blockquote><p>上述关于<code>--all-match</code>选项的<strong>说明似乎有问题</strong>，测试发现即使不添加 <code>--all-match</code> 选项，也可能实现同时筛选多个条件的目的，比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --oneline --author=<span class="string">&#x27;slim&#x27;</span> <span class="comment"># 所有提交记录的作者均为slimterry</span></span><br><span class="line">32b941f (HEAD -&gt; master) 重命名Readme.md</span><br><span class="line">8baa801 删除fetch.js</span><br><span class="line">9990b44 删除robot.txt</span><br><span class="line">de8fb67 添加robot.txt</span><br><span class="line">2ae831b 直接使用-am参数提交</span><br><span class="line">6b40dfc 提交CONTRIBUTING.md</span><br><span class="line">15ba6d0 修改md</span><br><span class="line">2e623a6 提交.gitignore</span><br><span class="line">f496a0f 新增文件</span><br><span class="line">3b4a7a8 新增 new file:   CONTRIBUTING.m</span><br><span class="line">351876e initial project version</span><br><span class="line"></span><br><span class="line">$ git <span class="built_in">log</span> --oneline --author=<span class="string">&#x27;slim&#x27;</span> --grep=<span class="string">&#x27;robot&#x27;</span> <span class="comment"># 同时筛选2个条件（不添加all-match）</span></span><br><span class="line">9990b44 删除robot.txt</span><br><span class="line">de8fb67 添加robot.txt</span><br><span class="line"></span><br><span class="line">$ git <span class="built_in">log</span> --oneline --author=<span class="string">&#x27;slim&#x27;</span> --grep=<span class="string">&#x27;robot&#x27;</span> --all-match <span class="comment"># 添加all-match）</span></span><br><span class="line">9990b44 删除robot.txt</span><br><span class="line">de8fb67 添加robot.txt</span><br></pre></td></tr></table></figure><p>另一个非常有用的筛选选项是 <code>-S</code>，可以列出那些<strong>添加</strong>或<strong>移除</strong>了<strong>某些字符串的提交</strong>,比如某一次提交中，修改改了文件<code>README.md</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git restore --staged &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line">        modified:   README.md  <span class="comment"># 修改了README.md</span></span><br><span class="line"></span><br><span class="line">$ git diff --staged</span><br><span class="line">diff --git a/README.md b/README.md</span><br><span class="line">index f9ec15a..0ef4f23 100644</span><br><span class="line">--- a/README.md</span><br><span class="line">+++ b/README.md</span><br><span class="line">@@ -1,3 +1,4 @@</span><br><span class="line"> My Project</span><br><span class="line"> 2342</span><br><span class="line"> 1234</span><br><span class="line">+aaaa  <span class="comment"># 此次新增的内容为 &#x27;aaaa&#x27;</span></span><br><span class="line"></span><br><span class="line">$ git commit -m <span class="string">&#x27;修改readme&#x27;</span> <span class="comment"># 提交本次修改</span></span><br><span class="line">[master d83bcb9] 修改readme</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><p>此时可以通过<code>-S</code>选项来筛选该次提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> -Saaaa</span><br><span class="line">commit d83bcb9d965a12f5cfe05d5eb45591580d0489e4 (HEAD -&gt; master)</span><br><span class="line">Author: slimterry &lt;slimterry@qq.com&gt;</span><br><span class="line">Date:   Thu Mar 21 14:18:08 2024 +0800</span><br><span class="line"></span><br><span class="line">    修改readme</span><br></pre></td></tr></table></figure><blockquote><p>注意：此处的<code>-S</code>也是模糊匹配，通过<code>git log -Saa</code>也能找到上述的记录。</p></blockquote><h2 id="撤销操作">撤销操作</h2><h3 id="重新提交（–amend）">重新提交（–amend）</h3><p>有时候我们提交完了才发现漏掉了<strong>几个文件没有添加</strong>，或者<strong>提交信息写错了</strong>。 此时，可以运行带有 <code>--amend</code> 选项的提交命令尝试重新提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit --amend -m <span class="string">&quot;新的提交信息&quot;</span></span><br></pre></td></tr></table></figure><p>这个命令会将<strong>暂存区中的文件提交</strong>。</p><p>如果<strong>自上次提交以来你还未做任何修改</strong>（例如，在上次提交后马上执行了此命令），那么快照会保持不变，而你所修改的只是提交信息，比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ git status  </span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean  <span class="comment"># 已无任何需要提交的改动</span></span><br><span class="line"></span><br><span class="line">$ git <span class="built_in">log</span> -1  </span><br><span class="line">commit d83bcb9d965a12f5cfe05d5eb45591580d0489e4 (HEAD -&gt; master)</span><br><span class="line">Author: slimterry &lt;slimterry@qq.com&gt;</span><br><span class="line">Date:   Thu Mar 21 14:18:08 2024 +0800</span><br><span class="line"></span><br><span class="line">    修改readme  <span class="comment"># 上一次提交的commit message</span></span><br><span class="line"></span><br><span class="line">$ git commit -m <span class="string">&quot;修改readme ---补充提交信息&quot;</span> --amend  <span class="comment"># 不做任何修改，仅修改提交信息</span></span><br><span class="line">[master f1a3002] 修改readme ---补充提交信息</span><br><span class="line"> Date: Thu Mar 21 14:18:08 2024 +0800</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"></span><br><span class="line">$ git <span class="built_in">log</span> -2  <span class="comment"># 查看最近的2条提交记录</span></span><br><span class="line">commit f1a30024cee279c169888a51a1fc214bb36c561a (HEAD -&gt; master)</span><br><span class="line">Author: slimterry &lt;slimterry@qq.com&gt;</span><br><span class="line">Date:   Thu Mar 21 14:18:08 2024 +0800</span><br><span class="line"></span><br><span class="line">    修改readme ---补充提交信息  <span class="comment"># 并没有生成信息提交记录</span></span><br><span class="line"></span><br><span class="line">commit 32b941f804b460b97ba5bc8fc87db57fda654018</span><br><span class="line">Author: slimterry &lt;slimterry@qq.com&gt;</span><br><span class="line">Date:   Thu Mar 21 10:59:17 2024 +0800</span><br><span class="line"></span><br><span class="line">    重命名Readme.md</span><br></pre></td></tr></table></figure><p>文本编辑器启动后，可以看到之前的提交信息。 编辑后保存会<strong>覆盖原来的提交信息</strong>。</p><blockquote><p>使用<code>--amend</code>参数并没有生成新的提交记录，而是直接<strong>覆盖</strong>了原先的提交记录(commit的hash发生了变化)</p></blockquote><p>例如，你提交后发现忘记了暂存某些需要的修改，假如我们的本意是同时添加<code>A.java</code>和<code>B.java</code>这2个文件，</p><p>但是由于疏忽，仅提交了<code>A.java</code>这个文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Untracked files:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to include <span class="keyword">in</span> what will be committed)</span><br><span class="line">        A.java</span><br><span class="line">        B.java</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use <span class="string">&quot;git add&quot;</span> to track)</span><br><span class="line"></span><br><span class="line">$ git add A.java </span><br><span class="line"></span><br><span class="line">$ git commit -m <span class="string">&#x27;新增A.java&#x27;</span>  <span class="comment"># 仅提交了A.java文件</span></span><br><span class="line">[master b8bd35c] 新增A.java</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 A.java</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Untracked files:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to include <span class="keyword">in</span> what will be committed)</span><br><span class="line">        B.java <span class="comment"># 此时的B.java仍然是未追踪的状态</span></span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use <span class="string">&quot;git add&quot;</span> to track)</span><br><span class="line"></span><br><span class="line">$ git <span class="built_in">log</span> -2</span><br><span class="line">commit b8bd35cd8c5d3fcb55a84dc4b68289c888e886ec (HEAD -&gt; master)</span><br><span class="line">Author: slimterry &lt;slimterry@qq.com&gt;</span><br><span class="line">Date:   Thu Mar 21 14:42:40 2024 +0800</span><br><span class="line"></span><br><span class="line">    新增A.java</span><br><span class="line"></span><br><span class="line">commit f1a30024cee279c169888a51a1fc214bb36c561a</span><br><span class="line">Author: slimterry &lt;slimterry@qq.com&gt;</span><br><span class="line">Date:   Thu Mar 21 14:18:08 2024 +0800</span><br><span class="line"></span><br><span class="line">    修改readme ---补充提交信息</span><br></pre></td></tr></table></figure><p>可以像下面这样操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ git add B.java <span class="comment"># 新增遗漏的文件</span></span><br><span class="line"></span><br><span class="line">$ git commit -m <span class="string">&#x27;新增A.java和B.java&#x27;</span> --amend <span class="comment"># 通过amend参数提交</span></span><br><span class="line">[master a824b78] 新增A.java和B.java</span><br><span class="line"> Date: Thu Mar 21 14:42:40 2024 +0800</span><br><span class="line"> 2 files changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 A.java</span><br><span class="line"> create mode 100644 B.java</span><br><span class="line"></span><br><span class="line">$ git <span class="built_in">log</span> -2</span><br><span class="line">commit a824b78efb10b0148ad23d6d730797697422df84 (HEAD -&gt; master)</span><br><span class="line">Author: slimterry &lt;slimterry@qq.com&gt;</span><br><span class="line">Date:   Thu Mar 21 14:42:40 2024 +0800</span><br><span class="line"></span><br><span class="line">    新增A.java和B.java <span class="comment"># 最终只有一次提交记录（覆盖）</span></span><br><span class="line"></span><br><span class="line">commit f1a30024cee279c169888a51a1fc214bb36c561a</span><br><span class="line">Author: slimterry &lt;slimterry@qq.com&gt;</span><br><span class="line">Date:   Thu Mar 21 14:18:08 2024 +0800</span><br><span class="line"></span><br><span class="line">    修改readme ---补充提交信息 </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最终你只会有一个提交 - 第二次提交将覆盖第一次提交的结果。</p><h3 id="取消暂存的文件">取消暂存的文件</h3><p>假设你已经修改了两个文件<code>A.java</code>和<code>B.java</code>并且想要将它们作为<strong>两次独立的修改提交</strong>，但是却意外地输入了 <code>git add *</code> 暂存了它们两个<br>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git restore &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">        modified:   A.java</span><br><span class="line">        modified:   B.java</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">&quot;git add&quot;</span> and/or <span class="string">&quot;git commit -a&quot;</span></span><br><span class="line"></span><br><span class="line">$ git add * <span class="comment"># 意外直接提交了所有改动</span></span><br><span class="line">git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git restore --staged &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line">        modified:   A.java</span><br><span class="line">        modified:   B.java</span><br></pre></td></tr></table></figure><p>如何只取消暂存两个中的一个呢？ <code>git status</code> 命令提示了你<code>use &quot;git restore --staged &lt;file&gt;...&quot; to unstage</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git restore --staged B.java <span class="comment"># 将B.java从暂存中移除</span></span><br></pre></td></tr></table></figure><p>此时再次查看仓库的状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git restore --staged &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line">        modified:   A.java</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git restore &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">        modified:   B.java <span class="comment"># B.java已经变为未暂存的状态</span></span><br></pre></td></tr></table></figure><h3 id="撤消对文件的修改">撤消对文件的修改</h3><p>如果你并不想保留对 <code>B.java</code> 文件的修改怎么办？ 你该如何方便地撤消修改 - 将它还原成上次提交时的样子（或者刚克隆完的样子，或者刚把它放入工作目录时的样子）？</p><p><code>git status</code>的结果中给出了方法<code>use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git restore --staged &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line">        modified:   A.java</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git restore &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">        modified:   B.java</span><br><span class="line">        </span><br><span class="line">$ git restore B.java <span class="comment"># 撤消对文件的修改</span></span><br></pre></td></tr></table></figure><blockquote><p>注意</p><ul class="lvl-1"><li class="lvl-2">此处的<code>git restore</code>撤销的是针对<strong>未暂存文件</strong>的修改</li></ul></blockquote><h2 id="远程仓库的使用">远程仓库的使用</h2><h3 id="查看远程仓库">查看远程仓库</h3><p>如果想查看你已经配置的远程仓库服务器，可以运行 <code>git remote</code> 命令。 它会列出你指定的每一个远程服务器的简写。 如果你已经克隆了自己的仓库，那么至少应该能看到 <code>origin</code> - 这是 Git 给你克隆的仓库服务器的默认名字：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">gitee   https://gitee.com/terrylikescoding/terrylikescoding.git (fetch)</span><br><span class="line">gitee   https://gitee.com/terrylikescoding/terrylikescoding.git (push)</span><br><span class="line">gitlab  https://gitlab.com/terrylikescoding/terrylikescoding.gitlab.io.git (fetch)</span><br><span class="line">gitlab  https://gitlab.com/terrylikescoding/terrylikescoding.gitlab.io.git (push)</span><br><span class="line">origin  git@github.com:terrylikescoding/hexo-deployer.git (fetch)</span><br><span class="line">origin  git@github.com:terrylikescoding/hexo-deployer.git (push)</span><br></pre></td></tr></table></figure><blockquote><p>选项 <code>-v</code>，会显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL</p><p>若不使用<code>-v</code>,则输出如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git remote</span><br><span class="line">gitee</span><br><span class="line">gitlab</span><br><span class="line">origin</span><br></pre></td></tr></table></figure></blockquote><h3 id="添加远程仓库">添加远程仓库</h3><p>通过如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add &lt;shortname&gt; &lt;url&gt;</span><br></pre></td></tr></table></figure><p>比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git remote</span><br><span class="line">origin <span class="comment"># 原先只有一个远程仓库</span></span><br><span class="line"></span><br><span class="line">$ git remote add pb https://github.com/paulboone/ticgit <span class="comment"># 关联新的远程仓库</span></span><br><span class="line"></span><br><span class="line">$ git remote -v</span><br><span class="line">originhttps://github.com/schacon/ticgit (fetch)</span><br><span class="line">originhttps://github.com/schacon/ticgit (push)</span><br><span class="line">pbhttps://github.com/paulboone/ticgit (fetch) <span class="comment"># pb</span></span><br><span class="line">pbhttps://github.com/paulboone/ticgit (push)</span><br></pre></td></tr></table></figure><p>现在你可以在命令行中使用字符串 <code>pb</code> 来代替整个 URL。 例如，如果你想拉取 Paul 的仓库中有但你没有的信息，可以运行 <code>git fetch pb</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch pb</span><br><span class="line">remote: Counting objects: 43, <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (36/36), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 43 (delta 10), reused 31 (delta 5)</span><br><span class="line">Unpacking objects: 100% (43/43), <span class="keyword">done</span>.</span><br><span class="line">From https://github.com/paulboone/ticgit</span><br><span class="line"> * [new branch]      master     -&gt; pb/master</span><br><span class="line"> * [new branch]      ticgit     -&gt; pb/ticgit</span><br></pre></td></tr></table></figure><h3 id="从远程仓库中抓取与拉取">从远程仓库中抓取与拉取</h3><p>从远程仓库中获得数据，可以执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch [remote-name]</span><br></pre></td></tr></table></figure><p>这个命令会访问远程仓库，从中拉取所有你还没有的数据。 执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。</p><p>如果你使用 <code>clone</code> 命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以 <code>origin</code>”为简写。 所以，<code>git fetch origin</code> 会抓取克隆（或上一次抓取）后新推送的所有工作。 必须注意 <code>git fetch</code> 命令会将数据拉取到你的本地仓库 - 但是它并<strong>不会自动合并或修改你当前的工作</strong>。 当准备好时你<strong>必须手动将其合并</strong>入你的工作。</p><p>使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure><p>命令来<strong>自动</strong>的抓取然后<strong>合并</strong>远程分支到当前分支,如果有冲突需要手动解决。默认情况下，<code>git clone</code> 命令会自动设置本地 <code>master</code> 分支跟踪克隆的远程仓库的 <code>master</code> 分支（或不管是什么名字的默认分支，有可能是<code>main</code>）。 运行 <code>git pull</code> 通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。</p><h3 id="推送到远程仓库">推送到远程仓库</h3><p>当你想分享你的项目时，必须将其推送到上游。 这个命令很简单：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push [remote-name] [branch-name]</span><br></pre></td></tr></table></figure><p>当你想要将 <code>master</code> 分支推送到 <code>origin</code> 服务器时，那么运行这个命令就可以将你所做的备份到服务器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure><p>只有当你<strong>有</strong>所克隆服务器的<strong>写入权限</strong>，并且<strong>之前没有人推送过时</strong>，这条命令才能生效。当你和其他人在同一时间克隆，他们先推送到上游然后你再推送到上游，你的推送就会毫无疑问地被拒绝。 <strong>你必须先将他们的工作拉取下来并将其合并进你的工作后才能推送</strong>。</p><h3 id="查看远程仓库-2">查看远程仓库</h3><p>如果想要查看某一个远程仓库的<strong>更多信息</strong>，可以使用 <code>git remote show [remote-name]</code> 命令。 如果想以一个特定的缩写名运行这个命令，例如 <code>origin</code>，会得到像下面类似的信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git remote show origin</span><br><span class="line">* remote origin</span><br><span class="line">  Fetch URL: git@github.com:terrylikescoding/hexo-deployer.git</span><br><span class="line">  Push  URL: git@github.com:terrylikescoding/hexo-deployer.git</span><br><span class="line">  HEAD branch: master</span><br><span class="line">  Remote branch:</span><br><span class="line">    master tracked</span><br><span class="line">  Local branch configured <span class="keyword">for</span> <span class="string">&#x27;git pull&#x27;</span>:</span><br><span class="line">    master merges with remote master</span><br><span class="line">  Local ref configured <span class="keyword">for</span> <span class="string">&#x27;git push&#x27;</span>:</span><br><span class="line">    master pushes to master (fast-forwardable)</span><br></pre></td></tr></table></figure><h3 id="远程仓库的移除和重命令">远程仓库的移除和重命令</h3><p>如果想要重命名引用的名字可以运行 <code>git remote rename</code> 去修改一个远程仓库的简写名。 例如，想要将 <code>pb</code> 重命名为 <code>paul</code>，可以用 <code>git remote rename</code> 这样做：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git remote rename pb paul</span><br><span class="line">$ git remote</span><br><span class="line">origin</span><br><span class="line">paul <span class="comment"># 已经被重命名为paul</span></span><br></pre></td></tr></table></figure><p>值得注意的是这同样也会修改你的远程分支名字。 那些过去引用 <code>pb/master</code> 的现在会引用 <code>paul/master</code>。</p><p>如果因为一些原因想要移除一个远程仓库 - 你已经从服务器上搬走了或不再想使用某一个特定的镜像了，又或者某一个贡献者不再贡献了 - 可以使用 <code>git remote rm</code> ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote <span class="built_in">rm</span> paul</span><br><span class="line">$ git remote</span><br><span class="line">origin</span><br></pre></td></tr></table></figure><h2 id="标签">标签</h2><p>Git 可以给历史中的某一个提交打上标签，<strong>以示重要</strong>。 比较有代表性的是人们会使用这个功能来标记发布结点（<strong>v1.0</strong> 等等）。</p><h3 id="列出标签">列出标签</h3><p>在 Git 中列出已有的标签是非常简单直观的。 只需要输入 <code>git tag</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git tag</span><br><span class="line">v1.0</span><br><span class="line">v1.1</span><br><span class="line">v1.1-preview</span><br></pre></td></tr></table></figure><p>这个命令以<strong>字母顺序</strong>列出标签；但是它们出现的顺序并不重要。</p><p>你也可以使用特定的模式查找标签。 例如，Git 自身的源代码仓库包含标签的数量超过 500 个。 如果只对 1.8.5 系列感兴趣，可以运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -l <span class="string">&#x27;关键字&#x27;</span></span><br></pre></td></tr></table></figure><blockquote><p><code>-l</code> or <code>--list</code></p><p>List tags. With optional <code>&lt;pattern&gt;...</code>, e.g. <code>git tag --list 'v-*'</code>, list only the tags <strong>that match the pattern(s)</strong>.</p><p>Running “git tag” <strong>without arguments also lists all tags</strong>. The pattern is a shell wildcard (i.e., matched using fnmatch(3)). <strong>Multiple patterns may be given</strong>; if any of them matches, the tag is shown.</p></blockquote><p>比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -l <span class="string">&#x27;*preview&#x27;</span></span><br><span class="line">v1.1-preview</span><br></pre></td></tr></table></figure><p>注意：通过<code>git tag -l 'preview'</code>并<strong>不能</strong>匹配到上面的记录<code>v1.1-preview</code></p><h3 id="创建标签">创建标签</h3><p>Git 使用两种主要类型的标签：<strong>轻量标签</strong>（<strong>lightweight</strong>）与<strong>附注标签</strong>（<strong>annotated</strong>）。</p><p>一个<strong>轻量标签</strong>很像一个<strong>不会改变的分支</strong> - 它只是<strong>一个特定提交的引用</strong>。</p><p>然而，<strong>附注标签</strong>是存储在 Git 数据库中的<strong>一个完整对象</strong>。 它们是<strong>可以被校验</strong>的；其中包含</p><ol><li class="lvl-3"><p>打标签者的名字、电子邮件地址、日期时间；</p></li><li class="lvl-3"><p>还有一个标签信息；并且可以使用 GNU Privacy Guard （GPG）签名与验证。 <strong>通常建议创建附注标签</strong>，这样你可以拥有以上所有信息；但是如果你只是想用一个临时的标签，或者因为某些原因不想要保存那些信息，轻量标签也是可用的。</p></li></ol><h4 id="附注标签">附注标签</h4><p>在 Git 中创建一个附注标签是很简单的。 最简单的方式是当你在运行 <code>tag</code> 命令时指定 <code>-a</code> 选项：</p><blockquote><ul class="lvl-1"><li class="lvl-2"><p><code>-a</code> or <code>--annotate</code> : Make an unsigned, <strong>annotated</strong> tag object</p></li><li class="lvl-2"><p><code>-m &lt;msg&gt;</code> or <code>--message=&lt;msg&gt;</code>:Use the given tag message (instead of prompting). If multiple <code>-m</code> options are given, their values are concatenated as separate paragraphs. Implies <code>-a</code> if none of <code>-a</code>, <code>-s</code>, or <code>-u &lt;key-id&gt;</code> is given.</p></li></ul></blockquote><p>比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -a v1.0 -m <span class="string">&#x27;初始版本v1.0&#x27;</span></span><br><span class="line">$ git tag</span><br><span class="line">v1.0</span><br></pre></td></tr></table></figure><p>注意：</p><ul class="lvl-0"><li class="lvl-2"><p>对于同一个版本，可以添加多个标签。</p></li></ul><h4 id="轻量标签">轻量标签</h4><p>另一种给提交打标签的方式是使用轻量标签。 轻量标签本质上是将提交校验和存储到一个文件中 - 没有保存任何其他信息。 创建轻量标签，不需要使用 <code>-a</code>、<code>-s</code> 或 <code>-m</code> 选项，只需要提供标签名字：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git tag v1.1-preview</span><br><span class="line">$ git tag</span><br><span class="line">v1.0  <span class="comment"># 附注标签</span></span><br><span class="line">v1.1-preview <span class="comment"># 轻量标签</span></span><br></pre></td></tr></table></figure><h3 id="查看标签详细信息">查看标签详细信息</h3><p>通过使用 <code>git show</code> 命令可以看到标签信息，对于上述<a href="#%E5%88%9B%E5%BB%BA%E6%A0%87%E7%AD%BE">创建标签</a>章节中创建的<strong>附注标签</strong>，其显示结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ git show v1.0</span><br><span class="line">tag v1.0</span><br><span class="line">Tagger: slimterry &lt;slimterry@qq.com&gt;</span><br><span class="line">Date:   Fri Mar 22 10:22:25 2024 +0800</span><br><span class="line"></span><br><span class="line">初始版本v1.0 <span class="comment"># 创建标签时的message</span></span><br><span class="line"></span><br><span class="line">commit a824b78efb10b0148ad23d6d730797697422df84 (HEAD -&gt; master, tag: v1.1-preview, tag: v1.1, tag: v1.0)</span><br><span class="line">Author: slimterry &lt;slimterry@qq.com&gt;</span><br><span class="line">Date:   Thu Mar 21 14:42:40 2024 +0800</span><br><span class="line"></span><br><span class="line">    新增A.java和B.java</span><br><span class="line"></span><br><span class="line">diff --git a/A.java b/A.java</span><br><span class="line">new file mode 100644</span><br><span class="line">index 0000000..e69de29</span><br><span class="line">diff --git a/B.java b/B.java</span><br><span class="line">new file mode 100644</span><br><span class="line">index 0000000..e69de29</span><br></pre></td></tr></table></figure><p>对于<a href="#%E5%88%9B%E5%BB%BA%E6%A0%87%E7%AD%BE">创建标签</a>章节中创建的轻量标签，其结果显示如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git show v1.1-preview</span><br><span class="line">commit a824b78efb10b0148ad23d6d730797697422df84 (HEAD -&gt; master, tag: v1.1-preview, tag: v1.1, tag: v1.0)</span><br><span class="line">Author: slimterry &lt;slimterry@qq.com&gt;</span><br><span class="line">Date:   Thu Mar 21 14:42:40 2024 +0800</span><br><span class="line"></span><br><span class="line">    新增A.java和B.java</span><br><span class="line"></span><br><span class="line">diff --git a/A.java b/A.java</span><br><span class="line">new file mode 100644</span><br><span class="line">index 0000000..e69de29</span><br><span class="line">diff --git a/B.java b/B.java</span><br><span class="line">new file mode 100644</span><br><span class="line">index 0000000..e69de29</span><br></pre></td></tr></table></figure><p>附注标签比轻量标签多了如下的信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Tagger: slimterry &lt;slimterry@qq.com&gt;</span><br><span class="line">Date:   Fri Mar 22 10:22:25 2024 +0800</span><br><span class="line"></span><br><span class="line">初始版本v1.0 <span class="comment"># 创建标签时的message</span></span><br></pre></td></tr></table></figure><p>即多显示了<strong>打标签者</strong>的信息、打标签的日期时间、附注信息。</p><p>注意：<code>git show</code>是一个多功能命令，可以用来查看git中多种对象的信息，其在git官方文档中的描述如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git show [&lt;options&gt;] [&lt;object&gt;…]</span><br></pre></td></tr></table></figure><blockquote><p>Shows one or more objects (blobs, trees, <strong>tags</strong> and <strong>commits</strong>).</p><p>For commits it <strong>shows the log message and textual diff.</strong> It also presents the merge commit in a special format as produced by <em>git diff-tree --cc</em>.</p><p>For tags, it shows t<strong>he tag message and the referenced objects</strong>.</p><p>For trees, it shows the names (equivalent to <em>git ls-tree</em> with --name-only).</p><p>For plain blobs, it shows the plain contents.</p><p>Some options that <em>git log</em> command understands can be used to control how the changes the commit introduces are shown.</p></blockquote><h3 id="删除标签">删除标签</h3><p>通过<code>git tag -d</code>可以删除标签：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git tag</span><br><span class="line">v1.0</span><br><span class="line">v1.1</span><br><span class="line">v1.1-preview</span><br><span class="line"></span><br><span class="line">$ git tag -d v1.1</span><br><span class="line">Deleted tag <span class="string">&#x27;v1.1&#x27;</span> (was c7e2557)</span><br></pre></td></tr></table></figure><h3 id="为过去的某个版本打标签">为过去的某个版本打标签</h3><p>上述的创建的标签都是在当前的版本创建的，如果希望给过去的某个版本打标签，这么操作：</p><p>首先找到需要补充tag的版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --oneline</span><br><span class="line">a824b78 (HEAD -&gt; master, tag: v1.1-preview, tag: v1.0) 新增A.java和B.java</span><br><span class="line">f1a3002 修改readme ---补充提交信息</span><br><span class="line">32b941f 重命名Readme.md</span><br><span class="line">8baa801 删除fetch.js</span><br><span class="line">9990b44 删除robot.txt</span><br><span class="line">de8fb67 添加robot.txt</span><br></pre></td></tr></table></figure><p>通过为<code>git tag</code>添加<strong>commit id</strong> 即可实现：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -a v0.6 -m <span class="string">&#x27;版本v0.6,删除fetch.js&#x27;</span> 8baa801</span><br><span class="line"></span><br><span class="line">$ git tag</span><br><span class="line">v0.6     <span class="comment"># 补充的tag</span></span><br><span class="line">v1.0</span><br><span class="line">v1.1-preview</span><br></pre></td></tr></table></figure><h3 id="推送标签到远端">推送标签到远端</h3><p>默认情况下，<code>git push</code> 命令并<strong>不会</strong>传送标签到远程仓库服务器上。 在创建完标签后你必<strong>须显式地推送</strong>标签到共享服务器上。 这个过程就像共享远程分支一样 ，你可以运行 <code>git push origin [tagname]</code>。</p><p>比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin v1.5 <span class="comment"># v1.5 为tag名称</span></span><br><span class="line">Counting objects: 14, <span class="keyword">done</span>.</span><br><span class="line">Delta compression using up to 8 threads.</span><br><span class="line">Compressing objects: 100% (12/12), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (14/14), 2.05 KiB | 0 bytes/s, <span class="keyword">done</span>.</span><br><span class="line">Total 14 (delta 3), reused 0 (delta 0)</span><br><span class="line">To git@github.com:schacon/simplegit.git</span><br><span class="line"> * [new tag]         v1.5 -&gt; v1.5</span><br></pre></td></tr></table></figure><p>如果想要<strong>一次性推送很多标签</strong>，也可以使用带有 <code>--tags</code> 选项的 <code>git push</code> 命令。 这将会把<strong>所有不在远程仓库服务器上的标签全部传送到那里</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin --tags</span><br><span class="line">Counting objects: 1, <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (1/1), 160 bytes | 0 bytes/s, <span class="keyword">done</span>.</span><br><span class="line">Total 1 (delta 0), reused 0 (delta 0)</span><br><span class="line">To git@github.com:schacon/simplegit.git</span><br><span class="line"> * [new tag]         v1.4 -&gt; v1.4</span><br><span class="line"> * [new tag] </span><br></pre></td></tr></table></figure><p>现在，当其他人从仓库中克隆或拉取，他们也能得到你的那些标签。</p><h3 id="检出远端的标签">检出远端的标签</h3><h4 id="检出标签">检出标签</h4><p>在 Git 中你<strong>并不能真的检出一个标签</strong>，因为它们并不能像分支一样来回移动。 如果你想要工作目录与仓库中特定的标签版本完全一样，可以使用 <code>git checkout -b [branchname] [tagname]</code> 在特定的标签上创建一个新分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b bugfix v2.0.0</span><br><span class="line">Switched to a new branch <span class="string">&#x27;bugfix&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="为git命令设置别名">为git命令设置别名</h2><p>如果不想每次都输入完整的 Git 命令，可以通过 <code>git config</code> 文件来轻松地为每一个命令设置一个别名。比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global alias.co checkout</span><br><span class="line">$ git config --global alias.br branch</span><br><span class="line">$ git config --global alias.ci commit</span><br><span class="line">$ git config --global alias.st status</span><br></pre></td></tr></table></figure><p>此时我们可以直接使用别名，比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git st <span class="comment"># 相当于git status</span></span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><p>也可以为一些繁琐的命令传递参数，比如添加一个<code>last</code>来方便查看最后一次提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.last <span class="string">&#x27;log -1 HEAD&#x27;</span></span><br></pre></td></tr></table></figure><p>这样，可以轻松地看到最后一次提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git last</span><br><span class="line">commit a824b78efb10b0148ad23d6d730797697422df84 (HEAD -&gt; master, tag: v1.1-preview, tag: v1.0)</span><br><span class="line">Author: slimterry &lt;slimterry@qq.com&gt;</span><br><span class="line">Date:   Thu Mar 21 14:42:40 2024 +0800</span><br><span class="line"></span><br><span class="line">    新增A.java和B.java</span><br></pre></td></tr></table></figure><p>可以看出，Git 只是<strong>简单地</strong>将别名<strong>替换</strong>为对应的命令。 然而，你可能想要执行<strong>外部命令</strong>，而不是一个 Git 子命令。 如果是那样的话，可以在命令前面加入 <code>!</code> 符号。 如果你自己要写一些与 Git 仓库协作的工具的话，那会很有用。 我们现在演示将 <code>git visual</code> 定义为 <code>gitk</code> 的别名：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global alias.visual <span class="string">&#x27;!gitk&#x27;</span></span><br></pre></td></tr></table></figure><p>设置完成后，就可以通过如下命令调用<code>gitk</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git visual</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>根据package-lock文件批量下载某个包的所有依赖</title>
      <link href="/2024/01/10/%E6%A0%B9%E6%8D%AEpackage-lock%E6%96%87%E4%BB%B6%E6%89%B9%E9%87%8F%E4%B8%8B%E8%BD%BD%E6%9F%90%E4%B8%AA%E5%8C%85%E7%9A%84%E6%89%80%E6%9C%89%E4%BE%9D%E8%B5%96/"/>
      <url>/2024/01/10/%E6%A0%B9%E6%8D%AEpackage-lock%E6%96%87%E4%BB%B6%E6%89%B9%E9%87%8F%E4%B8%8B%E8%BD%BD%E6%9F%90%E4%B8%AA%E5%8C%85%E7%9A%84%E6%89%80%E6%9C%89%E4%BE%9D%E8%B5%96/</url>
      
        <content type="html"><![CDATA[<h2 id="实现脚本">实现脚本</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> https = <span class="built_in">require</span>(<span class="string">&#x27;https&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> folderPath = <span class="string">&#x27;./dependency-tars&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断文件夹是否存在</span></span><br><span class="line"><span class="keyword">if</span> (!fs.<span class="title function_">existsSync</span>(folderPath)) &#123;</span><br><span class="line">    <span class="comment">// 如果不存在则创建文件夹</span></span><br><span class="line">    fs.<span class="title function_">mkdirSync</span>(folderPath);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取package-lock.json文件</span></span><br><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&#x27;package-lock.json&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;读取文件出错:&#x27;</span>, err);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> packageLock = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(data);</span><br><span class="line">        <span class="keyword">const</span> dependencies = packageLock.<span class="property">packages</span>;</span><br><span class="line">        <span class="keyword">const</span> tarballUrls = [];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历所有依赖并打印resolved属性的值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> packageName <span class="keyword">in</span> dependencies) &#123;</span><br><span class="line">            <span class="keyword">if</span> (packageName &amp;&amp; dependencies.<span class="title function_">hasOwnProperty</span>(packageName)) &#123;</span><br><span class="line">                <span class="keyword">const</span> dependency = dependencies[packageName];</span><br><span class="line">                <span class="keyword">const</span> resolved = dependency.<span class="property">resolved</span>;</span><br><span class="line">                tarballUrls.<span class="title function_">push</span>(resolved);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`解析完毕，共<span class="subst">$&#123;tarballUrls.length&#125;</span>个依赖，开始下载依赖`</span>);</span><br><span class="line"></span><br><span class="line">        <span class="title function_">downloadFiles</span>(tarballUrls);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;解析JSON出错:&#x27;</span>, error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">downloadFiles</span>(<span class="params">urls</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> url <span class="keyword">of</span> urls) &#123;</span><br><span class="line">        <span class="keyword">const</span> fileName = path.<span class="title function_">basename</span>(url); <span class="comment">// 获取文件名</span></span><br><span class="line">        <span class="keyword">const</span> filePath = path.<span class="title function_">join</span>(folderPath, fileName); <span class="comment">// 将文件名和文件夹路径拼接</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下载文件</span></span><br><span class="line">        <span class="keyword">const</span> file = fs.<span class="title function_">createWriteStream</span>(filePath);</span><br><span class="line">        https.<span class="title function_">get</span>(url, <span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (response.<span class="property">statusCode</span> === <span class="number">200</span>) &#123;</span><br><span class="line">                response.<span class="title function_">pipe</span>(file);</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;fileName&#125;</span>下载成功！`</span>);</span><br><span class="line"></span><br><span class="line">                count++;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (count === urls.<span class="property">length</span>) &#123;</span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;所有文件下载完成。&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (response.<span class="property">statusCode</span> === <span class="number">301</span> || response.<span class="property">statusCode</span> === <span class="number">302</span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> redirectUrl = response.<span class="property">headers</span>.<span class="property">location</span>;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`文件<span class="subst">$&#123;fileName&#125;</span>发生重定向，新的下载链接为: <span class="subst">$&#123;redirectUrl&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">                https.<span class="title function_">get</span>(redirectUrl, <span class="function">(<span class="params">redirectResponse</span>) =&gt;</span> &#123;</span><br><span class="line">                    redirectResponse.<span class="title function_">pipe</span>(file);</span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;fileName&#125;</span>下载成功！`</span>);</span><br><span class="line"></span><br><span class="line">                    count++;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (count === urls.<span class="property">length</span>) &#123;</span><br><span class="line">                        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;所有文件下载完成。&#x27;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).<span class="title function_">on</span>(<span class="string">&#x27;error&#x27;</span>, <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">`下载<span class="subst">$&#123;fileName&#125;</span>出错: <span class="subst">$&#123;error.message&#125;</span>`</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">`下载<span class="subst">$&#123;fileName&#125;</span>出错，状态码为: <span class="subst">$&#123;response.statusCode&#125;</span>`</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).<span class="title function_">on</span>(<span class="string">&#x27;error&#x27;</span>, <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">`下载<span class="subst">$&#123;fileName&#125;</span>出错: <span class="subst">$&#123;error.message&#125;</span>`</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> npm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> npm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo中扩展的MarkDown高级语法</title>
      <link href="/2023/12/22/hexo%E4%B8%AD%E6%89%A9%E5%B1%95%E7%9A%84MarkDown%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/"/>
      <url>/2023/12/22/hexo%E4%B8%AD%E6%89%A9%E5%B1%95%E7%9A%84MarkDown%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1>选项卡-tabs</h1><p><code>markdown</code>中本身不支持tabs,<code>rmarkdown</code>中似乎支持，而<code>hexo</code>中可以通过如下的语法生成tabs</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs First unique name %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 1.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 2.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 3.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><p>渲染后效果如下：</p><div class="tabs" id="first-unique-name"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="first-unique-name-1">First unique name 1</button><button type="button" class="tab " data-href="first-unique-name-2">First unique name 2</button><button type="button" class="tab " data-href="first-unique-name-3">First unique name 3</button></ul><div class="tab-contents"><div class="tab-item-content active" id="first-unique-name-1"><p><strong>This is Tab 1.</strong></p></div><div class="tab-item-content" id="first-unique-name-2"><p><strong>This is Tab 2.</strong></p></div><div class="tab-item-content" id="first-unique-name-3"><p><strong>This is Tab 3.</strong></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><blockquote><p>如上内容参考自：<a href="http://ynotes.cc/2023/02/16/hexo-next-%E5%B8%B8%E7%94%A8tag/#tabs-%E7%AE%80%E4%BB%8B">http://ynotes.cc/2023/02/16/hexo-next-常用tag/#tabs-简介</a></p></blockquote><p><a href="https://blog.ccknbc.cc/posts/introduction-of-plugin-tags-based-on-butterfly/">这里</a>可以找到更多的关于hexo支持的标签。</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot系列-02-helloworld示例(测试自动部署)</title>
      <link href="/2023/12/17/SpringBoot%E7%B3%BB%E5%88%97-02-helloworld%E7%A4%BA%E4%BE%8B/"/>
      <url>/2023/12/17/SpringBoot%E7%B3%BB%E5%88%97-02-helloworld%E7%A4%BA%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h1>创建一个maven项目</h1><p><img src="image-20220114132553579.png" alt="image-20220114132553579"></p><h1>在pom文件中引入SpringBoot父工程依赖</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><h1>在pom文件中添加所需依赖</h1><p>本例是一个Web项目，所以只需要引入web相关的依赖，即</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h1>编写SpringBoot的启动类</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lip.boot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MainApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>以上是SpringBoot启动类的<strong>固定写法</strong>，其中<code>@SpringBootApplication</code>告诉Spring,这是一个SpringBoot应用。</p></blockquote><h1>编写业务逻辑</h1><p>SpringBoot中编写控制器以及其他代码时，与编写SpringMVC的代码无区别</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello from SpringBoot!!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注：</p><ul class="lvl-1"><li class="lvl-2"><p>通过<code>@ResponseBody</code>告诉spring将返回结果放到响应体中，而不是通过视图解析器进行跳转。</p></li><li class="lvl-2"><p>如果某个控制器的所有控制器方法都会将响应内容写到响应体中，则可以将<code>@ResponseBody</code>标注到类上，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123; </span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello from SpringBoot!!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个注解可以使用注解<code>@RestController</code>代替</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello from SpringBoot!!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为<code>@RestController</code>是一个合成注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RestController &#123;</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h1>编写SpringBoot配置文件application.properties</h1><p>SpringBoot的<strong>所有配置</strong>都写在<strong>application.properties</strong>中：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.port=8888</span><br></pre></td></tr></table></figure><h1>将项目发布为一个可执行的jar</h1><p>首先需要在pom中引入如下插件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后通过maven的<code>package</code>即可将项目打包成一个可执行的jar。</p><p><img src="image-20220114140055988.png" alt="image-20220114140055988"></p><p>控制台中：</p><p><img src="image-20220114140148864.png" alt="image-20220114140148864"></p><p>此时到对应路径下，找到jar包，通过命令 <code>java -jar SpringBoot01-HelloWord-1.0-SNAPSHOT.jar</code>即可启动jar包：</p><p><img src="image-20220114140431321.png" alt="image-20220114140431321"></p><p>此时通过浏览器访问：</p><p><img src="image-20220114140500203.png" alt="image-20220114140500203"></p>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot系列-01-简介</title>
      <link href="/2023/12/17/SpringBoot%E7%B3%BB%E5%88%97-01-%E7%AE%80%E4%BB%8B/"/>
      <url>/2023/12/17/SpringBoot%E7%B3%BB%E5%88%97-01-%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1>Spring与SpringBoot</h1><h2 id="Spring可以做什么？">Spring可以做什么？</h2><p><img src="image-20220113132818021.png" alt="image-20220113132818021"></p><p>spring的生态覆盖了：</p><ul class="lvl-0"><li class="lvl-2"><p>web开发</p></li><li class="lvl-2"><p>数据访问</p></li><li class="lvl-2"><p>安全控制</p></li><li class="lvl-2"><p>分布式</p></li><li class="lvl-2"><p>消息服务</p></li><li class="lvl-2"><p>移动开发</p></li><li class="lvl-2"><p>批处理</p></li></ul><h1>Spring5重大升级</h1><h2 id="响应式编程">响应式编程</h2><p><img src="image-20220113133134231.png" alt="image-20220113133134231"></p><h2 id="内部源码设计">内部源码设计</h2><p>基于Java8的一些新特性，如：<strong>接口默认实现</strong>。重新设计源码架构</p><blockquote><p>有了接口默认实现，原先的适配器模式就失去意义了。</p></blockquote><h1>为什么使用SpringBoot?</h1><blockquote><p>Spring Boot makes it easy to create stand-alone, production-grade Spring based Applications that you can “just run”.</p></blockquote><p><strong>Spring Boot</strong>能快速创建出生产级别的Spring应用。</p><h2 id="Spring-Boot的优点">Spring Boot的优点</h2><ul class="lvl-0"><li class="lvl-2"><p>Create stand-alone Spring applications</p></li><li class="lvl-2"><ul class="lvl-2"><li class="lvl-4">创建<strong>独立</strong>Spring应用</li></ul></li><li class="lvl-2"><p>Embed <strong>Tomcat</strong>, <strong>Jetty</strong> or <strong>Undertow</strong> directly (<strong>no need to deploy WAR files</strong>)</p></li><li class="lvl-2"><ul class="lvl-2"><li class="lvl-4">内嵌web服务器</li></ul></li><li class="lvl-2"><p>Provide opinionated ‘<strong>starter</strong>’ dependencies to simplify your build configuration</p></li><li class="lvl-2"><ul class="lvl-2"><li class="lvl-4">自动<strong>starter</strong>依赖，简化构建配置</li></ul></li><li class="lvl-2"><p>Automatically configure Spring and 3rd party libraries whenever possible</p></li><li class="lvl-2"><ul class="lvl-2"><li class="lvl-4">自动配置Spring以及第三方功能</li></ul></li><li class="lvl-2"><p>Provide production-ready features such as metrics, health checks, and externalized configuration</p></li><li class="lvl-2"><ul class="lvl-2"><li class="lvl-4">提供生产级别的监控、健康检查及外部化配置</li></ul></li><li class="lvl-2"><p>Absolutely no code generation and no requirement for XML configuration</p></li><li class="lvl-2"><ul class="lvl-2"><li class="lvl-4">无代码生成、无需编写XML</li></ul></li></ul><blockquote><ul class="lvl-1"><li class="lvl-2"><p>SpringBoot是整合Spring技术栈的一站式框架</p></li><li class="lvl-2"><p>SpringBoot是简化Spring技术栈的快速开发脚手架</p></li></ul></blockquote><h2 id="Spring-Boot的缺点？">Spring Boot的缺点？</h2><ul class="lvl-0"><li class="lvl-2"><p>人称版本帝，迭代快，需要时刻关注变化</p></li><li class="lvl-2"><p>封装太深，内部原理复杂，不容易精通</p></li></ul><h1>SpringBoot的时代背景</h1><h2 id="微服务">微服务</h2><p><a href="https://martinfowler.com/articles/microservices.html">James Lewis and Martin Fowler (2014)</a>  提出微服务完整概念。<a href="https://martinfowler.com/microservices/">https://martinfowler.com/microservices/</a></p><blockquote><p>In short, the <strong>microservice architectural style</strong> is an approach to developing a single application as a <strong>suite of small services</strong>, each <strong>running in its own process</strong> and communicating with <strong>lightweight</strong> mechanisms, often an <strong>HTTP</strong> resource API. These services are <strong>built around business capabilities</strong> and <strong>independently deployable</strong> by fully <strong>automated deployment</strong> machinery. There is a <strong>bare minimum of centralized management</strong> of these services, which may be <strong>written in different programming languages</strong> and use different data storage technologies.-- <a href="https://martinfowler.com/articles/microservices.html">James Lewis and Martin Fowler (2014)</a></p></blockquote><ul class="lvl-0"><li class="lvl-2"><p>微服务是一种架构风格</p></li><li class="lvl-2"><p>一个应用拆分为一组<strong>小型服务</strong></p></li><li class="lvl-2"><p>每个服务运行在自己的进程内，也就是可独立部署和升级</p></li><li class="lvl-2"><p>服务之间使用轻量级<strong>HTTP</strong>交互</p></li><li class="lvl-2"><p>服务围绕业务功能拆分</p></li><li class="lvl-2"><p>可以由全自动部署机制独立部署</p></li><li class="lvl-2"><p><strong>去中心化</strong>，服务自治。服务可以使用不同的语言、不同的存储技术</p></li></ul><h2 id="分布式">分布式</h2><p><img src="image-20220113134537059.png" alt="image-20220113134537059"></p><h3 id="分布式中的难题">分布式中的难题</h3><ul class="lvl-0"><li class="lvl-2"><p>远程调用</p></li><li class="lvl-2"><p>服务发现</p></li><li class="lvl-2"><p>负载均衡</p></li><li class="lvl-2"><p>服务容错</p></li><li class="lvl-2"><p>配置管理</p></li><li class="lvl-2"><p>服务监控</p></li><li class="lvl-2"><p>链路追踪</p></li><li class="lvl-2"><p>日志管理</p></li><li class="lvl-2"><p>任务调度</p></li></ul><h3 id="分布式难题的解决方法">分布式难题的解决方法</h3><p>SpringBoot + SpringCloud</p><p><img src="image-20220113135220799.png" alt="image-20220113135220799"></p><h2 id="云原生Cloud-Native">云原生Cloud Native</h2><h3 id="上云的困难">上云的困难</h3><ul class="lvl-0"><li class="lvl-2"><p>服务自愈</p></li><li class="lvl-2"><p>弹性伸缩</p></li><li class="lvl-2"><p>服务隔离</p></li><li class="lvl-2"><p>自动化部署</p></li><li class="lvl-2"><p>灰度发布</p></li><li class="lvl-2"><p>流量治理</p></li><li class="lvl-2"><p>…</p></li></ul><h3 id="如何解决上云的困难">如何解决上云的困难</h3><p><img src="image-20220114095416456.png" alt="image-20220114095416456.png"></p>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
